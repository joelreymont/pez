//! Main decompilation logic.
//!
//! Combines CFG analysis, control flow detection, and stack simulation
//! to reconstruct Python source code from bytecode.

const std = @import("std");
const Allocator = std.mem.Allocator;
const ast = @import("ast.zig");
const cfg_mod = @import("cfg.zig");
const ctrl = @import("ctrl.zig");
const decoder = @import("decoder.zig");
const dom_mod = @import("dom.zig");
const stack_mod = @import("stack.zig");
const sc_pass = @import("sc_pass.zig");
const pyc = @import("pyc.zig");
const codegen = @import("codegen.zig");
const name_mangle = @import("name_mangle.zig");
const signature = @import("signature.zig");
const test_utils = @import("test_utils.zig");

pub const CFG = cfg_mod.CFG;
pub const BasicBlock = cfg_mod.BasicBlock;
pub const Analyzer = ctrl.Analyzer;
pub const SimContext = stack_mod.SimContext;
pub const Version = decoder.Version;
pub const Expr = ast.Expr;
pub const Stmt = ast.Stmt;
const ExprContext = ast.ExprContext;
const StackValue = stack_mod.StackValue;
const Opcode = decoder.Opcode;
pub const DecompileError = stack_mod.SimError || std.fs.File.WriteError || std.Io.Writer.Error || std.json.Stringify.Error || error{
    UnknownExpr,
    UnexpectedEmptyWorklist,
    InvalidBlock,
    SkipStatement,
    PatternNoMatch,
};

/// Check if an opcode is a LOAD instruction.
fn isLoadInstr(op: Opcode) bool {
    return switch (op) {
        .LOAD_NAME, .LOAD_FAST, .LOAD_GLOBAL, .LOAD_DEREF, .LOAD_FAST_BORROW, .LOAD_FAST_CHECK => true,
        else => false,
    };
}

fn isInplaceOpcode(op: Opcode) bool {
    return switch (op) {
        .INPLACE_ADD,
        .INPLACE_SUBTRACT,
        .INPLACE_MULTIPLY,
        .INPLACE_MODULO,
        .INPLACE_POWER,
        .INPLACE_TRUE_DIVIDE,
        .INPLACE_FLOOR_DIVIDE,
        .INPLACE_LSHIFT,
        .INPLACE_RSHIFT,
        .INPLACE_AND,
        .INPLACE_XOR,
        .INPLACE_OR,
        .INPLACE_MATRIX_MULTIPLY,
        .INPLACE_DIVIDE,
        => true,
        else => false,
    };
}

fn storeAttrAug(instructions: []const decoder.Instruction, idx: usize) bool {
    if (idx == 0) return false;
    var saw_swap = false;
    var scan: isize = @as(isize, @intCast(idx)) - 1;
    while (scan >= 0) : (scan -= 1) {
        const inst = instructions[@intCast(scan)];
        switch (inst.opcode) {
            .CACHE, .NOT_TAKEN, .EXTENDED_ARG => continue,
            else => {},
        }
        if (!saw_swap) {
            if (inst.opcode == .ROT_TWO or (inst.opcode == .SWAP and inst.arg == 2)) {
                saw_swap = true;
                continue;
            }
            return false;
        }
        return isInplaceOpcode(inst.opcode);
    }
    return false;
}

/// Error context for debugging.
pub const ErrorContext = struct {
    code_name: []const u8,
    block_id: u32,
    offset: u32,
    opcode: []const u8,
};

pub const DecompileOptions = struct {
    focus: ?[]const u8 = null,
    align_defs: bool = false,
    trace_loop_guards: bool = false,
    trace_sim_block: ?u32 = null,
    trace_decisions: bool = false,
    trace_stackflow: bool = false,
    trace_blocks: bool = false,
    trace_file: ?std.fs.File = null,
};

const DecompKind = enum {
    module,
    function,
};

const DecompPipeline = struct {
    allocator: Allocator,
    code: *const pyc.Code,
    version: Version,
    opts: DecompileOptions,
    kind: DecompKind,
    decompiler: ?Decompiler = null,
    raw_stmts: ?[]const *Stmt = null,
    stmts: ?[]const *Stmt = null,

    fn init(
        allocator: Allocator,
        code: *const pyc.Code,
        version: Version,
        opts: DecompileOptions,
        kind: DecompKind,
    ) DecompPipeline {
        return .{
            .allocator = allocator,
            .code = code,
            .version = version,
            .opts = opts,
            .kind = kind,
        };
    }

    fn deinit(self: *DecompPipeline) void {
        if (self.decompiler) |*d| {
            d.deinit();
        }
        self.decompiler = null;
    }

    fn ensureAnalyze(self: *DecompPipeline) DecompileError!void {
        if (self.decompiler != null) return;
        var decomp = try Decompiler.initWithOptions(self.allocator, self.code, self.version, self.opts);
        if (self.opts.trace_sim_block) |bid| {
            try decomp.traceSimBlock(bid);
        }
        self.decompiler = decomp;
    }

    fn ensureDecompile(self: *DecompPipeline, err_writer: ?std.fs.File) DecompileError!void {
        try self.ensureAnalyze();
        if (self.raw_stmts != null) return;
        const decomp = &self.decompiler.?;
        self.raw_stmts = decomp.decompile() catch |err| {
            try reportDecompileError(err_writer, decomp, err);
            return err;
        };
    }

    fn ensureRewrite(self: *DecompPipeline, err_writer: ?std.fs.File) DecompileError!void {
        try self.ensureDecompile(err_writer);
        if (self.stmts != null) return;
        const decomp = &self.decompiler.?;
        const raw = self.raw_stmts.?;
        self.stmts = switch (self.kind) {
            .module => try rewriteModuleStmts(decomp, raw),
            .function => try rewriteFunctionStmts(decomp, raw),
        };
    }
};

fn reportDecompileError(err_writer: ?std.fs.File, decompiler: *const Decompiler, err: anyerror) !void {
    if (err_writer) |ew| {
        if (decompiler.last_error_ctx) |ctx| {
            var buf: [256]u8 = undefined;
            const msg = try std.fmt.bufPrint(&buf, "Error in {s} at offset {d} ({s}): {s}\n", .{
                ctx.code_name,
                ctx.offset,
                ctx.opcode,
                @errorName(err),
            });
            _ = try ew.write(msg);
        } else {
            var buf: [128]u8 = undefined;
            const msg = try std.fmt.bufPrint(&buf, "Error: {s}\n", .{@errorName(err)});
            _ = try ew.write(msg);
        }
    }
}

fn trimTrailingReturnNone(stmts: []const *Stmt) []const *Stmt {
    var out = stmts;
    while (out.len > 0 and Decompiler.isReturnNone(out[out.len - 1])) {
        out = out[0 .. out.len - 1];
    }
    return out;
}

fn rewriteFunctionStmts(decompiler: *Decompiler, stmts: []const *Stmt) DecompileError![]const *Stmt {
    const a = decompiler.arena.allocator();
    var out = stmts;
    out = try decompiler.rewriteRetRaiseDeep(a, out);
    out = try decompiler.rewriteLoopGuardElseDeep(a, out);
    return trimTrailingReturnNone(out);
}

fn rewriteModuleStmts(decompiler: *Decompiler, stmts: []const *Stmt) DecompileError![]const *Stmt {
    var out = trimTrailingReturnNone(stmts);
    if (out.len == 0) return out;
    const a = decompiler.arena.allocator();
    out = try Decompiler.reorderFutureImports(a, out);
    out = try decompiler.mergeImportFromGroupsDeep(a, out);
    out = try decompiler.rewriteRetRaiseDeep(a, out);
    out = try decompiler.rewriteLoopGuardElseDeep(a, out);
    // Control-flow rewrites can change bytecode parity.
    out = try decompiler.trimPostTerminalCleanupDeep(a, out);
    return out;
}

const TraceStackVal = struct {
    tag: []const u8,
    text: ?[]const u8 = null,
};

const GuardTrace = struct {
    kind: []const u8,
    block: u32,
    header: u32,
    term_op: []const u8,
    target: u32,
    continues_path: []const u32,
    stack_in: []const TraceStackVal,
    guard_expr: []const u8,
    insert_idx: usize,
};

const SimTrace = struct {
    kind: []const u8,
    block: u32,
    offset: u32,
    op: []const u8,
    arg: u32,
    stack_before: []const TraceStackVal,
    stack_after: []const TraceStackVal,
};

const DecisionTrace = struct {
    kind: []const u8,
    block: u32,
    note: []const u8,
    cond: ?[]const u8 = null,
};

const StackFlowTrace = struct {
    kind: []const u8,
    block: u32,
    stack_len: u32,
    updates: u32,
    worklist: u32,
};

const StackFlowMismatch = struct {
    kind: []const u8,
    pred: u32,
    succ: u32,
    existing_len: u32,
    incoming_len: u32,
};

const BlockTrace = struct {
    kind: []const u8,
    phase: []const u8,
    block: u32,
    start: u32,
    end: u32,
};

const GuardBranch = struct {
    target: u32,
    taken: bool,
    path: []const u32,
};

const GenSet = struct {
    marks: []u32,
    gen: u32,
    list: std.ArrayListUnmanaged(u32),

    fn init(allocator: Allocator, bit_len: usize) !GenSet {
        const marks = try allocator.alloc(u32, bit_len);
        @memset(marks, 0);
        var list: std.ArrayListUnmanaged(u32) = .{};
        if (bit_len > 0) {
            try list.ensureTotalCapacity(allocator, bit_len);
        }
        return .{ .marks = marks, .gen = 1, .list = list };
    }

    fn ensureSize(self: *GenSet, allocator: Allocator, bit_len: usize) !void {
        if (self.marks.len != bit_len) {
            const old_len = self.marks.len;
            self.marks = try allocator.realloc(self.marks, bit_len);
            if (bit_len > old_len) {
                @memset(self.marks[old_len..], 0);
            }
        }
        if (bit_len > self.list.capacity) {
            try self.list.ensureTotalCapacity(allocator, bit_len);
        }
        self.reset();
    }

    fn reset(self: *GenSet) void {
        self.gen +%= 1;
        if (self.gen == 0) {
            @memset(self.marks, 0);
            self.gen = 1;
        }
        self.list.clearRetainingCapacity();
    }

    fn set(self: *GenSet, allocator: Allocator, idx: u32) !void {
        const i: usize = @intCast(idx);
        if (i >= self.marks.len) return;
        if (self.marks[i] != self.gen) {
            self.marks[i] = self.gen;
            try self.list.append(allocator, idx);
        }
    }

    fn isSet(self: *const GenSet, idx: u32) bool {
        const i: usize = @intCast(idx);
        if (i >= self.marks.len) return false;
        return self.marks[i] == self.gen;
    }

    fn unset(self: *GenSet, idx: u32) void {
        const i: usize = @intCast(idx);
        if (i >= self.marks.len) return;
        if (self.marks[i] == self.gen) {
            self.marks[i] = 0;
        }
    }

    fn deinit(self: *GenSet, allocator: Allocator) void {
        if (self.marks.len > 0) allocator.free(self.marks);
        self.list.deinit(allocator);
    }
};

/// Decompiler state for a single code object.
pub const Decompiler = struct {
    allocator: Allocator,
    base_alloc: Allocator,
    arena: *std.heap.ArenaAllocator,
    clone_arena: *std.heap.ArenaAllocator,
    flow_arena: *std.heap.ArenaAllocator,
    sim_arena: *std.heap.ArenaAllocator,
    seed_arena: *std.heap.ArenaAllocator,
    code: *const pyc.Code,
    version: Version,
    cfg: *CFG,
    analyzer: Analyzer,
    dom: *dom_mod.DomTree,
    postdom_idom: ?[]u32 = null,

    /// Accumulated statements.
    statements: std.ArrayListUnmanaged(*Stmt),
    /// Nested decompilers (kept alive for arena lifetime).
    nested_decompilers: std.ArrayListUnmanaged(*Decompiler),
    /// Next block after chained comparison (set by tryDecompileChainedComparison).
    chained_cmp_next_block: ?u32 = null,
    /// Pending inline comprehension expressions keyed by exit block.
    inline_pend: std.ArrayListUnmanaged(InlinePend) = .{},
    /// Accumulated print items for Python 2.x PRINT_ITEM/PRINT_NEWLINE.
    print_items: std.ArrayListUnmanaged(*Expr),
    /// Print destination for PRINT_ITEM_TO.
    print_dest: ?*Expr = null,
    /// Error context for debugging.
    last_error_ctx: ?ErrorContext = null,
    /// Saw __classcell__ store in class body; suppress return emission.
    saw_classcell: bool = false,
    /// Class name for name-unmangling in class scope (null outside classes).
    class_name: ?[]const u8 = null,
    /// Entry stack state per block (computed by dataflow).
    stack_in: []?[]StackValue,
    /// Phi slots for stack merges keyed by (block, slot).
    phi_slots: std.AutoHashMapUnmanaged(PhiKey, PhiSlot) = .{},
    /// Phi slot indices per merge block.
    phi_by_block: std.AutoHashMapUnmanaged(u32, std.ArrayListUnmanaged(u32)) = .{},
    /// Phi incoming expressions keyed by (pred, succ, slot).
    phi_incoming: std.AutoHashMapUnmanaged(PhiIncomingKey, *Expr) = .{},
    /// Phi temp counter.
    phi_counter: u32 = 0,
    /// Blocks eligible for phi merges (if-chain merge ends).
    phi_merge_ok: ?std.DynamicBitSet = null,
    /// Guard against recursive if/elif cycles.
    if_in_progress: ?std.DynamicBitSet = null,
    /// Guard against recursive structured range cycles.
    range_in_progress: std.AutoHashMap(u64, void),
    /// Guard against recursive loop decompilation cycles.
    loop_in_progress: ?std.DynamicBitSet = null,
    /// Defensive recursion depth for loop decompilation.
    loop_depth: u32 = 0,
    /// Scratch buffers for try/except analysis.
    try_scratch: ?TryScratch = null,
    /// Scratch reachability set for conditional analysis.
    cond_seen: GenSet,
    /// Scratch DFS stack for conditional reachability.
    cond_stack: std.ArrayListUnmanaged(u32),
    /// Blocks already emitted into statements.
    consumed: GenSet,
    /// Scratch simulator for stack cloning.
    clone_sim: SimContext,
    /// Override for fallthrough after single-branch if.
    if_next: ?u32 = null,
    /// Tail statements to append after next if.
    if_tail: ?[]const *Stmt = null,
    /// Override for next block after loop when folding exit guards.
    loop_next: ?u32 = null,
    /// Optional limit for branchEnd traversal.
    br_limit: ?u32 = null,
    /// Trace loop guard insertion.
    trace_loop_guards: bool = false,
    /// Trace stack simulation for a block.
    trace_sim_block: ?u32 = null,
    /// Trace control-flow rewrite decisions.
    trace_decisions: bool = false,
    /// Trace stack-flow propagation.
    trace_stackflow: bool = false,
    /// Trace block traversal in structured passes.
    trace_blocks: bool = false,
    /// Trace output file.
    trace_file: ?std.fs.File = null,

    const ScPass = sc_pass.Methods(@This(), DecompileError);
    const PhiKey = struct { block: u32, slot: u32 };
    const PhiIncomingKey = struct { pred: u32, succ: u32, slot: u32 };
    const PhiSlot = struct { name: []const u8, expr: *Expr };

    fn simulateTernaryBranch(
        self: *Decompiler,
        block_id: u32,
        base_vals: []const StackValue,
    ) DecompileError!?*Expr {
        return ScPass.simulateTernaryBranch(self, block_id, base_vals);
    }

    fn simulateConditionExpr(
        self: *Decompiler,
        block_id: u32,
        base_vals: []const StackValue,
    ) DecompileError!?*Expr {
        return ScPass.simulateConditionExpr(self, block_id, base_vals);
    }

    fn simulateValueExprSkip(
        self: *Decompiler,
        block_id: u32,
        base_vals: []const StackValue,
        skip: usize,
    ) DecompileError!?*Expr {
        return ScPass.simulateValueExprSkip(self, block_id, base_vals, skip);
    }

    fn simulateBoolOpCondExpr(
        self: *Decompiler,
        block_id: u32,
        base_vals: []const StackValue,
        skip: usize,
        kind: ctrl.BoolOpKind,
    ) DecompileError!?*Expr {
        return ScPass.simulateBoolOpCondExpr(self, block_id, base_vals, skip, kind);
    }

    fn boolOpBlockSkip(
        self: *Decompiler,
        block: *const BasicBlock,
        kind: ctrl.BoolOpKind,
    ) usize {
        return ScPass.boolOpBlockSkip(self, block, kind);
    }

    fn initCondSim(
        self: *Decompiler,
        block_id: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?ScPass.CondSim {
        return ScPass.initCondSim(self, block_id, stmts, stmts_allocator) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn saveTernary(
        self: *Decompiler,
        merge_block: u32,
        condition: *Expr,
        true_expr: *Expr,
        false_expr: *Expr,
        base_vals: []StackValue,
        base_owned: *bool,
    ) DecompileError!void {
        return ScPass.saveTernary(self, merge_block, condition, true_expr, false_expr, base_vals, base_owned);
    }

    fn findTernaryLeaf(
        self: *Decompiler,
        start: u32,
        limit: u32,
    ) DecompileError!?ctrl.TernaryPattern {
        return ScPass.findTernaryLeaf(self, start, limit) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn tryDecompileTernaryTreeInto(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?u32 {
        return ScPass.tryDecompileTernaryTreeInto(self, block_id, limit, stmts, stmts_allocator) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn tryDecompileTernaryInto(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?u32 {
        return self.tryDecompileTernaryIntoWithSkip(block_id, limit, stmts, stmts_allocator, false);
    }

    fn tryDecompileTernaryIntoWithSkip(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first_store: bool,
    ) DecompileError!?u32 {
        return ScPass.tryDecompileTernaryIntoWithSkip(self, block_id, limit, stmts, stmts_allocator, skip_first_store) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn tryDecompileAndOrInto(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?u32 {
        return ScPass.tryDecompileAndOrInto(self, block_id, limit, stmts, stmts_allocator) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn tryDecompileBoolOpInto(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?u32 {
        return self.tryDecompileBoolOpIntoWithSkip(block_id, limit, stmts, stmts_allocator, false);
    }

    fn tryDecompileBoolOpIntoWithSkip(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first_store: bool,
    ) DecompileError!?u32 {
        return ScPass.tryDecompileBoolOpIntoWithSkip(self, block_id, limit, stmts, stmts_allocator, skip_first_store) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
    }

    fn buildBoolOpExpr(
        self: *Decompiler,
        first: *Expr,
        pattern: ctrl.BoolOpPattern,
        base_vals: []const StackValue,
    ) DecompileError!ScPass.BoolOpResult {
        return ScPass.buildBoolOpExpr(self, first, pattern, base_vals);
    }

    pub fn init(allocator: Allocator, code: *const pyc.Code, version: Version) DecompileError!Decompiler {
        return initWithOptions(allocator, code, version, .{});
    }

    pub fn initWithOptions(
        allocator: Allocator,
        code: *const pyc.Code,
        version: Version,
        opts: DecompileOptions,
    ) DecompileError!Decompiler {
        const arena = try allocator.create(std.heap.ArenaAllocator);
        errdefer allocator.destroy(arena);
        arena.* = std.heap.ArenaAllocator.init(allocator);
        errdefer arena.deinit();

        var decomp = Decompiler{
            .allocator = undefined,
            .base_alloc = allocator,
            .arena = arena,
            .clone_arena = undefined,
            .flow_arena = undefined,
            .sim_arena = undefined,
            .seed_arena = undefined,
            .code = code,
            .version = version,
            .cfg = undefined,
            .analyzer = undefined,
            .dom = undefined,
            .postdom_idom = null,
            .statements = .{},
            .nested_decompilers = .{},
            .print_items = .{},
            .stack_in = &.{},
            .range_in_progress = undefined,
            .cond_seen = undefined,
            .cond_stack = .{},
            .consumed = undefined,
            .clone_sim = undefined,
            .class_name = null,
            .trace_loop_guards = opts.trace_loop_guards,
            .trace_sim_block = opts.trace_sim_block,
            .trace_decisions = opts.trace_decisions,
            .trace_stackflow = opts.trace_stackflow,
            .trace_blocks = opts.trace_blocks,
            .trace_file = opts.trace_file,
        };
        decomp.allocator = decomp.arena.allocator();
        const a = decomp.allocator;

        const clone_arena = try a.create(std.heap.ArenaAllocator);
        errdefer a.destroy(clone_arena);
        clone_arena.* = std.heap.ArenaAllocator.init(allocator);
        errdefer clone_arena.deinit();
        decomp.clone_arena = clone_arena;
        decomp.clone_sim = SimContext.init(clone_arena.allocator(), clone_arena.allocator(), code, version);

        const flow_arena = try a.create(std.heap.ArenaAllocator);
        errdefer a.destroy(flow_arena);
        flow_arena.* = std.heap.ArenaAllocator.init(allocator);
        errdefer flow_arena.deinit();
        decomp.flow_arena = flow_arena;

        const sim_arena = try a.create(std.heap.ArenaAllocator);
        errdefer a.destroy(sim_arena);
        sim_arena.* = std.heap.ArenaAllocator.init(allocator);
        errdefer sim_arena.deinit();
        decomp.sim_arena = sim_arena;

        const seed_arena = try a.create(std.heap.ArenaAllocator);
        errdefer a.destroy(seed_arena);
        seed_arena.* = std.heap.ArenaAllocator.init(allocator);
        errdefer seed_arena.deinit();
        decomp.seed_arena = seed_arena;

        // Allocate CFG on heap so pointer stays valid
        const cfg = try a.create(CFG);
        cfg.* = if (version.gte(3, 11) and code.exceptiontable.len > 0)
            try cfg_mod.buildCFGWithExceptions(a, code.code, code.exceptiontable, version)
        else
            try cfg_mod.buildCFG(a, code.code, version);
        errdefer cfg.deinit();
        decomp.cfg = cfg;

        const dom = try a.create(dom_mod.DomTree);
        errdefer a.destroy(dom);
        dom.* = try dom_mod.DomTree.init(a, cfg);
        errdefer dom.deinit();
        decomp.dom = dom;

        var analyzer = try Analyzer.init(a, cfg, dom);
        errdefer analyzer.deinit();
        decomp.analyzer = analyzer;

        decomp.range_in_progress = std.AutoHashMap(u64, void).init(a);

        var cond_seen = try GenSet.init(a, cfg.blocks.len);
        errdefer cond_seen.deinit(a);
        decomp.cond_seen = cond_seen;

        var consumed = try GenSet.init(a, cfg.blocks.len);
        errdefer consumed.deinit(a);
        decomp.consumed = consumed;

        var cond_stack: std.ArrayListUnmanaged(u32) = .{};
        errdefer cond_stack.deinit(a);
        if (cfg.blocks.len > 0) {
            try cond_stack.ensureTotalCapacity(a, cfg.blocks.len);
        }
        decomp.cond_stack = cond_stack;

        try decomp.initStackFlow();
        decomp.if_in_progress = try std.DynamicBitSet.initEmpty(a, cfg.blocks.len);
        decomp.loop_in_progress = try std.DynamicBitSet.initEmpty(a, cfg.blocks.len);
        return decomp;
    }

    pub fn deinit(self: *Decompiler) void {
        self.clone_sim.deinit();
        for (self.nested_decompilers.items) |nested| {
            nested.deinit();
            self.allocator.destroy(nested);
        }
        self.nested_decompilers.deinit(self.allocator);
        self.print_items.deinit(self.allocator);
        self.inline_pend.deinit(self.allocator);
        self.flow_arena.deinit();
        self.allocator.destroy(self.flow_arena);
        self.sim_arena.deinit();
        self.allocator.destroy(self.sim_arena);
        self.seed_arena.deinit();
        self.allocator.destroy(self.seed_arena);
        self.clone_arena.deinit();
        self.allocator.destroy(self.clone_arena);
        for (self.stack_in) |entry_opt| {
            if (entry_opt) |entry| {
                if (entry.len > 0) self.allocator.free(entry);
            }
        }
        if (self.stack_in.len > 0) self.allocator.free(self.stack_in);
        var phi_vals = self.phi_by_block.valueIterator();
        while (phi_vals.next()) |list| {
            list.deinit(self.allocator);
        }
        self.phi_by_block.deinit(self.allocator);
        self.phi_slots.deinit(self.allocator);
        self.phi_incoming.deinit(self.allocator);
        if (self.phi_merge_ok) |*set| {
            set.deinit();
        }
        if (self.if_in_progress) |*set| set.deinit();
        if (self.loop_in_progress) |*set| set.deinit();
        self.range_in_progress.deinit();
        self.analyzer.deinit();
        self.dom.deinit();
        self.allocator.destroy(self.dom);
        if (self.postdom_idom) |idom| {
            self.allocator.free(idom);
        }
        if (self.try_scratch) |*scratch| {
            scratch.deinit(self.allocator);
        }
        self.cond_seen.deinit(self.allocator);
        self.cond_stack.deinit(self.allocator);
        self.consumed.deinit(self.allocator);
        self.statements.deinit(self.allocator);
        self.arena.deinit();
        self.base_alloc.destroy(self.arena);
    }

    const TryScratch = struct {
        handler_set: GenSet,
        protected_set: GenSet,
        handler_reach: GenSet,
        normal_reach: GenSet,
        queue: std.ArrayListUnmanaged(u32),
        handler_end: std.AutoHashMapUnmanaged(u32, u32),

        fn init(allocator: Allocator, bit_len: usize) !TryScratch {
            return .{
                .handler_set = try GenSet.init(allocator, bit_len),
                .protected_set = try GenSet.init(allocator, bit_len),
                .handler_reach = try GenSet.init(allocator, bit_len),
                .normal_reach = try GenSet.init(allocator, bit_len),
                .queue = .{},
                .handler_end = .{},
            };
        }

        fn ensureSize(self: *TryScratch, allocator: Allocator, bit_len: usize) !void {
            try self.handler_set.ensureSize(allocator, bit_len);
            try self.protected_set.ensureSize(allocator, bit_len);
            try self.handler_reach.ensureSize(allocator, bit_len);
            try self.normal_reach.ensureSize(allocator, bit_len);
            if (bit_len > self.queue.capacity) {
                try self.queue.ensureTotalCapacity(allocator, bit_len);
            }
            self.queue.clearRetainingCapacity();
            const cap: u32 = @intCast(bit_len);
            try self.handler_end.ensureTotalCapacity(allocator, cap);
        }

        fn deinit(self: *TryScratch, allocator: Allocator) void {
            self.handler_set.deinit(allocator);
            self.protected_set.deinit(allocator);
            self.handler_reach.deinit(allocator);
            self.normal_reach.deinit(allocator);
            self.queue.deinit(allocator);
            self.handler_end.deinit(allocator);
        }
    };

    fn getTryScratch(self: *Decompiler, bit_len: usize) DecompileError!*TryScratch {
        if (self.try_scratch) |*scratch| {
            try scratch.ensureSize(self.allocator, bit_len);
            return scratch;
        }
        var scratch = try TryScratch.init(self.allocator, bit_len);
        try scratch.ensureSize(self.allocator, bit_len);
        self.try_scratch = scratch;
        return &self.try_scratch.?;
    }

    pub fn isSoftSimErr(self: *Decompiler, err: anyerror) bool {
        _ = self;
        return switch (err) {
            error.StackUnderflow,
            error.NotAnExpression,
            error.InvalidSwapArg,
            error.InvalidDupArg,
            => true,
            else => false,
        };
    }

    pub fn simOpt(self: *Decompiler, sim: *SimContext, inst: decoder.Instruction) DecompileError!void {
        sim.simulate(inst) catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
    }

    pub fn popExprMatch(self: *Decompiler, sim: *SimContext) DecompileError!*Expr {
        return sim.stack.popExpr() catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
    }

    pub fn isStatementOpcode(op: Opcode) bool {
        const name = op.name();
        return std.mem.startsWith(u8, name, "STORE_") or
            std.mem.startsWith(u8, name, "DELETE_") or
            std.mem.startsWith(u8, name, "IMPORT_") or
            std.mem.startsWith(u8, name, "RETURN_") or
            std.mem.startsWith(u8, name, "RAISE_") or
            std.mem.startsWith(u8, name, "PRINT_") or
            std.mem.startsWith(u8, name, "EXEC_") or
            std.mem.eql(u8, name, "POP_TOP") or
            std.mem.eql(u8, name, "RERAISE") or
            std.mem.eql(u8, name, "SETUP_EXCEPT") or
            std.mem.eql(u8, name, "SETUP_FINALLY") or
            std.mem.eql(u8, name, "SETUP_WITH") or
            std.mem.eql(u8, name, "SETUP_ASYNC_WITH") or
            std.mem.eql(u8, name, "END_FINALLY") or
            std.mem.eql(u8, name, "WITH_CLEANUP") or
            std.mem.eql(u8, name, "POP_BLOCK") or
            std.mem.eql(u8, name, "POP_EXCEPT") or
            std.mem.eql(u8, name, "BREAK_LOOP") or
            std.mem.eql(u8, name, "CONTINUE_LOOP") or
            std.mem.eql(u8, name, "YIELD_VALUE") or
            std.mem.eql(u8, name, "YIELD_FROM") or
            std.mem.eql(u8, name, "END_FOR") or
            std.mem.eql(u8, name, "END_SEND") or
            std.mem.eql(u8, name, "RAISE_VARARGS") or
            std.mem.eql(u8, name, "DELETE_NAME") or
            std.mem.eql(u8, name, "DELETE_FAST") or
            std.mem.eql(u8, name, "DELETE_GLOBAL") or
            std.mem.eql(u8, name, "DELETE_DEREF");
    }

    fn hasTrySetup(block: *const BasicBlock) bool {
        for (block.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            if (inst.opcode == .SETUP_FINALLY or inst.opcode == .SETUP_EXCEPT) return true;
        }
        return false;
    }

    fn isExprOnlyBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        for (blk.instructions) |inst| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) return false;
            if (inst.isUnconditionalJump()) return false;
            if (isStatementOpcode(inst.opcode)) return false;
        }
        return true;
    }

    fn condBlockHasPrelude(block: *const BasicBlock) bool {
        for (block.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) return false;
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            if (isStatementOpcode(inst.opcode)) return true;
        }
        return false;
    }

    /// Check if a block has meaningful content beyond just a terminal instruction.
    /// Returns true if there are statements before the terminator.
    fn exitBlockHasContent(block: *const BasicBlock) bool {
        var stmt_count: usize = 0;
        for (block.instructions) |inst| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            // Terminal instructions don't count as content
            switch (inst.opcode) {
                .RETURN_VALUE, .RETURN_CONST, .RAISE_VARARGS, .RERAISE => {},
                else => {
                    if (isStatementOpcode(inst.opcode)) stmt_count += 1;
                },
            }
        }
        return stmt_count > 0;
    }

    fn condChainAllTrueJumps(self: *Decompiler, start: u32, stop: u32) DecompileError!bool {
        if (start >= self.cfg.blocks.len) return false;
        if (stop >= self.cfg.blocks.len) return false;
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer seen.deinit();
        var cur = start;
        while (true) {
            if (cur == stop) return true;
            if (cur >= self.cfg.blocks.len) return false;
            if (seen.isSet(cur)) return false;
            seen.set(cur);
            const blk = &self.cfg.blocks[cur];
            const term = blk.terminator() orelse return false;
            switch (term.opcode) {
                .POP_JUMP_IF_TRUE,
                .POP_JUMP_FORWARD_IF_TRUE,
                .POP_JUMP_BACKWARD_IF_TRUE,
                .JUMP_IF_TRUE,
                => {},
                else => return false,
            }
            var next_false: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.edge_type == .conditional_false) {
                    next_false = edge.target;
                }
            }
            if (next_false == null) return false;
            cur = next_false.?;
        }
    }

    fn condChainFalseTarget(self: *Decompiler, start: u32, then_block: u32) DecompileError!?u32 {
        if (start >= self.cfg.blocks.len) return null;
        if (then_block >= self.cfg.blocks.len) return null;
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer seen.deinit();
        var cur = start;
        while (true) {
            if (cur >= self.cfg.blocks.len) return null;
            if (seen.isSet(cur)) return null;
            seen.set(cur);
            const blk = &self.cfg.blocks[cur];
            const term = blk.terminator() orelse return null;
            if (!ctrl.Analyzer.isConditionalJump(undefined, term.opcode)) return null;
            if (condBlockHasPrelude(blk)) return null;
            var t_id: ?u32 = null;
            var f_id: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.edge_type == .conditional_false) {
                    f_id = edge.target;
                } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                    t_id = edge.target;
                }
            }
            if (t_id == null or f_id == null) return null;
            var next: u32 = undefined;
            if (t_id.? == then_block and f_id.? != then_block) {
                next = f_id.?;
            } else if (f_id.? == then_block and t_id.? != then_block) {
                next = t_id.?;
            } else {
                return null;
            }
            if (next >= self.cfg.blocks.len) return null;
            const next_blk = &self.cfg.blocks[next];
            const next_term = next_blk.terminator() orelse return next;
            if (!ctrl.Analyzer.isConditionalJump(undefined, next_term.opcode)) return next;
            if (condBlockHasPrelude(next_blk)) return next;
            var next_has_then = false;
            for (next_blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.target == then_block) {
                    next_has_then = true;
                    break;
                }
            }
            if (!next_has_then) return next;
            cur = next;
        }
    }

    /// Try to emit a statement for the given opcode from the current stack state.
    /// Returns the statement if one was emitted, null otherwise.
    pub fn tryEmitStatement(
        self: *Decompiler,
        inst: decoder.Instruction,
        sim: *SimContext,
        block_id: ?u32,
        inst_idx: ?usize,
    ) DecompileError!?*Stmt {
        switch (inst.opcode) {
            .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => {
                var name = switch (inst.opcode) {
                    .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                    .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                    .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                    else => "__unknown__",
                };
                if (inst.opcode == .STORE_DEREF and self.version.gte(3, 14) and std.mem.eql(u8, name, "__classdict__")) {
                    name = "__unknown__";
                }
                var value = sim.stack.pop() orelse {
                    if (sim.lenient) return null;
                    return error.StackUnderflow;
                };
                errdefer value.deinit(sim.allocator, sim.stack_alloc);
                if (block_id != null and inst_idx != null) {
                    switch (value) {
                        .unknown, .null_marker => {
                            if (try self.tryRecoverTernaryStore(block_id.?, inst_idx.?)) |expr| {
                                value.deinit(sim.allocator, sim.stack_alloc);
                                value = .{ .expr = expr };
                            }
                        },
                        else => {},
                    }
                }
                return try self.handleStoreValue(sim, name, value);
            },
            .POP_TOP => {
                const val = sim.stack.pop() orelse {
                    if (sim.lenient) return null;
                    return error.StackUnderflow;
                };
                switch (val) {
                    .expr => |e| {
                        return self.makeExprStmt(e) catch |err| {
                            if (err == error.SkipStatement) {
                                // Skipped expression - arena-allocated, don't free
                                return null;
                            }
                            return err;
                        };
                    },
                    else => {
                        val.deinit(sim.allocator, sim.stack_alloc);
                        return null;
                    },
                }
            },
            .EXEC_STMT => {
                const locals_val = sim.stack.pop() orelse return error.StackUnderflow;
                const globals_val = sim.stack.pop() orelse {
                    var v = locals_val;
                    v.deinit(sim.allocator, sim.stack_alloc);
                    return error.StackUnderflow;
                };
                const code_val = sim.stack.pop() orelse {
                    var v = locals_val;
                    v.deinit(sim.allocator, sim.stack_alloc);
                    var g = globals_val;
                    g.deinit(sim.allocator, sim.stack_alloc);
                    return error.StackUnderflow;
                };

                const code_expr = switch (code_val) {
                    .expr => |e| e,
                    else => blk: {
                        var v = code_val;
                        v.deinit(sim.allocator, sim.stack_alloc);
                        var g = globals_val;
                        g.deinit(sim.allocator, sim.stack_alloc);
                        var l = locals_val;
                        l.deinit(sim.allocator, sim.stack_alloc);
                        break :blk null;
                    },
                } orelse return null;

                var globals_expr: ?*Expr = switch (globals_val) {
                    .expr => |e| e,
                    else => blk: {
                        var v = globals_val;
                        v.deinit(sim.allocator, sim.stack_alloc);
                        break :blk null;
                    },
                };
                var locals_expr: ?*Expr = switch (locals_val) {
                    .expr => |e| e,
                    else => blk: {
                        var v = locals_val;
                        v.deinit(sim.allocator, sim.stack_alloc);
                        break :blk null;
                    },
                };

                if (globals_expr) |g| {
                    if (g.* == .constant and g.constant == .none) globals_expr = null;
                }
                if (locals_expr) |l| {
                    if (l.* == .constant and l.constant == .none) locals_expr = null;
                }
                if (locals_expr != null and globals_expr == null) {
                    globals_expr = try ast.makeConstant(self.arena.allocator(), .none);
                }

                const a = self.arena.allocator();
                const stmt = try a.create(Stmt);
                stmt.* = .{ .exec_stmt = .{
                    .code = code_expr,
                    .globals = globals_expr,
                    .locals = locals_expr,
                } };
                return stmt;
            },
            .DELETE_NAME, .DELETE_FAST, .DELETE_GLOBAL, .DELETE_DEREF => {
                const name = switch (inst.opcode) {
                    .DELETE_NAME, .DELETE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                    .DELETE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                    .DELETE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                    else => "__unknown__",
                };
                const a = self.arena.allocator();
                const target = try self.makeName(name, .del);
                const targets = try a.alloc(*Expr, 1);
                targets[0] = target;
                const stmt = try a.create(Stmt);
                stmt.* = .{ .delete = .{ .targets = targets } };
                return stmt;
            },
            .DELETE_ATTR => {
                const obj = try sim.stack.popExpr();
                const attr = sim.getName(inst.arg) orelse "__unknown__";
                const a = self.arena.allocator();
                const target = try self.makeAttribute(obj, attr, .del);
                const targets = try a.alloc(*Expr, 1);
                targets[0] = target;
                const stmt = try a.create(Stmt);
                stmt.* = .{ .delete = .{ .targets = targets } };
                return stmt;
            },
            .DELETE_SUBSCR => {
                const key = try sim.stack.popExpr();
                const container = try sim.stack.popExpr();
                const a = self.arena.allocator();
                const target = try ast.makeSubscript(a, container, key, .del);
                const targets = try a.alloc(*Expr, 1);
                targets[0] = target;
                const stmt = try a.create(Stmt);
                stmt.* = .{ .delete = .{ .targets = targets } };
                return stmt;
            },
            .DELETE_SLICE_0, .DELETE_SLICE_1, .DELETE_SLICE_2, .DELETE_SLICE_3 => {
                var lower: ?*Expr = null;
                var upper: ?*Expr = null;
                const container = switch (inst.opcode) {
                    .DELETE_SLICE_0 => try sim.stack.popExpr(),
                    .DELETE_SLICE_1 => blk: {
                        const start = try sim.stack.popExpr();
                        lower = start;
                        break :blk try sim.stack.popExpr();
                    },
                    .DELETE_SLICE_2 => blk: {
                        const stop = try sim.stack.popExpr();
                        upper = stop;
                        break :blk try sim.stack.popExpr();
                    },
                    .DELETE_SLICE_3 => blk: {
                        const stop = try sim.stack.popExpr();
                        upper = stop;
                        const start = try sim.stack.popExpr();
                        lower = start;
                        break :blk try sim.stack.popExpr();
                    },
                    else => unreachable,
                };

                const lower_val = if (lower) |l| (if (l.* == .constant and l.constant == .none) null else l) else null;
                const upper_val = if (upper) |u| (if (u.* == .constant and u.constant == .none) null else u) else null;
                const a = self.arena.allocator();
                const slice_expr = try a.create(Expr);
                slice_expr.* = .{ .slice = .{ .lower = lower_val, .upper = upper_val, .step = null } };
                const target = try ast.makeSubscript(a, container, slice_expr, .del);
                const targets = try a.alloc(*Expr, 1);
                targets[0] = target;
                const stmt = try a.create(Stmt);
                stmt.* = .{ .delete = .{ .targets = targets } };
                return stmt;
            },
            .RAISE_VARARGS => {
                // RAISE_VARARGS argc: 0=bare, 1=exc, 2=exc from cause
                if (inst.arg == 0) {
                    const a = self.arena.allocator();
                    const stmt = try a.create(Stmt);
                    stmt.* = .{ .raise_stmt = .{ .exc = null, .cause = null } };
                    return stmt;
                } else if (inst.arg == 1) {
                    const val = sim.stack.pop() orelse return error.StackUnderflow;
                    if (val == .expr) {
                        const a = self.arena.allocator();
                        const stmt = try a.create(Stmt);
                        stmt.* = .{ .raise_stmt = .{ .exc = val.expr, .cause = null } };
                        return stmt;
                    }
                    val.deinit(sim.allocator, sim.stack_alloc);
                } else if (inst.arg == 2) {
                    const cause_val = sim.stack.pop() orelse return error.StackUnderflow;
                    errdefer cause_val.deinit(sim.allocator, sim.stack_alloc);
                    const exc_val = sim.stack.pop() orelse return error.StackUnderflow;
                    if (exc_val == .expr and cause_val == .expr) {
                        const a = self.arena.allocator();
                        const stmt = try a.create(Stmt);
                        stmt.* = .{ .raise_stmt = .{ .exc = exc_val.expr, .cause = cause_val.expr } };
                        return stmt;
                    }
                    exc_val.deinit(sim.allocator, sim.stack_alloc);
                    cause_val.deinit(sim.allocator, sim.stack_alloc);
                }
                return null;
            },
            else => {
                // For other statement opcodes, simulate and don't emit
                try sim.simulate(inst);
                return null;
            },
        }
    }

    fn firstMeaningfulInstIdx(block: *const BasicBlock) usize {
        var idx: usize = 0;
        while (idx < block.instructions.len) : (idx += 1) {
            const op = block.instructions[idx].opcode;
            if (op == .NOT_TAKEN or op == .CACHE) continue;
            break;
        }
        return idx;
    }

    const TernaryRecover = struct {
        expr: *Expr,
        cond_block: u32,
        true_block: u32,
        false_block: u32,
    };

    fn tryRecoverTernaryAtMerge(
        self: *Decompiler,
        merge_block: u32,
    ) DecompileError!?TernaryRecover {
        if (merge_block >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[merge_block];

        var preds: [2]u32 = undefined;
        var pred_count: usize = 0;
        for (block.predecessors) |pid| {
            if (pid >= self.cfg.blocks.len) continue;
            const pblk = &self.cfg.blocks[pid];
            var is_exc = true;
            for (pblk.successors) |edge| {
                if (edge.target == merge_block) {
                    if (edge.edge_type != .exception) is_exc = false;
                    break;
                }
            }
            if (is_exc) continue;
            if (pred_count < preds.len) preds[pred_count] = pid;
            pred_count += 1;
        }
        if (pred_count != 2) return null;
        const p0 = preds[0];
        const p1 = preds[1];

        const p0_blk = &self.cfg.blocks[p0];
        const p1_blk = &self.cfg.blocks[p1];
        var cond_id: ?u32 = null;
        for (p0_blk.predecessors) |cand| {
            if (cand >= self.cfg.blocks.len) continue;
            for (p1_blk.predecessors) |cand2| {
                if (cand == cand2) {
                    cond_id = cand;
                    break;
                }
            }
            if (cond_id != null) break;
        }
        const cond_block = cond_id orelse return null;

        const cond_blk = &self.cfg.blocks[cond_block];
        const term = cond_blk.terminator() orelse return null;
        if (!self.analyzer.isConditionalJump(term.opcode)) return null;

        var non_exc_edges: [2]cfg_mod.Edge = undefined;
        var non_exc_len: usize = 0;
        for (cond_blk.successors) |edge| {
            if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
            if (non_exc_len < non_exc_edges.len) {
                non_exc_edges[non_exc_len] = edge;
            }
            non_exc_len += 1;
        }
        if (non_exc_len != 2) return null;

        var true_block: ?u32 = null;
        var false_block: ?u32 = null;
        for (non_exc_edges[0..2]) |edge| {
            if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                true_block = edge.target;
            } else if (edge.edge_type == .conditional_false) {
                false_block = edge.target;
            }
        }
        const true_id = true_block orelse return null;
        const false_id = false_block orelse return null;

        const true_blk = &self.cfg.blocks[true_id];
        const false_blk = &self.cfg.blocks[false_id];
        var true_merge: ?u32 = null;
        var false_merge: ?u32 = null;
        for (true_blk.successors) |edge| {
            if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
            if (edge.edge_type == .normal) {
                true_merge = edge.target;
                break;
            }
        }
        for (false_blk.successors) |edge| {
            if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
            if (edge.edge_type == .normal) {
                false_merge = edge.target;
                break;
            }
        }
        if (true_merge == null or false_merge == null) return null;
        const merge = if (true_merge == false_id)
            false_merge.?
        else if (true_merge == false_merge)
            true_merge.?
        else
            return null;

        if (merge != merge_block) return null;
        const pred_match = (true_id == p0 and false_id == p1) or
            (true_id == p1 and false_id == p0);
        if (!pred_match) return null;

        const cond_res = (try self.loopCondExpr(cond_block, true_id, false_id, 0)) orelse return null;
        defer self.deinitStackValues(cond_res.base_vals);

        const true_expr = (try self.simulateTernaryBranch(true_id, cond_res.base_vals)) orelse return null;
        const false_expr = (try self.simulateTernaryBranch(false_id, cond_res.base_vals)) orelse return null;

        const a = self.arena.allocator();
        const if_expr = try a.create(Expr);
        if_expr.* = .{ .if_exp = .{
            .condition = cond_res.expr,
            .body = true_expr,
            .else_body = false_expr,
        } };
        return .{
            .expr = if_expr,
            .cond_block = cond_block,
            .true_block = true_id,
            .false_block = false_id,
        };
    }

    fn tryRecoverTernaryStore(
        self: *Decompiler,
        block_id: u32,
        inst_idx: usize,
    ) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];
        const first = firstMeaningfulInstIdx(block);
        if (inst_idx != first) {
            if (inst_idx >= block.instructions.len) return null;
            if (block.instructions[inst_idx].opcode != .STORE_ATTR) return null;
            if (!isAttrStorePrelude(block, first, inst_idx)) return null;
        }
        if (try self.tryRecoverTernaryAtMerge(block_id)) |rec| {
            return rec.expr;
        }
        return null;
    }

    fn isAttrStorePrelude(block: *const BasicBlock, start: usize, end: usize) bool {
        var i: usize = start;
        while (i < end) : (i += 1) {
            const op = block.instructions[i].opcode;
            switch (op) {
                .LOAD_FAST, .LOAD_NAME, .LOAD_GLOBAL, .LOAD_DEREF, .LOAD_ATTR => {},
                .NOT_TAKEN, .CACHE => {},
                else => return false,
            }
        }
        return true;
    }

    fn firstStoreIdx(block: *const BasicBlock) ?usize {
        var i: usize = 0;
        while (i < block.instructions.len) : (i += 1) {
            const op = block.instructions[i].opcode;
            switch (op) {
                .LOAD_FAST, .LOAD_NAME, .LOAD_GLOBAL, .LOAD_DEREF, .LOAD_ATTR => {},
                .NOT_TAKEN, .CACHE => {},
                .STORE_FAST,
                .STORE_NAME,
                .STORE_GLOBAL,
                .STORE_DEREF,
                .STORE_ATTR,
                .STORE_SUBSCR,
                => return i,
                else => return null,
            }
        }
        return null;
    }

    fn tryRecoverBoolOpStore(
        self: *Decompiler,
        block_id: u32,
        inst_idx: usize,
    ) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];
        if (inst_idx != firstMeaningfulInstIdx(block)) return null;

        var cond_id: ?u32 = null;
        var pat: ?ctrl.BoolOpPattern = null;
        for (block.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            if (self.analyzer.detectBoolOp(pred_id)) |p| {
                if (p.merge_block == block_id) {
                    cond_id = pred_id;
                    pat = p;
                    break;
                }
            }
        }
        const cond_block = cond_id orelse return null;
        const pattern = pat orelse return null;

        var cond_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer cond_sim.deinit();
        if (cond_block < self.stack_in.len) {
            if (self.stack_in[cond_block]) |entry| {
                for (entry) |val| {
                    const cloned = try cond_sim.cloneStackValue(val);
                    try cond_sim.stack.push(cloned);
                }
            }
        }
        for (self.cfg.blocks[cond_block].instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            cond_sim.simulate(inst) catch |err| {
                if (self.isSoftSimErr(err)) return error.PatternNoMatch;
                return err;
            };
        }
        const first = cond_sim.stack.popExpr() catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
        const base_vals = try self.cloneStackValues(cond_sim.stack.items.items);
        defer self.deinitStackValues(base_vals);

        const bool_res = ScPass.buildBoolOpExpr(self, first, pattern, base_vals) catch |err| {
            if (err == error.InvalidBlock or err == error.PatternNoMatch) return error.PatternNoMatch;
            return err;
        };
        return bool_res.expr;
    }

    fn shouldSkipIfForWithTernary(self: *Decompiler, pattern: ctrl.IfPattern) DecompileError!?u32 {
        if (pattern.else_block == null) return null;
        const else_id = pattern.else_block.?;
        var merge_id: ?u32 = pattern.merge_block;
        if (merge_id) |mid| {
            if (mid >= self.cfg.blocks.len) {
                merge_id = null;
            } else {
                const merge_pat = try self.analyzer.detectPatternNoTry(mid);
                if (merge_pat != .with_stmt) {
                    merge_id = null;
                }
            }
        }
        if (merge_id == null) {
            var then_succ: ?u32 = null;
            var else_succ: ?u32 = null;
            if (pattern.then_block < self.cfg.blocks.len) {
                const then_blk = &self.cfg.blocks[pattern.then_block];
                for (then_blk.successors) |edge| {
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                    if (then_succ != null) {
                        then_succ = null;
                        break;
                    }
                    then_succ = edge.target;
                }
            }
            if (else_id < self.cfg.blocks.len) {
                const else_blk = &self.cfg.blocks[else_id];
                for (else_blk.successors) |edge| {
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                    if (else_succ != null) {
                        else_succ = null;
                        break;
                    }
                    else_succ = edge.target;
                }
            }
            if (then_succ != null and else_succ != null and then_succ.? == else_succ.?) {
                merge_id = then_succ.?;
            }
        }
        const merge = merge_id orelse return null;
        if (merge >= self.cfg.blocks.len) return null;
        const merge_pat = try self.analyzer.detectPatternNoTry(merge);
        if (merge_pat != .with_stmt) return null;
        if (try self.tryRecoverTernaryAtMerge(merge)) |rec| {
            const matches = rec.cond_block == pattern.condition_block and
                ((rec.true_block == pattern.then_block and rec.false_block == else_id) or
                    (rec.true_block == else_id and rec.false_block == pattern.then_block));
            if (matches) return merge;
        }
        return null;
    }

    fn shouldSkipIfForTernaryStore(self: *Decompiler, pattern: ctrl.IfPattern) DecompileError!?u32 {
        if (pattern.else_block == null) return null;
        const else_id = pattern.else_block.?;
        var merge_id: ?u32 = pattern.merge_block;
        if (merge_id) |mid| {
            if (mid >= self.cfg.blocks.len) merge_id = null;
        }
        if (merge_id == null) {
            var then_succ: ?u32 = null;
            var else_succ: ?u32 = null;
            if (pattern.then_block < self.cfg.blocks.len) {
                const then_blk = &self.cfg.blocks[pattern.then_block];
                for (then_blk.successors) |edge| {
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                    if (then_succ != null) {
                        then_succ = null;
                        break;
                    }
                    then_succ = edge.target;
                }
            }
            if (else_id < self.cfg.blocks.len) {
                const else_blk = &self.cfg.blocks[else_id];
                for (else_blk.successors) |edge| {
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                    if (else_succ != null) {
                        else_succ = null;
                        break;
                    }
                    else_succ = edge.target;
                }
            }
            if (then_succ != null and else_succ != null and then_succ.? == else_succ.?) {
                merge_id = then_succ.?;
            }
        }
        const merge = merge_id orelse return null;
        if (merge >= self.cfg.blocks.len) return null;
        const rec = try self.tryRecoverTernaryAtMerge(merge) orelse return null;
        const matches = rec.cond_block == pattern.condition_block and
            ((rec.true_block == pattern.then_block and rec.false_block == else_id) or
                (rec.true_block == else_id and rec.false_block == pattern.then_block));
        if (!matches) return null;
        const store_idx = firstStoreIdx(&self.cfg.blocks[merge]) orelse return null;
        if (try self.tryRecoverTernaryStore(merge, store_idx)) |_| {
            return merge;
        }
        return null;
    }

    pub fn deinitStackValuesSlice(
        ast_alloc: Allocator,
        stack_alloc: Allocator,
        slice_alloc: Allocator,
        values: []const StackValue,
    ) void {
        for (values) |val| {
            if (val != .expr) {
                val.deinit(ast_alloc, stack_alloc);
            }
        }
        if (values.len > 0) slice_alloc.free(@constCast(values));
    }

    fn deinitStackValues(self: *Decompiler, values: []const StackValue) void {
        deinitStackValuesSlice(self.clone_sim.allocator, self.clone_sim.stack_alloc, self.allocator, values);
    }

    fn returnCleanupSkip(instructions: []const decoder.Instruction, idx: usize) ?usize {
        if (idx + 2 < instructions.len and
            instructions[idx].opcode == .ROT_TWO and
            instructions[idx + 1].opcode == .POP_TOP and
            instructions[idx + 2].opcode == .RETURN_VALUE)
        {
            return 2;
        }
        if (idx + 4 < instructions.len and
            instructions[idx].opcode == .ROT_TWO and
            instructions[idx + 1].opcode == .POP_TOP and
            instructions[idx + 2].opcode == .ROT_TWO and
            instructions[idx + 3].opcode == .POP_TOP and
            instructions[idx + 4].opcode == .RETURN_VALUE)
        {
            return 4;
        }
        return null;
    }

    fn tryRecoverWithReturnExprFromBlock(
        self: *Decompiler,
        block: *const cfg_mod.BasicBlock,
        end_idx: usize,
    ) DecompileError!?*Expr {
        if (end_idx > block.instructions.len) return null;
        var tmp = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer tmp.deinit();
        tmp.lenient = true;
        tmp.stack.allow_underflow = true;

        const exit_expr = try self.makeName("__with_exit__", .load);
        try tmp.stack.push(.{ .expr = exit_expr });
        try tmp.stack.push(.unknown);

        for (block.instructions[0..end_idx]) |inst| {
            try tmp.simulate(inst);
        }
        const expr = tmp.stack.popExpr() catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
        if (self.isPlaceholderExpr(expr)) return null;
        return expr;
    }

    fn tryRecoverWithReturnValue(
        self: *Decompiler,
        block: *const cfg_mod.BasicBlock,
        idx: usize,
    ) DecompileError!?*Expr {
        const insts = block.instructions;
        if (idx >= insts.len) return null;
        if (insts[idx].opcode != .RETURN_VALUE) return null;
        var cur = block;
        var steps: usize = 0;
        while (steps < 4) : (steps += 1) {
            const cur_insts = cur.instructions;
            var cleanup_start: ?usize = null;
            var i: usize = 0;
            while (i + 2 < cur_insts.len) : (i += 1) {
                if (cur_insts[i].opcode == .ROT_TWO and
                    cur_insts[i + 1].opcode == .POP_TOP and
                    cur_insts[i + 2].opcode == .POP_BLOCK)
                {
                    cleanup_start = i;
                }
            }
            if (cleanup_start) |start| {
                if (start >= 3 and cur_insts[start - 1].opcode == .COMPARE_OP and
                    isLoadInstr(cur_insts[start - 2].opcode) and isLoadInstr(cur_insts[start - 3].opcode))
                {
                    var tmp = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                    defer tmp.deinit();
                    tmp.lenient = true;
                    tmp.stack.allow_underflow = true;
                    for (cur_insts[start - 3 .. start]) |inst| {
                        try tmp.simulate(inst);
                    }
                    if (tmp.stack.popExpr()) |expr| {
                        if (!self.isPlaceholderExpr(expr)) return expr;
                    } else |err| {
                        if (!self.isSoftSimErr(err)) return err;
                    }
                }
                const expr = self.tryRecoverWithReturnExprFromBlock(cur, start) catch |err| switch (err) {
                    error.PatternNoMatch => null,
                    else => return err,
                };
                if (expr) |e| return e;
            }
            if (cur.predecessors.len == 1) {
                const pred_id = cur.predecessors[0];
                if (pred_id < self.cfg.blocks.len) {
                    const pred_blk = &self.cfg.blocks[pred_id];
                    if (pred_blk.instructions.len >= 2) {
                        const last_idx = pred_blk.instructions.len - 1;
                        const last = pred_blk.instructions[last_idx];
                        if (last.opcode == .POP_BLOCK) {
                            var scan: isize = @as(isize, @intCast(last_idx)) - 1;
                            while (scan >= 0) : (scan -= 1) {
                                const inst = pred_blk.instructions[@intCast(scan)];
                                switch (inst.opcode) {
                                    .CACHE, .NOT_TAKEN, .EXTENDED_ARG => continue,
                                    else => {},
                                }
                                if (isLoadInstr(inst.opcode)) {
                                    var tmp = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                    defer tmp.deinit();
                                    tmp.lenient = true;
                                    tmp.stack.allow_underflow = true;
                                    try tmp.simulate(inst);
                                    if (tmp.stack.popExpr()) |expr| {
                                        if (!self.isPlaceholderExpr(expr)) return expr;
                                    } else |err| {
                                        if (!self.isSoftSimErr(err)) return err;
                                    }
                                }
                                break;
                            }
                            const expr = self.recoverTryRetExpr(pred_id) catch |err| switch (err) {
                                error.PatternNoMatch => null,
                                else => return err,
                            };
                            if (expr) |e| {
                                if (!self.isPlaceholderExpr(e)) return e;
                            }
                        }
                    }
                }
            }
            if (cur.predecessors.len != 1) break;
            const pred_id = cur.predecessors[0];
            if (pred_id >= self.cfg.blocks.len) break;
            cur = &self.cfg.blocks[pred_id];
        }

        return null;
    }

    fn markCondChainConsumed(
        self: *Decompiler,
        first_block: u32,
        memo: *const std.AutoHashMapUnmanaged(u32, *Expr),
    ) DecompileError!void {
        var it = memo.iterator();
        while (it.next()) |entry| {
            const bid = entry.key_ptr.*;
            if (bid == first_block) continue;
            try self.consumed.set(self.allocator, bid);
        }
    }

    pub fn markConsumed(self: *Decompiler, block_id: u32) DecompileError!void {
        if (block_id >= self.cfg.blocks.len) return;
        try self.consumed.set(self.allocator, block_id);
    }

    fn isDocstringStmt(stmt: *const Stmt) bool {
        return switch (stmt.*) {
            .expr_stmt => |e| e.value.* == .constant and e.value.constant == .string,
            else => false,
        };
    }

    fn isAssignNameToName(stmt: *const Stmt, name: []const u8, value: []const u8) bool {
        if (stmt.* != .assign) return false;
        if (stmt.assign.targets.len != 1) return false;
        const target = stmt.assign.targets[0];
        if (target.* != .name) return false;
        if (!std.mem.eql(u8, target.name.id, name)) return false;
        const rhs = stmt.assign.value;
        if (rhs.* != .name) return false;
        return std.mem.eql(u8, rhs.name.id, value);
    }

    fn collectFinalCleanupNames(
        self: *Decompiler,
        final_body: []const *Stmt,
    ) DecompileError![]const []const u8 {
        var names: std.ArrayListUnmanaged([]const u8) = .{};
        errdefer names.deinit(self.allocator);
        for (final_body) |stmt| {
            if (stmt.* != .assign) continue;
            const assign = stmt.assign;
            if (assign.value.* != .constant or assign.value.constant != .none) continue;
            for (assign.targets) |t| {
                if (t.* != .name) continue;
                try names.append(self.allocator, t.name.id);
            }
        }
        return names.toOwnedSlice(self.allocator);
    }

    fn cleanupHasName(cleanup: []const []const u8, name: []const u8) bool {
        for (cleanup) |n| {
            if (std.mem.eql(u8, n, name)) return true;
        }
        return false;
    }

    fn assignNoneTargetsInCleanup(
        self: *Decompiler,
        stmt: *const Stmt,
        cleanup: []const []const u8,
    ) bool {
        _ = self;
        if (stmt.* != .assign) return false;
        const assign = stmt.assign;
        if (assign.value.* != .constant or assign.value.constant != .none) return false;
        for (assign.targets) |t| {
            if (t.* != .name) return false;
            if (!cleanupHasName(cleanup, t.name.id)) return false;
        }
        return true;
    }

    fn stripCleanupAssignBeforeReturn(
        self: *Decompiler,
        body: []const *Stmt,
        cleanup: []const []const u8,
    ) DecompileError![]const *Stmt {
        if (body.len < 2) return body;
        const last = body[body.len - 1];
        const prev = body[body.len - 2];
        if (last.* != .return_stmt) return body;
        if (!self.assignNoneTargetsInCleanup(prev, cleanup)) return body;
        const a = self.arena.allocator();
        const next = try a.alloc(*Stmt, body.len - 1);
        if (body.len > 2) {
            std.mem.copyForwards(*Stmt, next[0 .. body.len - 2], body[0 .. body.len - 2]);
        }
        next[body.len - 2] = last;
        return next;
    }

    fn stripCleanupAssignDupesInBody(
        self: *Decompiler,
        body: []const *Stmt,
        cleanup: []const []const u8,
    ) DecompileError![]const *Stmt {
        var changed = false;
        const a = self.arena.allocator();
        var out = body;
        for (out) |stmt| {
            switch (stmt.*) {
                .if_stmt => |*ifs| {
                    const new_then = try self.stripCleanupAssignDupesInBody(ifs.body, cleanup);
                    if (new_then.ptr != ifs.body.ptr or new_then.len != ifs.body.len) {
                        ifs.body = new_then;
                        changed = true;
                    }
                    const new_else = try self.stripCleanupAssignDupesInBody(ifs.else_body, cleanup);
                    if (new_else.ptr != ifs.else_body.ptr or new_else.len != ifs.else_body.len) {
                        ifs.else_body = new_else;
                        changed = true;
                    }
                    const trimmed_then = try self.stripCleanupAssignBeforeReturn(ifs.body, cleanup);
                    if (trimmed_then.ptr != ifs.body.ptr or trimmed_then.len != ifs.body.len) {
                        ifs.body = trimmed_then;
                        changed = true;
                    }
                    const trimmed_else = try self.stripCleanupAssignBeforeReturn(ifs.else_body, cleanup);
                    if (trimmed_else.ptr != ifs.else_body.ptr or trimmed_else.len != ifs.else_body.len) {
                        ifs.else_body = trimmed_else;
                        changed = true;
                    }
                },
                else => {},
            }
        }
        const trimmed = try self.stripCleanupAssignBeforeReturn(out, cleanup);
        if (trimmed.ptr != out.ptr or trimmed.len != out.len) {
            out = trimmed;
            changed = true;
        }
        if (!changed) return body;
        const next = try a.alloc(*Stmt, out.len);
        std.mem.copyForwards(*Stmt, next[0..out.len], out);
        return next;
    }

    fn normalizeTryFinalbody(self: *Decompiler, stmt: *Stmt) DecompileError!void {
        if (stmt.* != .try_stmt) return;
        const cleanup = try self.collectFinalCleanupNames(stmt.try_stmt.finalbody);
        defer self.allocator.free(cleanup);
        if (cleanup.len == 0) return;
        stmt.try_stmt.body = try self.stripCleanupAssignDupesInBody(stmt.try_stmt.body, cleanup);
        stmt.try_stmt.else_body = try self.stripCleanupAssignDupesInBody(stmt.try_stmt.else_body, cleanup);
    }

    fn recoverTryRetExpr(self: *Decompiler, try_block: u32) DecompileError!?*Expr {
        if (try_block >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[try_block];
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.enable_ifexp = true;
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        if (try_block < self.stack_in.len) {
            if (self.stack_in[try_block]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }
        var saw_pop = false;
        for (block.instructions) |inst| {
            try sim.simulate(inst);
            if (inst.opcode == .POP_BLOCK) {
                saw_pop = true;
                break;
            }
        }
        if (!saw_pop) return null;
        if (sim.stack.peek() == null) return null;
        const expr = sim.stack.popExpr() catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
        return expr;
    }

    fn isAssignNameToQualname(stmt: *const Stmt, name: []const u8, class_name: []const u8) bool {
        if (stmt.* != .assign) return false;
        if (stmt.assign.targets.len != 1) return false;
        const target = stmt.assign.targets[0];
        if (target.* != .name) return false;
        if (!std.mem.eql(u8, target.name.id, name)) return false;
        const rhs = stmt.assign.value;
        if (rhs.* != .constant or rhs.constant != .string) return false;
        const qual = rhs.constant.string;
        if (std.mem.eql(u8, qual, class_name)) return true;
        return qual.len >= class_name.len and
            std.mem.eql(u8, qual[qual.len - class_name.len ..], class_name);
    }

    fn trimClassPrelude(self: *Decompiler, body: []const *Stmt, class_name: []const u8) []const *Stmt {
        _ = self;
        if (body.len == 0) return body;
        var idx: usize = 0;
        if (idx < body.len and isAssignNameToName(body[idx], "__module__", "__name__")) {
            idx += 1;
        }
        if (idx < body.len and isAssignNameToQualname(body[idx], "__qualname__", class_name)) {
            idx += 1;
        }
        return body[idx..];
    }

    fn isFutureImportStmt(stmt: *const Stmt) bool {
        return switch (stmt.*) {
            .import_from => |i| i.module != null and std.mem.eql(u8, i.module.?, "__future__"),
            else => false,
        };
    }

    fn isEmptyHandlerBody(body: []const *Stmt) bool {
        if (body.len == 0) return true;
        if (body.len == 1 and body[0].* == .pass) return true;
        return false;
    }

    fn reorderFutureImports(allocator: Allocator, stmts: []const *Stmt) Allocator.Error![]const *Stmt {
        if (stmts.len == 0) return stmts;

        var out = try allocator.alloc(*Stmt, stmts.len);
        var out_len: usize = 0;
        var start_idx: usize = 0;

        if (isDocstringStmt(stmts[0])) {
            out[out_len] = stmts[0];
            out_len += 1;
            start_idx = 1;
        }

        var has_future = false;
        for (stmts[start_idx..]) |stmt| {
            if (isFutureImportStmt(stmt)) {
                out[out_len] = stmt;
                out_len += 1;
                has_future = true;
            }
        }
        if (!has_future) {
            allocator.free(out);
            return stmts;
        }

        for (stmts[start_idx..]) |stmt| {
            if (isFutureImportStmt(stmt)) continue;
            out[out_len] = stmt;
            out_len += 1;
        }

        return out[0..out_len];
    }

    pub fn cloneStackValues(
        self: *Decompiler,
        values: []const StackValue,
    ) DecompileError![]StackValue {
        const out = try self.allocator.alloc(StackValue, values.len);
        var count: usize = 0;
        errdefer {
            for (out[0..count]) |val| {
                val.deinit(self.allocator, self.allocator);
            }
            self.allocator.free(out);
        }
        var clone_sim = &self.clone_sim;
        clone_sim.resetForClone();

        for (values, 0..) |val, idx| {
            out[idx] = try clone_sim.cloneStackValue(val);
            count += 1;
        }

        return out;
    }

    fn cloneStackValuesWithExpr(
        self: *Decompiler,
        values: []const StackValue,
        expr: *Expr,
    ) DecompileError![]StackValue {
        const out = try self.allocator.alloc(StackValue, values.len + 1);
        var count: usize = 0;
        errdefer {
            for (out[0..count]) |val| val.deinit(self.allocator, self.allocator);
            self.allocator.free(out);
        }

        var clone_sim = &self.clone_sim;
        clone_sim.resetForClone();

        for (values, 0..) |val, idx| {
            out[idx] = try clone_sim.cloneStackValue(val);
            count += 1;
        }
        out[values.len] = try clone_sim.cloneStackValue(.{ .expr = expr });
        count += 1;

        return out;
    }

    pub fn setStackEntryWithExpr(
        self: *Decompiler,
        block_id: u32,
        base_vals: []StackValue,
        expr: *Expr,
        base_owned: *bool,
    ) DecompileError!void {
        if (block_id >= self.stack_in.len) return;
        try self.clearPhiForBlock(block_id);
        const total = base_vals.len + 1;
        const out = try self.allocator.alloc(StackValue, total);
        if (base_vals.len > 0) {
            @memcpy(out[0..base_vals.len], base_vals);
        }
        out[base_vals.len] = .{ .expr = expr };
        self.stack_in[block_id] = out;
        if (base_owned.*) base_owned.* = false;
    }

    fn clearPhiForBlock(self: *Decompiler, block_id: u32) DecompileError!void {
        const removed = self.phi_by_block.fetchRemove(block_id) orelse return;
        var slots = removed.value;
        defer slots.deinit(self.allocator);
        for (slots.items) |slot_idx| {
            _ = self.phi_slots.remove(.{ .block = block_id, .slot = slot_idx });
        }
        var remove_keys: std.ArrayListUnmanaged(PhiIncomingKey) = .{};
        defer remove_keys.deinit(self.allocator);
        var it = self.phi_incoming.iterator();
        while (it.next()) |entry| {
            if (entry.key_ptr.succ == block_id) {
                try remove_keys.append(self.allocator, entry.key_ptr.*);
            }
        }
        for (remove_keys.items) |key| {
            _ = self.phi_incoming.remove(key);
        }
    }

    fn makePhiName(self: *Decompiler) DecompileError![]const u8 {
        var buf: [32]u8 = undefined;
        const name = try std.fmt.bufPrint(&buf, "__phi{d}", .{self.phi_counter});
        self.phi_counter +|= 1;
        return try self.allocator.dupe(u8, name);
    }

    fn ensurePhiSlot(self: *Decompiler, block_id: u32, slot_idx: u32) DecompileError!*Expr {
        const key = PhiKey{ .block = block_id, .slot = slot_idx };
        if (self.phi_slots.get(key)) |slot| return slot.expr;
        const name = try self.makePhiName();
        const expr = try self.makeRawName(name, .load);
        try self.phi_slots.put(self.allocator, key, .{ .name = name, .expr = expr });
        if (self.phi_by_block.getPtr(block_id)) |list| {
            try list.append(self.allocator, slot_idx);
        } else {
            var list: std.ArrayListUnmanaged(u32) = .{};
            try list.append(self.allocator, slot_idx);
            try self.phi_by_block.put(self.allocator, block_id, list);
        }
        return expr;
    }

    fn stackValueToPhiExpr(self: *Decompiler, value: StackValue) DecompileError!*Expr {
        return switch (value) {
            .expr => |expr| expr,
            .exc_marker => try self.makeRawName("__exception__", .load),
            else => try self.makeRawName("__unknown__", .load),
        };
    }

    fn phiAssignmentsForEdge(self: *Decompiler, pred: u32, succ: u32) DecompileError![]const *Stmt {
        const slots = self.phi_by_block.get(succ) orelse return &.{};
        if (slots.items.len == 0) return &.{};
        const a = self.arena.allocator();
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(a);
        for (slots.items) |slot_idx| {
            const incoming = self.phi_incoming.get(.{ .pred = pred, .succ = succ, .slot = slot_idx }) orelse continue;
            const phi = self.phi_slots.get(.{ .block = succ, .slot = slot_idx }) orelse continue;
            if (ast.exprEqual(incoming, phi.expr)) continue;
            const target = try self.makeRawName(phi.name, .store);
            const stmt = try self.makeAssign(target, incoming);
            try out.append(a, stmt);
        }
        return out.toOwnedSlice(a);
    }

    fn appendStmtSlice(
        _: *Decompiler,
        allocator: Allocator,
        body: []const *Stmt,
        extra: []const *Stmt,
    ) DecompileError![]const *Stmt {
        if (extra.len == 0) return body;
        if (body.len == 0) return extra;
        const out = try allocator.alloc(*Stmt, body.len + extra.len);
        std.mem.copyForwards(*Stmt, out[0..body.len], body);
        std.mem.copyForwards(*Stmt, out[body.len..], extra);
        return out;
    }

    fn isNormalPred(self: *Decompiler, pred_id: u32, merge_block: u32) bool {
        if (pred_id >= self.cfg.blocks.len) return false;
        const pred = &self.cfg.blocks[pred_id];
        for (pred.successors) |edge| {
            if (edge.target != merge_block) continue;
            return edge.edge_type != .exception and edge.edge_type != .loop_back;
        }
        return false;
    }

    fn findPredForBranch(self: *Decompiler, merge_block: u32, branch_start: u32) DecompileError!?u32 {
        if (merge_block >= self.cfg.blocks.len) return null;
        const merge_blk = &self.cfg.blocks[merge_block];
        var pred: ?u32 = null;
        for (merge_blk.predecessors) |pid| {
            if (!self.isNormalPred(pid, merge_block)) continue;
            if (try self.reachesBlockNoBack(branch_start, pid, merge_block)) {
                if (pred != null and pred.? != pid) return null;
                pred = pid;
            }
        }
        return pred;
    }

    fn appendPhiAssignmentsForBranch(
        self: *Decompiler,
        merge_block: u32,
        branch_start: u32,
        body: []const *Stmt,
        allocator: Allocator,
    ) DecompileError![]const *Stmt {
        if (self.bodyEndsTerminal(body)) return body;
        const pred = try self.findPredForBranch(merge_block, branch_start) orelse return body;
        const assigns = try self.phiAssignmentsForEdge(pred, merge_block);
        return try self.appendStmtSlice(allocator, body, assigns);
    }

    fn moveStackValuesToSim(
        self: *Decompiler,
        sim: *SimContext,
        values: []StackValue,
    ) DecompileError!void {
        var moved: usize = 0;
        errdefer {
            for (values[moved..]) |val| {
                val.deinit(self.clone_sim.allocator, self.clone_sim.stack_alloc);
            }
        }

        for (values) |val| {
            try sim.stack.push(val);
            moved += 1;
        }
    }

    fn cloneStackValuesArena(
        self: *Decompiler,
        sim: *SimContext,
        values: []const StackValue,
    ) DecompileError![]StackValue {
        if (values.len == 0) return &.{};

        const out = try self.allocator.alloc(StackValue, values.len);
        errdefer self.allocator.free(out);

        for (values, 0..) |val, idx| {
            out[idx] = try sim.cloneStackValue(val);
        }

        return out;
    }

    fn cloneStackValuesArenaFlow(
        self: *Decompiler,
        sim: *SimContext,
        values: []const StackValue,
    ) DecompileError![]StackValue {
        if (values.len == 0) return &.{};

        const out = try self.allocator.alloc(StackValue, values.len);
        errdefer self.allocator.free(out);

        for (values, 0..) |val, idx| {
            out[idx] = try sim.cloneStackValueFlow(val);
        }

        return out;
    }

    fn allocUnknownStack(self: *Decompiler, len: usize) DecompileError![]StackValue {
        if (len == 0) return &.{};
        const out = try self.allocator.alloc(StackValue, len);
        errdefer self.allocator.free(out);
        for (out) |*slot| slot.* = .unknown;
        return out;
    }

    fn initPhiMergeOk(self: *Decompiler) DecompileError!void {
        if (self.phi_merge_ok != null) return;
        if (self.cfg.blocks.len == 0) return;

        var set = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        var bid: u32 = 0;
        while (bid < self.cfg.blocks.len) : (bid += 1) {
            const pat = try self.analyzer.detectPattern(bid);
            if (pat == .if_stmt) {
                const end = try self.findIfChainEnd(pat.if_stmt);
                if (end < self.cfg.blocks.len) {
                    set.set(@intCast(end));
                }
            }
        }
        self.phi_merge_ok = set;
    }

    fn allocExcStack(self: *Decompiler, len: usize) DecompileError![]StackValue {
        if (len == 0) return &.{};
        const out = try self.allocator.alloc(StackValue, len);
        errdefer self.allocator.free(out);
        for (out) |*slot| slot.* = .exc_marker;
        return out;
    }

    fn cloneStackExtra(
        self: *Decompiler,
        sim: *SimContext,
        values: []const StackValue,
        exc_extra: usize,
        lasti_extra: usize,
    ) DecompileError![]StackValue {
        const total = values.len + exc_extra + lasti_extra;
        if (total == 0) return &.{};

        const out = try self.allocator.alloc(StackValue, total);
        errdefer self.allocator.free(out);

        for (values, 0..) |val, idx| {
            out[idx] = try sim.cloneStackValueFlow(val);
        }
        var idx = values.len;
        var i: usize = 0;
        while (i < lasti_extra) : (i += 1) {
            out[idx] = .unknown;
            idx += 1;
        }
        i = 0;
        while (i < exc_extra) : (i += 1) {
            out[idx] = .exc_marker;
            idx += 1;
        }

        return out;
    }

    fn phiEligibleMerge(self: *Decompiler, merge_block: u32) bool {
        if (merge_block >= self.cfg.blocks.len) return false;
        const block = &self.cfg.blocks[merge_block];
        if (block.is_loop_header or block.is_exception_handler) return false;

        var pred_count: usize = 0;
        for (block.predecessors) |pid| {
            if (!self.isNormalPred(pid, merge_block)) continue;
            pred_count += 1;
        }
        if (self.hasConditionalPred(merge_block)) {
            if (self.phi_merge_ok) |set| {
                if (!set.isSet(@intCast(merge_block))) return false;
            } else {
                return false;
            }
        }
        return pred_count >= 2;
    }

    fn mergeStackEntry(
        self: *Decompiler,
        existing_opt: ?[]StackValue,
        incoming: []const StackValue,
        clone_sim: *SimContext,
        flow_mode: bool,
        merge_block: u32,
    ) DecompileError!?[]StackValue {
        if (existing_opt == null) {
            if (flow_mode) {
                return try self.cloneStackValuesArenaFlow(clone_sim, incoming);
            }
            return try self.cloneStackValuesArena(clone_sim, incoming);
        }

        const existing = existing_opt.?;
        const existing_len = existing.len;
        const incoming_len = incoming.len;
        if (existing_len == 0 and incoming_len == 0) return null;
        if (existing_len != incoming_len) return error.InvalidStackDepth;

        const max_len = existing_len;

        if (existing_len == max_len) {
            var unchanged = true;
            for (0..max_len) |idx| {
                const cur = existing[idx];
                const inc = incoming[idx];
                const next: StackValue = blk: {
                    if (cur == .unknown) break :blk cur;
                    if (stack_mod.stackValueEqual(cur, inc)) break :blk cur;
                    break :blk .unknown;
                };
                if (!stack_mod.stackValueEqual(cur, next)) {
                    unchanged = false;
                    break;
                }
            }
            if (unchanged) return null;
        }

        if (flow_mode) {
            var changed = false;
            const out = try self.allocator.alloc(StackValue, max_len);
            errdefer self.allocator.free(out);

            for (0..max_len) |idx| {
                const cur = existing[idx];
                const inc = incoming[idx];
                if (cur == .unknown) {
                    out[idx] = cur;
                    continue;
                }
                if (stack_mod.stackValueEqual(cur, inc)) {
                    out[idx] = cur;
                    continue;
                }
                out[idx] = .unknown;
                changed = true;
            }

            if (!changed) {
                self.allocator.free(out);
                return null;
            }
            return out;
        }

        var changed = false;
        const out = try self.allocator.alloc(StackValue, max_len);
        errdefer self.allocator.free(out);
        const can_phi = self.phiEligibleMerge(merge_block);

        for (0..max_len) |idx| {
            const cur = existing[idx];
            const inc = incoming[idx];
            if (cur == .unknown) {
                out[idx] = cur;
                continue;
            }
            if (inc == .unknown) {
                out[idx] = .unknown;
                changed = true;
                continue;
            }
            if (stack_mod.stackValueEqual(cur, inc)) {
                out[idx] = cur;
                continue;
            }
            if (!can_phi or cur != .expr or inc != .expr) {
                out[idx] = .unknown;
                changed = true;
                continue;
            }
            const phi_expr = try self.ensurePhiSlot(merge_block, @intCast(idx));
            out[idx] = .{ .expr = phi_expr };
            if (!stack_mod.stackValueEqual(cur, out[idx])) {
                changed = true;
            }
        }

        if (!changed) {
            self.allocator.free(out);
            return null;
        }

        return out;
    }

    fn buildExcIncoming(
        self: *Decompiler,
        clone_sim: *SimContext,
        sim_arena: *std.heap.ArenaAllocator,
        entry: cfg_mod.ExceptionEntry,
        start_block: *const BasicBlock,
        entry_stack: ?[]const StackValue,
        handler: *const BasicBlock,
    ) DecompileError!?[]StackValue {
        const exc_count = self.excSeedFlow(handler);
        const lasti_extra: usize = if (entry.push_lasti) 1 else 0;
        const has_table = self.version.gte(3, 11) and self.code.exceptiontable.len > 0;
        const expect_depth: ?usize = if (has_table) @intCast(entry.depth) else null;

        if (entry_stack == null) {
            if (expect_depth) |depth| {
                return try self.cloneStackExtra(clone_sim, &.{}, exc_count, lasti_extra + depth);
            }
            return null;
        }

        _ = sim_arena.reset(.retain_capacity);
        var sim = self.initSim(sim_arena.allocator(), sim_arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.flow_mode = true;
        sim.stack.allow_underflow = true;

        for (entry_stack.?) |val| {
            const cloned = try clone_sim.cloneStackValueFlow(val);
            try sim.stack.push(cloned);
        }

        for (start_block.instructions) |inst| {
            if (inst.offset >= entry.start) break;
            sim.simulate(inst) catch |err| {
                if (sim.lenient and (err == error.NotAnExpression or err == error.StackUnderflow or err == error.InvalidStackDepth)) {
                    return error.InvalidStackDepth;
                }
                return err;
            };
        }

        if (expect_depth) |depth| {
            if (sim.stack.items.items.len < depth) {
                if (self.last_error_ctx == null) {
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = start_block.id,
                        .offset = entry.start,
                        .opcode = "exc_depth_underflow",
                    };
                }
                return error.InvalidStackDepth;
            }
            while (sim.stack.items.items.len > depth) {
                if (sim.stack.pop()) |val| {
                    val.deinit(sim.allocator, sim.stack_alloc);
                }
            }
        }

        return try self.cloneStackExtra(clone_sim, sim.stack.items.items, exc_count, lasti_extra);
    }

    fn runStackSSA(
        self: *Decompiler,
        worklist: *std.ArrayListUnmanaged(u32),
        clone_sim: *SimContext,
        update_counts: ?[]u32,
        sim_arena: *std.heap.ArenaAllocator,
    ) DecompileError!void {
        const block_count: u32 = @intCast(self.cfg.blocks.len);
        var iterations: usize = 0;
        const max_iterations: usize = @as(usize, block_count) * 100;
        while (worklist.items.len > 0) {
            iterations += 1;
            const bid = worklist.items[worklist.items.len - 1];
            worklist.items.len -= 1;
            if (iterations > max_iterations) {
                if (self.last_error_ctx == null) {
                    const offset = if (bid < self.cfg.blocks.len)
                        self.cfg.blocks[bid].start_offset
                    else
                        0;
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = bid,
                        .offset = offset,
                        .opcode = "stackflow_iter_limit",
                    };
                }
                return error.InvalidStackDepth;
            }

            const entry = self.stack_in[bid] orelse continue;
            if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                const counts = update_counts.?;
                const ev = StackFlowTrace{
                    .kind = "stackflow_pop",
                    .block = bid,
                    .stack_len = @intCast(entry.len),
                    .updates = counts[bid],
                    .worklist = @intCast(worklist.items.len),
                };
                try self.writeTrace(ev);
            }

            _ = sim_arena.reset(.retain_capacity);
            var sim = self.initSim(self.arena.allocator(), sim_arena.allocator(), self.code, self.version);
            defer sim.deinit();
            sim.lenient = true;
            sim.stack.allow_underflow = true;

            for (entry) |val| {
                const cloned = try sim.cloneStackValue(val);
                try sim.stack.push(cloned);
            }

            const block = &self.cfg.blocks[bid];
            var simulate_failed = false;
            for (block.instructions) |inst| {
                sim.simulate(inst) catch |err| {
                    if (sim.lenient and (err == error.NotAnExpression or err == error.StackUnderflow or err == error.InvalidStackDepth)) {
                        simulate_failed = true;
                        break;
                    }
                    return err;
                };
            }
            if (simulate_failed) continue;

            const exit = try self.cloneStackValuesArena(clone_sim, sim.stack.items.items);
            defer if (exit.len > 0) self.allocator.free(exit);
            const term = block.terminator();
            for (block.successors) |edge| {
                const succ = edge.target;
                if (succ >= block_count) continue;
                if (edge.edge_type == .exception) continue;
                if (self.cfg.blocks[succ].is_exception_handler) continue;

                var incoming = exit;
                if (term) |t| switch (t.opcode) {
                    .FOR_ITER => {
                        if (edge.edge_type == .conditional_false) {
                            const drop: usize = if (self.version.gte(3, 12)) 1 else 2;
                            const false_len = if (incoming.len >= drop) incoming.len - drop else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .BREAK_LOOP => {
                        const drop: usize = if (self.version.gte(2, 3)) 1 else 2;
                        const out_len = if (incoming.len >= drop) incoming.len - drop else 0;
                        incoming = incoming[0..out_len];
                    },
                    .JUMP_IF_TRUE_OR_POP => {
                        if (edge.edge_type == .conditional_false) {
                            const false_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .JUMP_IF_FALSE_OR_POP => {
                        if (edge.edge_type == .conditional_true) {
                            const true_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..true_len];
                        }
                    },
                    else => {},
                };

                if (self.stack_in[succ]) |existing| {
                    if (existing.len != incoming.len) {
                        if (self.trace_stackflow and self.trace_file != null) {
                            const ev = StackFlowMismatch{
                                .kind = "stackflow_mismatch",
                                .pred = bid,
                                .succ = succ,
                                .existing_len = @intCast(existing.len),
                                .incoming_len = @intCast(incoming.len),
                            };
                            try self.writeTrace(ev);
                        }
                        return error.InvalidStackDepth;
                    }
                }
                const merged = try self.mergeStackEntry(self.stack_in[succ], incoming, clone_sim, false, succ);
                if (merged) |new_entry| {
                    if (self.stack_in[succ]) |old| {
                        if (old.len > 0) self.allocator.free(old);
                    }
                    self.stack_in[succ] = new_entry;
                    if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                        const counts = update_counts.?;
                        counts[succ] +|= 1;
                        const ev = StackFlowTrace{
                            .kind = "stackflow_update",
                            .block = succ,
                            .stack_len = @intCast(new_entry.len),
                            .updates = counts[succ],
                            .worklist = @intCast(worklist.items.len),
                        };
                        try self.writeTrace(ev);
                    }
                    try worklist.append(self.allocator, succ);
                }
            }
        }
    }

    fn runStackFlow(
        self: *Decompiler,
        worklist: *std.ArrayListUnmanaged(u32),
        clone_sim: *SimContext,
        update_counts: ?[]u32,
        sim_arena: *std.heap.ArenaAllocator,
    ) DecompileError!void {
        const block_count: u32 = @intCast(self.cfg.blocks.len);
        var iterations: usize = 0;
        const max_iterations: usize = @as(usize, block_count) * 100;
        while (worklist.items.len > 0) {
            iterations += 1;
            const bid = worklist.items[worklist.items.len - 1];
            worklist.items.len -= 1;
            if (iterations > max_iterations) {
                if (self.last_error_ctx == null) {
                    const offset = if (bid < self.cfg.blocks.len)
                        self.cfg.blocks[bid].start_offset
                    else
                        0;
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = bid,
                        .offset = offset,
                        .opcode = "stackflow_iter_limit",
                    };
                }
                return error.InvalidStackDepth;
            }

            const entry = self.stack_in[bid] orelse continue;
            if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                const counts = update_counts.?;
                const ev = StackFlowTrace{
                    .kind = "stackflow_pop",
                    .block = bid,
                    .stack_len = @intCast(entry.len),
                    .updates = counts[bid],
                    .worklist = @intCast(worklist.items.len),
                };
                try self.writeTrace(ev);
            }

            _ = sim_arena.reset(.retain_capacity);
            var sim = self.initSim(sim_arena.allocator(), sim_arena.allocator(), self.code, self.version);
            defer sim.deinit();
            sim.lenient = true;
            sim.flow_mode = true;
            sim.stack.allow_underflow = true;

            for (entry) |val| {
                const cloned = try clone_sim.cloneStackValueFlow(val);
                try sim.stack.push(cloned);
            }

            const block = &self.cfg.blocks[bid];
            var simulate_failed = false;
            for (block.instructions) |inst| {
                sim.simulate(inst) catch |err| {
                    if (sim.lenient and (err == error.NotAnExpression or err == error.StackUnderflow or err == error.InvalidStackDepth)) {
                        simulate_failed = true;
                        break;
                    }
                    return err;
                };
            }
            if (simulate_failed) continue;

            const exit = try self.cloneStackValuesArenaFlow(clone_sim, sim.stack.items.items);
            defer if (exit.len > 0) self.allocator.free(exit);
            const term = block.terminator();
            for (block.successors) |edge| {
                const succ = edge.target;
                if (succ >= block_count) continue;
                if (edge.edge_type == .exception) continue;
                if (self.cfg.blocks[succ].is_exception_handler) continue;

                var incoming = exit;
                if (term) |t| switch (t.opcode) {
                    .FOR_ITER => {
                        if (edge.edge_type == .conditional_false) {
                            // False edge sees no iteration value; iterator stays for 3.12+.
                            const drop: usize = if (self.version.gte(3, 12)) 1 else 2;
                            const false_len = if (incoming.len >= drop) incoming.len - drop else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .BREAK_LOOP => {
                        const drop: usize = if (self.version.gte(2, 3)) 1 else 2;
                        const out_len = if (incoming.len >= drop) incoming.len - drop else 0;
                        incoming = incoming[0..out_len];
                    },
                    .JUMP_IF_TRUE_OR_POP => {
                        if (edge.edge_type == .conditional_false) {
                            const false_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .JUMP_IF_FALSE_OR_POP => {
                        if (edge.edge_type == .conditional_true) {
                            const true_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..true_len];
                        }
                    },
                    else => {},
                };

                if (self.stack_in[succ]) |existing| {
                    if (existing.len != incoming.len) {
                        if (self.trace_stackflow and self.trace_file != null) {
                            const ev = StackFlowMismatch{
                                .kind = "stackflow_mismatch",
                                .pred = bid,
                                .succ = succ,
                                .existing_len = @intCast(existing.len),
                                .incoming_len = @intCast(incoming.len),
                            };
                            try self.writeTrace(ev);
                        }
                        return error.InvalidStackDepth;
                    }
                }
                const merged = try self.mergeStackEntry(self.stack_in[succ], incoming, clone_sim, true, succ);
                if (merged) |new_entry| {
                    if (self.stack_in[succ]) |old| {
                        if (old.len > 0) self.allocator.free(old);
                    }
                    self.stack_in[succ] = new_entry;
                    if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                        const counts = update_counts.?;
                        counts[succ] +|= 1;
                        const ev = StackFlowTrace{
                            .kind = "stackflow_update",
                            .block = succ,
                            .stack_len = @intCast(new_entry.len),
                            .updates = counts[succ],
                            .worklist = @intCast(worklist.items.len),
                        };
                        try self.writeTrace(ev);
                    }
                    try worklist.append(self.allocator, succ);
                }
            }
        }
    }

    fn initStackFlow(self: *Decompiler) DecompileError!void {
        const block_count: u32 = @intCast(self.cfg.blocks.len);
        if (block_count == 0) {
            self.stack_in = &.{};
            return;
        }

        self.stack_in = try self.allocator.alloc(?[]StackValue, block_count);
        errdefer {
            for (self.stack_in) |entry_opt| {
                if (entry_opt) |entry| {
                    if (entry.len > 0) self.allocator.free(entry);
                }
            }
            self.allocator.free(self.stack_in);
            self.stack_in = &.{};
        }
        for (self.stack_in) |*slot| {
            slot.* = null;
        }

        var worklist: std.ArrayListUnmanaged(u32) = .{};
        defer worklist.deinit(self.allocator);

        var update_counts: ?[]u32 = null;
        if (self.trace_stackflow) {
            update_counts = try self.allocator.alloc(u32, block_count);
            @memset(update_counts.?, 0);
        }
        defer {
            if (update_counts) |counts| self.allocator.free(counts);
        }

        if (self.stack_in[0]) |old| {
            if (old.len > 0) self.allocator.free(old);
        }
        const entry_exc = self.excSeedFlow(&self.cfg.blocks[0]);
        if (entry_exc > 0) {
            self.stack_in[0] = try self.allocExcStack(entry_exc);
        } else {
            self.stack_in[0] = &.{};
        }
        try worklist.append(self.allocator, 0);

        var clone_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer clone_sim.deinit();

        const flow_arena = self.flow_arena;
        _ = flow_arena.reset(.retain_capacity);
        try self.initPhiMergeOk();
        try self.runStackSSA(&worklist, &clone_sim, update_counts, flow_arena);

        if (self.cfg.exception_entries.len > 0) {
            var exc_iters: usize = 0;
            const max_exc_iters: usize = @as(usize, block_count) * 100;
            var changed = true;
            while (changed) {
                exc_iters += 1;
                if (exc_iters > max_exc_iters) return error.InvalidStackDepth;
                changed = false;

                for (self.cfg.exception_entries) |entry| {
                    const handler_block = self.cfg.blockContaining(entry.target) orelse continue;
                    const start_block = self.cfg.blockContaining(entry.start) orelse continue;
                    const entry_stack = if (start_block.id < self.stack_in.len)
                        self.stack_in[start_block.id]
                    else
                        null;

                    const incoming_opt = try self.buildExcIncoming(&clone_sim, flow_arena, entry, start_block, entry_stack, handler_block);
                    if (incoming_opt == null) continue;
                    const incoming = incoming_opt.?;
                    defer if (incoming.len > 0) self.deinitStackValues(incoming);

                    const hid = handler_block.id;
                    if (self.stack_in[hid]) |existing| {
                        if (existing.len != incoming.len) {
                            if (self.trace_stackflow and self.trace_file != null) {
                                const ev = StackFlowMismatch{
                                    .kind = "stackflow_mismatch",
                                    .pred = start_block.id,
                                    .succ = hid,
                                    .existing_len = @intCast(existing.len),
                                    .incoming_len = @intCast(incoming.len),
                                };
                                try self.writeTrace(ev);
                            }
                            return error.InvalidStackDepth;
                        }
                    }

                    const merged = try self.mergeStackEntry(self.stack_in[hid], incoming, &clone_sim, false, hid);
                    if (merged) |new_entry| {
                        if (self.stack_in[hid]) |old| {
                            if (old.len > 0) self.allocator.free(old);
                        }
                        self.stack_in[hid] = new_entry;
                        if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                            const counts = update_counts.?;
                            counts[hid] +|= 1;
                            const ev = StackFlowTrace{
                                .kind = "stackflow_update",
                                .block = hid,
                                .stack_len = @intCast(new_entry.len),
                                .updates = counts[hid],
                                .worklist = @intCast(worklist.items.len),
                            };
                            try self.writeTrace(ev);
                        }
                        try worklist.append(self.allocator, hid);
                        changed = true;
                    }
                }

                if (worklist.items.len > 0) {
                    try self.runStackSSA(&worklist, &clone_sim, update_counts, flow_arena);
                }
            }
        }

        var seeded_loose = false;
        for (self.cfg.blocks) |*block| {
            const exc_count = self.excSeedFlow(block);
            if (exc_count == 0) continue;
            const bid = block.id;
            if (self.stack_in[bid] != null) continue;
            self.stack_in[bid] = try self.allocExcStack(exc_count);
            if (self.trace_stackflow and update_counts != null and self.trace_file != null) {
                const counts = update_counts.?;
                counts[bid] +|= 1;
                const ev = StackFlowTrace{
                    .kind = "stackflow_update",
                    .block = bid,
                    .stack_len = @intCast(exc_count),
                    .updates = counts[bid],
                    .worklist = @intCast(worklist.items.len),
                };
                try self.writeTrace(ev);
            }
            try worklist.append(self.allocator, bid);
            seeded_loose = true;
        }
        if (seeded_loose and worklist.items.len > 0) {
            try self.runStackSSA(&worklist, &clone_sim, update_counts, flow_arena);
        }
        try self.collectPhiIncoming();
    }

    fn collectPhiIncoming(self: *Decompiler) DecompileError!void {
        if (self.phi_by_block.count() == 0) return;
        self.phi_incoming.clearRetainingCapacity();

        const sim_arena = self.sim_arena;
        _ = sim_arena.reset(.retain_capacity);

        var bid: u32 = 0;
        while (bid < self.cfg.blocks.len) : (bid += 1) {
            const block = &self.cfg.blocks[bid];
            if (self.stack_in[bid] == null) continue;

            _ = sim_arena.reset(.retain_capacity);
            var sim = self.initSim(self.arena.allocator(), sim_arena.allocator(), self.code, self.version);
            defer sim.deinit();
            if (self.hasExceptionSuccessor(block) or self.hasWithExitCleanup(block)) {
                sim.lenient = true;
                sim.stack.allow_underflow = true;
            }
            if (self.stack_in[bid]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
            if (sim.stack.len() == 0 and self.needsPredecessorSeed(block)) {
                try self.seedFromPredecessors(block.id, &sim);
            }
            for (block.instructions) |inst| {
                try sim.simulate(inst);
            }

            const exit = sim.stack.items.items;
            const term = block.terminator();
            for (block.successors) |edge| {
                const succ = edge.target;
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                if (succ >= self.cfg.blocks.len) continue;
                if (self.cfg.blocks[succ].is_exception_handler) continue;
                if (!self.phi_by_block.contains(succ)) continue;

                var incoming = exit;
                if (term) |t| switch (t.opcode) {
                    .FOR_ITER => {
                        if (edge.edge_type == .conditional_false) {
                            const drop: usize = if (self.version.gte(3, 12)) 1 else 2;
                            const false_len = if (incoming.len >= drop) incoming.len - drop else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .BREAK_LOOP => {
                        const drop: usize = if (self.version.gte(2, 3)) 1 else 2;
                        const out_len = if (incoming.len >= drop) incoming.len - drop else 0;
                        incoming = incoming[0..out_len];
                    },
                    .JUMP_IF_TRUE_OR_POP => {
                        if (edge.edge_type == .conditional_false) {
                            const false_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .JUMP_IF_FALSE_OR_POP => {
                        if (edge.edge_type == .conditional_true) {
                            const true_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..true_len];
                        }
                    },
                    else => {},
                };

                const slots = self.phi_by_block.get(succ) orelse continue;
                for (slots.items) |slot_idx| {
                    const idx: usize = @intCast(slot_idx);
                    const val = if (idx < incoming.len) incoming[idx] else .unknown;
                    const expr = try self.stackValueToPhiExpr(val);
                    try self.phi_incoming.put(self.allocator, .{
                        .pred = bid,
                        .succ = succ,
                        .slot = slot_idx,
                    }, expr);
                }
            }
        }
    }

    fn computeStackInRange(
        self: *Decompiler,
        start: u32,
        end: u32,
        init_stack: []const StackValue,
    ) DecompileError![]?[]StackValue {
        if (start >= end) return &.{};
        const count: usize = @intCast(end - start);
        var local = try self.allocator.alloc(?[]StackValue, count);
        errdefer {
            for (local) |entry_opt| {
                if (entry_opt) |entry| {
                    if (entry.len > 0) self.allocator.free(entry);
                }
            }
            self.allocator.free(local);
        }
        for (local) |*slot| {
            slot.* = null;
        }

        var worklist: std.ArrayListUnmanaged(u32) = .{};
        defer worklist.deinit(self.allocator);

        var clone_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        clone_sim.flow_mode = true;
        clone_sim.stack.allow_underflow = true;
        defer clone_sim.deinit();

        if (init_stack.len > 0) {
            const seed = try self.allocator.alloc(StackValue, init_stack.len);
            errdefer self.allocator.free(seed);
            for (init_stack, 0..) |val, idx| {
                seed[idx] = try clone_sim.cloneStackValueFlow(val);
            }
            local[0] = seed;
        } else {
            local[0] = &.{};
        }
        try worklist.append(self.allocator, start);

        const sim_arena = self.sim_arena;
        _ = sim_arena.reset(.retain_capacity);

        while (worklist.items.len > 0) {
            const bid = worklist.items[worklist.items.len - 1];
            worklist.items.len -= 1;

            const entry = local[@intCast(bid - start)] orelse continue;

            _ = sim_arena.reset(.retain_capacity);
            var sim = self.initSim(sim_arena.allocator(), sim_arena.allocator(), self.code, self.version);
            defer sim.deinit();
            sim.lenient = true;
            sim.flow_mode = true;
            sim.stack.allow_underflow = true;

            for (entry) |val| {
                const cloned = try clone_sim.cloneStackValueFlow(val);
                try sim.stack.push(cloned);
            }

            const block = &self.cfg.blocks[bid];
            var simulate_failed = false;
            for (block.instructions) |inst| {
                sim.simulate(inst) catch |err| {
                    if (sim.lenient and (err == error.NotAnExpression or err == error.StackUnderflow or err == error.InvalidStackDepth)) {
                        simulate_failed = true;
                        break;
                    }
                    return err;
                };
            }
            if (simulate_failed) continue;

            const exit = try self.cloneStackValuesArenaFlow(&clone_sim, sim.stack.items.items);
            defer if (exit.len > 0) self.allocator.free(exit);
            const term = block.terminator();
            for (block.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const succ = edge.target;
                if (succ < start or succ >= end) continue;

                var incoming = exit;
                if (term) |t| switch (t.opcode) {
                    .FOR_ITER => {
                        if (edge.edge_type == .conditional_false) {
                            // False edge sees no iteration value; iterator stays for 3.12+.
                            const drop: usize = if (self.version.gte(3, 12)) 1 else 2;
                            const false_len = if (incoming.len >= drop) incoming.len - drop else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .BREAK_LOOP => {
                        const drop: usize = if (self.version.gte(2, 3)) 1 else 2;
                        const out_len = if (incoming.len >= drop) incoming.len - drop else 0;
                        incoming = incoming[0..out_len];
                    },
                    .JUMP_IF_TRUE_OR_POP => {
                        if (edge.edge_type == .conditional_false) {
                            const false_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..false_len];
                        }
                    },
                    .JUMP_IF_FALSE_OR_POP => {
                        if (edge.edge_type == .conditional_true) {
                            const true_len = if (incoming.len >= 1) incoming.len - 1 else 0;
                            incoming = incoming[0..true_len];
                        }
                    },
                    else => {},
                };

                const idx: usize = @intCast(succ - start);
                if (local[idx]) |existing| {
                    if (existing.len != incoming.len) {
                        if (self.trace_stackflow and self.trace_file != null) {
                            const ev = StackFlowMismatch{
                                .kind = "stackflow_mismatch",
                                .pred = bid,
                                .succ = succ,
                                .existing_len = @intCast(existing.len),
                                .incoming_len = @intCast(incoming.len),
                            };
                            try self.writeTrace(ev);
                        }
                        return error.InvalidStackDepth;
                    }
                }
                const merged = try self.mergeStackEntry(local[idx], incoming, &clone_sim, true, @intCast(idx));
                if (merged) |new_entry| {
                    if (local[idx]) |old| {
                        if (old.len > 0) self.allocator.free(old);
                    }
                    local[idx] = new_entry;
                    try worklist.append(self.allocator, succ);
                }
            }
        }

        return local;
    }

    pub fn processBlockWithSim(
        self: *Decompiler,
        block: *const BasicBlock,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!void {
        return self.processBlockWithSimAndSkipInner(block, sim, stmts, stmts_allocator, 0, false);
    }

    pub fn processBlockWithSimSkipStore(
        self: *Decompiler,
        block: *const BasicBlock,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first_store: bool,
    ) DecompileError!void {
        return self.processBlockWithSimAndSkipInner(block, sim, stmts, stmts_allocator, 0, skip_first_store);
    }

    fn tryHandleChainAssignStore(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        idx: *usize,
        name: []const u8,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!bool {
        if (idx.* == 0) return false;
        const prev = instructions[idx.* - 1];
        if (prev.opcode != .DUP_TOP and prev.opcode != .COPY) return false;

        const arena = self.arena.allocator();
        var targets: std.ArrayListUnmanaged(*Expr) = .{};

        const first_target = try self.makeName(name, .store);
        try targets.append(arena, first_target);

        _ = sim.stack.pop() orelse return error.StackUnderflow;

        var j: usize = idx.* + 1;
        while (j < instructions.len) {
            const next_inst = instructions[j];
            if (next_inst.opcode == .DUP_TOP or next_inst.opcode == .COPY) {
                try sim.simulate(next_inst);
                if (j + 1 < instructions.len) {
                    const following = instructions[j + 1];
                    if (following.opcode == .STORE_NAME or
                        following.opcode == .STORE_FAST or
                        following.opcode == .STORE_GLOBAL or
                        following.opcode == .STORE_DEREF)
                    {
                        const store_name: ?[]const u8 = switch (following.opcode) {
                            .STORE_NAME, .STORE_GLOBAL => sim.getName(following.arg),
                            .STORE_FAST => sim.getLocal(following.arg),
                            .STORE_DEREF => sim.getDeref(following.arg),
                            else => null,
                        };
                        if (store_name) |sn| {
                            const target = try self.makeName(sn, .store);
                            try targets.append(arena, target);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j += 2;
                            continue;
                        }
                    } else if (following.opcode == .STORE_FAST_STORE_FAST) {
                        const idx1 = (following.arg >> 4) & 0xF;
                        const idx2 = following.arg & 0xF;
                        if (sim.getLocal(idx1)) |n1| {
                            const t1 = try self.makeName(n1, .store);
                            try targets.append(arena, t1);
                        }
                        if (sim.getLocal(idx2)) |n2| {
                            const t2 = try self.makeName(n2, .store);
                            try targets.append(arena, t2);
                        }
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                        j += 2;
                        continue;
                    } else if (following.opcode == .UNPACK_SEQUENCE) {
                        const unpack_cnt = following.arg;
                        var tup_targets: std.ArrayListUnmanaged(*Expr) = .{};
                        try tup_targets.ensureTotalCapacity(arena, unpack_cnt);

                        var kk: usize = j + 2;
                        var found: usize = 0;
                        while (found < unpack_cnt and kk < instructions.len) {
                            const us2 = instructions[kk];
                            if (us2.opcode == .STORE_FAST_STORE_FAST and found + 1 < unpack_cnt) {
                                const idx1 = (us2.arg >> 4) & 0xF;
                                const idx2 = us2.arg & 0xF;
                                if (sim.getLocal(idx1)) |n1| {
                                    const t1 = try self.makeName(n1, .store);
                                    try tup_targets.append(arena, t1);
                                    found += 1;
                                }
                                if (sim.getLocal(idx2)) |n2| {
                                    const t2 = try self.makeName(n2, .store);
                                    try tup_targets.append(arena, t2);
                                    found += 1;
                                }
                                kk += 1;
                                continue;
                            }
                            const un2: ?[]const u8 = switch (us2.opcode) {
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(us2.arg),
                                .STORE_FAST => sim.getLocal(us2.arg),
                                .STORE_DEREF => sim.getDeref(us2.arg),
                                else => null,
                            };
                            if (un2) |nm| {
                                const tgt = try self.makeName(nm, .store);
                                try tup_targets.append(arena, tgt);
                                found += 1;
                                kk += 1;
                                continue;
                            }
                            if (us2.opcode == .LOAD_NAME or us2.opcode == .LOAD_FAST or
                                us2.opcode == .LOAD_GLOBAL or us2.opcode == .LOAD_DEREF)
                            {
                                if (try self.tryParseSubscriptTarget(sim, instructions, kk, arena)) |result| {
                                    try tup_targets.append(arena, result.target);
                                    found += 1;
                                    kk = result.next_idx;
                                    continue;
                                }
                            }
                            break;
                        }

                        if (tup_targets.items.len == unpack_cnt) {
                            const tup_expr = try arena.create(Expr);
                            tup_expr.* = .{ .tuple = .{ .elts = tup_targets.items, .ctx = .store } };
                            try targets.append(arena, tup_expr);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j = kk;
                            continue;
                        }
                    } else if (following.opcode == .LOAD_NAME or
                        following.opcode == .LOAD_FAST or
                        following.opcode == .LOAD_GLOBAL or
                        following.opcode == .LOAD_DEREF)
                    {
                        if (try self.tryParseSubscriptTarget(sim, instructions, j + 1, arena)) |result| {
                            try targets.append(arena, result.target);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j = result.next_idx;
                            continue;
                        }
                    }
                }
                break;
            } else if (next_inst.opcode == .STORE_NAME or
                next_inst.opcode == .STORE_FAST or
                next_inst.opcode == .STORE_GLOBAL or
                next_inst.opcode == .STORE_DEREF)
            {
                const store_name: ?[]const u8 = switch (next_inst.opcode) {
                    .STORE_NAME, .STORE_GLOBAL => sim.getName(next_inst.arg),
                    .STORE_FAST => sim.getLocal(next_inst.arg),
                    .STORE_DEREF => sim.getDeref(next_inst.arg),
                    else => null,
                };
                if (store_name) |sn| {
                    const target = try self.makeName(sn, .store);
                    try targets.append(arena, target);
                    j += 1;
                }
                break;
            } else if (next_inst.opcode == .LOAD_NAME or
                next_inst.opcode == .LOAD_FAST or
                next_inst.opcode == .LOAD_GLOBAL or
                next_inst.opcode == .LOAD_DEREF)
            {
                if (try self.tryParseSubscriptTarget(sim, instructions, j, arena)) |result| {
                    try targets.append(arena, result.target);
                    j = result.next_idx;
                }
                break;
            } else if (next_inst.opcode == .UNPACK_SEQUENCE) {
                const unpack_count = next_inst.arg;
                var tuple_targets: std.ArrayListUnmanaged(*Expr) = .{};
                try tuple_targets.ensureTotalCapacity(arena, unpack_count);

                var k: usize = j + 1;
                var targets_found: usize = 0;
                while (targets_found < unpack_count and k < instructions.len) {
                    const us = instructions[k];
                    if (us.opcode == .STORE_FAST_STORE_FAST and targets_found + 1 < unpack_count) {
                        const idx1 = (us.arg >> 4) & 0xF;
                        const idx2 = us.arg & 0xF;
                        if (sim.getLocal(idx1)) |n1| {
                            const t1 = try self.makeName(n1, .store);
                            try tuple_targets.append(arena, t1);
                            targets_found += 1;
                        }
                        if (sim.getLocal(idx2)) |n2| {
                            const t2 = try self.makeName(n2, .store);
                            try tuple_targets.append(arena, t2);
                            targets_found += 1;
                        }
                        k += 1;
                        continue;
                    }
                    const un: ?[]const u8 = switch (us.opcode) {
                        .STORE_NAME, .STORE_GLOBAL => sim.getName(us.arg),
                        .STORE_FAST => sim.getLocal(us.arg),
                        .STORE_DEREF => sim.getDeref(us.arg),
                        else => null,
                    };
                    if (un) |tgt_name| {
                        const t = try self.makeName(tgt_name, .store);
                        try tuple_targets.append(arena, t);
                        targets_found += 1;
                        k += 1;
                        continue;
                    }
                    if (us.opcode == .LOAD_NAME or us.opcode == .LOAD_FAST or
                        us.opcode == .LOAD_GLOBAL or us.opcode == .LOAD_DEREF)
                    {
                        if (try self.tryParseSubscriptTarget(sim, instructions, k, arena)) |result| {
                            try tuple_targets.append(arena, result.target);
                            targets_found += 1;
                            k = result.next_idx;
                            continue;
                        }
                    }
                    break;
                }

                if (tuple_targets.items.len == unpack_count) {
                    const tuple_expr = try arena.create(Expr);
                    tuple_expr.* = .{ .tuple = .{ .elts = tuple_targets.items, .ctx = .store } };
                    try targets.append(arena, tuple_expr);
                    j = k;
                    var u: usize = 0;
                    while (u < unpack_count) : (u += 1) {
                        _ = sim.stack.pop() orelse break;
                    }
                }
                break;
            } else {
                break;
            }
        }

        const value_opt = sim.stack.pop();
        if (value_opt) |value| {
            if (value == .expr) {
                const stmt = try arena.create(Stmt);
                stmt.* = .{ .assign = .{
                    .targets = targets.items,
                    .value = value.expr,
                    .type_comment = null,
                } };
                try stmts.append(stmts_allocator, stmt);
            }
        } else {
            const placeholder = try ast.makeConstant(arena, .ellipsis);
            const stmt = try arena.create(Stmt);
            stmt.* = .{ .assign = .{
                .targets = targets.items,
                .value = placeholder,
                .type_comment = null,
            } };
            try stmts.append(stmts_allocator, stmt);
        }

        idx.* = j - 1;
        return true;
    }

    fn tryHandleChainAssignSubscr(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        idx: *usize,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!bool {
        const real_idx = idx.*;
        const is_chain = blk: {
            var back: usize = 1;
            var non_cache_count: usize = 0;
            while (back <= real_idx and non_cache_count < 3) : (back += 1) {
                const prev_op = instructions[real_idx - back].opcode;
                if (prev_op == .CACHE) continue;
                non_cache_count += 1;
                if (non_cache_count == 3) {
                    break :blk prev_op == .DUP_TOP or prev_op == .COPY;
                }
            }
            break :blk false;
        };
        if (!is_chain) return false;

        const arena = self.arena.allocator();
        var targets: std.ArrayListUnmanaged(*Expr) = .{};

        const key_val = sim.stack.pop() orelse {
            try sim.simulate(instructions[idx.*]);
            return true;
        };
        const container_val = sim.stack.pop() orelse {
            try sim.simulate(instructions[idx.*]);
            return true;
        };
        _ = sim.stack.pop() orelse {
            try sim.simulate(instructions[idx.*]);
            return true;
        };

        if (key_val == .expr and container_val == .expr) {
            const first_target = try arena.create(Expr);
            first_target.* = .{ .subscript = .{
                .value = container_val.expr,
                .slice = key_val.expr,
                .ctx = .store,
            } };
            try targets.append(arena, first_target);
        }

        var j: usize = idx.* + 1;
        while (j < instructions.len) {
            const next_inst = instructions[j];
            if (next_inst.opcode == .DUP_TOP or next_inst.opcode == .COPY) {
                try sim.simulate(next_inst);
                if (j + 1 < instructions.len) {
                    const following = instructions[j + 1];
                    if (following.opcode == .STORE_NAME or
                        following.opcode == .STORE_FAST or
                        following.opcode == .STORE_GLOBAL or
                        following.opcode == .STORE_DEREF)
                    {
                        const store_name: ?[]const u8 = switch (following.opcode) {
                            .STORE_NAME, .STORE_GLOBAL => sim.getName(following.arg),
                            .STORE_FAST => sim.getLocal(following.arg),
                            .STORE_DEREF => sim.getDeref(following.arg),
                            else => null,
                        };
                        if (store_name) |sn| {
                            const target = try self.makeName(sn, .store);
                            try targets.append(arena, target);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j += 2;
                            continue;
                        }
                    } else if (following.opcode == .STORE_FAST_STORE_FAST) {
                        const idx1 = (following.arg >> 4) & 0xF;
                        const idx2 = following.arg & 0xF;
                        if (sim.getLocal(idx1)) |n1| {
                            const t1 = try self.makeName(n1, .store);
                            try targets.append(arena, t1);
                        }
                        if (sim.getLocal(idx2)) |n2| {
                            const t2 = try self.makeName(n2, .store);
                            try targets.append(arena, t2);
                        }
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                        j += 2;
                        continue;
                    } else if (following.opcode == .UNPACK_SEQUENCE) {
                        const unpack_cnt = following.arg;
                        var tup_targets: std.ArrayListUnmanaged(*Expr) = .{};
                        try tup_targets.ensureTotalCapacity(arena, unpack_cnt);

                        var kk: usize = j + 2;
                        var found: usize = 0;
                        while (found < unpack_cnt and kk < instructions.len) {
                            const us2 = instructions[kk];
                            if (us2.opcode == .STORE_FAST_STORE_FAST and found + 1 < unpack_cnt) {
                                const idx1 = (us2.arg >> 4) & 0xF;
                                const idx2 = us2.arg & 0xF;
                                if (sim.getLocal(idx1)) |n1| {
                                    const t1 = try self.makeName(n1, .store);
                                    try tup_targets.append(arena, t1);
                                    found += 1;
                                }
                                if (sim.getLocal(idx2)) |n2| {
                                    const t2 = try self.makeName(n2, .store);
                                    try tup_targets.append(arena, t2);
                                    found += 1;
                                }
                                kk += 1;
                                continue;
                            }
                            const un2: ?[]const u8 = switch (us2.opcode) {
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(us2.arg),
                                .STORE_FAST => sim.getLocal(us2.arg),
                                .STORE_DEREF => sim.getDeref(us2.arg),
                                else => null,
                            };
                            if (un2) |nm| {
                                const tgt = try self.makeName(nm, .store);
                                try tup_targets.append(arena, tgt);
                                found += 1;
                                kk += 1;
                                continue;
                            }
                            if (us2.opcode == .LOAD_NAME or us2.opcode == .LOAD_FAST or
                                us2.opcode == .LOAD_GLOBAL or us2.opcode == .LOAD_DEREF)
                            {
                                if (try self.tryParseSubscriptTarget(sim, instructions, kk, arena)) |result| {
                                    try tup_targets.append(arena, result.target);
                                    found += 1;
                                    kk = result.next_idx;
                                    continue;
                                }
                            }
                            break;
                        }

                        if (tup_targets.items.len == unpack_cnt) {
                            const tup_expr = try arena.create(Expr);
                            tup_expr.* = .{ .tuple = .{ .elts = tup_targets.items, .ctx = .store } };
                            try targets.append(arena, tup_expr);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j = kk;
                            continue;
                        }
                    } else if (following.opcode == .LOAD_NAME or
                        following.opcode == .LOAD_FAST or
                        following.opcode == .LOAD_GLOBAL or
                        following.opcode == .LOAD_DEREF)
                    {
                        if (try self.tryParseSubscriptTarget(sim, instructions, j + 1, arena)) |result| {
                            try targets.append(arena, result.target);
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            j = result.next_idx;
                            continue;
                        }
                    }
                }
                break;
            } else if (next_inst.opcode == .STORE_NAME or
                next_inst.opcode == .STORE_FAST or
                next_inst.opcode == .STORE_GLOBAL or
                next_inst.opcode == .STORE_DEREF)
            {
                const store_name: ?[]const u8 = switch (next_inst.opcode) {
                    .STORE_NAME, .STORE_GLOBAL => sim.getName(next_inst.arg),
                    .STORE_FAST => sim.getLocal(next_inst.arg),
                    .STORE_DEREF => sim.getDeref(next_inst.arg),
                    else => null,
                };
                if (store_name) |sn| {
                    const target = try self.makeName(sn, .store);
                    try targets.append(arena, target);
                    j += 1;
                }
                break;
            } else if (next_inst.opcode == .LOAD_NAME or
                next_inst.opcode == .LOAD_FAST or
                next_inst.opcode == .LOAD_GLOBAL or
                next_inst.opcode == .LOAD_DEREF)
            {
                if (try self.tryParseSubscriptTarget(sim, instructions, j, arena)) |result| {
                    try targets.append(arena, result.target);
                    j = result.next_idx;
                }
                break;
            } else if (next_inst.opcode == .UNPACK_SEQUENCE) {
                const unpack_count = next_inst.arg;
                var tuple_targets: std.ArrayListUnmanaged(*Expr) = .{};
                try tuple_targets.ensureTotalCapacity(arena, unpack_count);

                var k: usize = j + 1;
                var targets_found: usize = 0;
                while (targets_found < unpack_count and k < instructions.len) {
                    const us = instructions[k];
                    if (us.opcode == .STORE_FAST_STORE_FAST and targets_found + 1 < unpack_count) {
                        const idx1 = (us.arg >> 4) & 0xF;
                        const idx2 = us.arg & 0xF;
                        if (sim.getLocal(idx1)) |n1| {
                            const t1 = try self.makeName(n1, .store);
                            try tuple_targets.append(arena, t1);
                            targets_found += 1;
                        }
                        if (sim.getLocal(idx2)) |n2| {
                            const t2 = try self.makeName(n2, .store);
                            try tuple_targets.append(arena, t2);
                            targets_found += 1;
                        }
                        k += 1;
                        continue;
                    }
                    const un: ?[]const u8 = switch (us.opcode) {
                        .STORE_NAME, .STORE_GLOBAL => sim.getName(us.arg),
                        .STORE_FAST => sim.getLocal(us.arg),
                        .STORE_DEREF => sim.getDeref(us.arg),
                        else => null,
                    };
                    if (un) |tgt_name| {
                        const t = try self.makeName(tgt_name, .store);
                        try tuple_targets.append(arena, t);
                        targets_found += 1;
                        k += 1;
                        continue;
                    }
                    if (us.opcode == .LOAD_NAME or us.opcode == .LOAD_FAST or
                        us.opcode == .LOAD_GLOBAL or us.opcode == .LOAD_DEREF)
                    {
                        if (try self.tryParseSubscriptTarget(sim, instructions, k, arena)) |result| {
                            try tuple_targets.append(arena, result.target);
                            targets_found += 1;
                            k = result.next_idx;
                            continue;
                        }
                    }
                    break;
                }

                if (tuple_targets.items.len == unpack_count) {
                    const tuple_expr = try arena.create(Expr);
                    tuple_expr.* = .{ .tuple = .{ .elts = tuple_targets.items, .ctx = .store } };
                    try targets.append(arena, tuple_expr);
                    j = k;
                    var u: usize = 0;
                    while (u < unpack_count) : (u += 1) {
                        _ = sim.stack.pop() orelse break;
                    }
                }
                break;
            } else {
                break;
            }
        }

        const value = sim.stack.pop() orelse return error.StackUnderflow;
        if (value == .expr) {
            const stmt = try arena.create(Stmt);
            stmt.* = .{ .assign = .{
                .targets = targets.items,
                .value = value.expr,
                .type_comment = null,
            } };
            try stmts.append(stmts_allocator, stmt);
        }

        idx.* = j - 1;
        return true;
    }

    const UnpackTgts = struct {
        tgts: []*Expr,
        skip: usize,
        ok: bool,
    };

    fn starTgt(
        self: *Decompiler,
        arena: Allocator,
        tgt: *Expr,
        idx: usize,
        star_pos: ?u32,
    ) DecompileError!*Expr {
        _ = self;
        if (star_pos == null or idx != @as(usize, star_pos.?)) return tgt;
        const starred = try arena.create(Expr);
        starred.* = .{ .starred = .{ .value = tgt, .ctx = .store } };
        return starred;
    }

    fn collectUnpackTgts(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        unpack_idx: usize,
        arena: Allocator,
    ) DecompileError!?UnpackTgts {
        if (unpack_idx >= instructions.len) return null;
        const inst = instructions[unpack_idx];
        if (inst.opcode != .UNPACK_SEQUENCE and inst.opcode != .UNPACK_EX) return null;

        const cnt = if (inst.opcode == .UNPACK_EX) blk: {
            const before = inst.arg & 0xFF;
            const after = (inst.arg >> 8) & 0xFF;
            break :blk before + 1 + after;
        } else inst.arg;
        const cnt_usize: usize = @intCast(cnt);

        const star_pos: ?u32 = if (inst.opcode == .UNPACK_EX) blk: {
            const before = inst.arg & 0xFF;
            break :blk before;
        } else null;

        var tgts = try std.ArrayListUnmanaged(*Expr).initCapacity(arena, cnt_usize);
        var skip: usize = 0;
        var inst_idx: usize = unpack_idx + 1;
        var found: usize = 0;

        while (found < cnt_usize and inst_idx < instructions.len) {
            const cur = instructions[inst_idx];
            if (cur.opcode == .STORE_FAST_STORE_FAST and found + 1 < cnt_usize) {
                const idx1 = (cur.arg >> 4) & 0xF;
                const idx2 = cur.arg & 0xF;
                if (sim.getLocal(idx1)) |n1| {
                    var t1 = try self.makeName(n1, .store);
                    t1 = try self.starTgt(arena, t1, found, star_pos);
                    try tgts.append(arena, t1);
                }
                if (sim.getLocal(idx2)) |n2| {
                    var t2 = try self.makeName(n2, .store);
                    t2 = try self.starTgt(arena, t2, found + 1, star_pos);
                    try tgts.append(arena, t2);
                }
                found += 2;
                skip += 1;
                inst_idx += 1;
                continue;
            }

            const name: ?[]const u8 = switch (cur.opcode) {
                .STORE_NAME, .STORE_GLOBAL => sim.getName(cur.arg),
                .STORE_FAST => sim.getLocal(cur.arg),
                .STORE_DEREF => sim.getDeref(cur.arg),
                else => null,
            };
            if (name) |n| {
                var t = try self.makeName(n, .store);
                t = try self.starTgt(arena, t, found, star_pos);
                try tgts.append(arena, t);
                found += 1;
                skip += 1;
                inst_idx += 1;
                continue;
            }

            if (isLoadInstr(cur.opcode)) {
                if (try self.tryParseSubscriptTarget(sim, instructions, inst_idx, arena)) |result| {
                    var t = result.target;
                    t = try self.starTgt(arena, t, found, star_pos);
                    try tgts.append(arena, t);
                    found += 1;
                    skip += result.next_idx - inst_idx;
                    inst_idx = result.next_idx;
                    continue;
                }
            }
            // Handle nested UNPACK_SEQUENCE/UNPACK_EX for nested tuple targets
            if (cur.opcode == .UNPACK_SEQUENCE or cur.opcode == .UNPACK_EX) {
                if (try self.collectUnpackTgts(sim, instructions, inst_idx, arena)) |nested| {
                    if (nested.ok) {
                        const tuple_expr = try arena.create(Expr);
                        // Use .load context for nested tuples to ensure parentheses are printed
                        tuple_expr.* = .{ .tuple = .{ .elts = nested.tgts, .ctx = .load } };
                        var t = tuple_expr;
                        t = try self.starTgt(arena, t, found, star_pos);
                        try tgts.append(arena, t);
                        found += 1;
                        skip += 1 + nested.skip;
                        inst_idx += 1 + nested.skip;
                        continue;
                    }
                }
            }
            break;
        }

        return .{ .tgts = tgts.items, .skip = skip, .ok = tgts.items.len == cnt_usize };
    }

    fn handleUnpack(
        self: *Decompiler,
        sim: *SimContext,
        chain_targets: *std.ArrayListUnmanaged(*Expr),
        instructions: []const decoder.Instruction,
        idx: usize,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!usize {
        const inst = instructions[idx];
        const count = if (inst.opcode == .UNPACK_EX) blk: {
            const before = inst.arg & 0xFF;
            const after = (inst.arg >> 8) & 0xFF;
            break :blk before + 1 + after;
        } else inst.arg;
        const seq_expr = try sim.stack.popExpr();
        const arena = self.arena.allocator();

        const unpack = try self.collectUnpackTgts(sim, instructions, idx, arena);
        if (unpack != null and unpack.?.ok) {
            const targets = unpack.?.tgts;
            // Check for pending chain targets from preceding STORE_ATTR
            const has_pending = chain_targets.items.len > 0;
            if (has_pending) {
                // Combine pending targets with unpack targets
                // Create: self.a = (self.b, self.c) = expr
                const all_targets = try arena.alloc(*Expr, 1 + chain_targets.items.len);

                // First, create tuple from unpack targets
                const tuple_expr = try arena.create(Expr);
                tuple_expr.* = .{ .tuple = .{
                    .elts = try arena.dupe(*Expr, targets),
                    .ctx = .store,
                } };

                // Put pending targets first (leftmost in chain), then tuple
                for (chain_targets.items, 0..) |t, t_idx| {
                    all_targets[t_idx] = t;
                }
                all_targets[chain_targets.items.len] = tuple_expr;
                chain_targets.clearRetainingCapacity();

                const stmt = try arena.create(Stmt);
                stmt.* = .{ .assign = .{
                    .targets = all_targets,
                    .value = seq_expr,
                    .type_comment = null,
                } };
                try stmts.append(stmts_allocator, stmt);
                return unpack.?.skip;
            }
            // Generate unpacking assignment: a, b, c = expr
            const stmt = try self.makeUnpackAssignExprs(targets, seq_expr);
            try stmts.append(stmts_allocator, stmt);
            return unpack.?.skip;
        }

        // Fallback: push unknown for each element
        var k: u32 = 0;
        while (k < count) : (k += 1) {
            try sim.stack.push(.unknown);
        }
        return 0;
    }

    fn processBlockWithSimAndSkip(
        self: *Decompiler,
        block: *const BasicBlock,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first: usize,
    ) DecompileError!void {
        return self.processBlockWithSimAndSkipInner(block, sim, stmts, stmts_allocator, skip_first, false);
    }

    fn inlineCleanupSkip(block: *const BasicBlock, start: usize) usize {
        const cleanup_insts = block.instructions[start..];
        var extra_skip: usize = 0;
        for (cleanup_insts, 0..) |inst, j| {
            switch (inst.opcode) {
                .END_FOR, .POP_TOP, .POP_ITER, .SWAP => {
                    extra_skip += 1;
                },
                .STORE_FAST => {
                    if (j > 0 and cleanup_insts[j - 1].opcode == .SWAP) {
                        extra_skip += 1;
                    } else {
                        break;
                    }
                },
                else => break,
            }
        }
        return extra_skip;
    }

    fn hasInlinePend(self: *const Decompiler, block_id: u32) bool {
        for (self.inline_pend.items) |item| {
            if (item.block == block_id) return true;
        }
        return false;
    }

    fn pushInlinePend(self: *Decompiler, block_id: u32, sim: *SimContext) DecompileError!void {
        if (self.inline_pend.items.len == 0) return;
        var write: usize = 0;
        for (self.inline_pend.items) |item| {
            if (item.block == block_id) {
                try sim.stack.push(.{ .expr = item.expr });
            } else {
                self.inline_pend.items[write] = item;
                write += 1;
            }
        }
        self.inline_pend.items.len = write;
    }

    fn processBlockWithSimAndSkipInner(
        self: *Decompiler,
        block: *const BasicBlock,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first: usize,
        skip_first_store_param: bool,
    ) DecompileError!void {
        // Check for pending ternary expression from tryDecompileTernaryInto
        // For inline comprehensions (Python 3.12+), we need to skip cleanup ops
        // before pushing the expression: END_FOR, POP_TOP, SWAP, STORE_FAST (loop var restore)
        var extra_skip: usize = 0;
        const has_inline = self.hasInlinePend(block.id);
        if (has_inline) {
            extra_skip = inlineCleanupSkip(block, skip_first);
        }
        if (has_inline) {
            try self.pushInlinePend(block.id, sim);
        }
        if (sim.stack.len() == 0) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        var chain_targets: std.ArrayListUnmanaged(*Expr) = .{};
        defer chain_targets.deinit(self.allocator);

        const instructions = block.instructions[skip_first + extra_skip ..];
        const inst_base = skip_first + extra_skip;
        var skip_first_store = skip_first_store_param;
        var skip_store_count: u32 = 0;
        var i: usize = 0;
        while (i < instructions.len) : (i += 1) {
            const inst = instructions[i];
            // POP_EXCEPT marks handler cleanup; allow trailing ops (e.g. return)
            if (inst.opcode == .POP_EXCEPT) {
                try sim.simulate(inst);
                continue;
            }
            if (returnCleanupSkip(instructions, i)) |skip| {
                i += skip - 1;
                continue;
            }

            errdefer if (self.last_error_ctx == null) {
                self.last_error_ctx = .{
                    .code_name = self.code.name,
                    .block_id = block.id,
                    .offset = inst.offset,
                    .opcode = inst.opcode.name(),
                };
            };
            try self.flushPendingPrint(inst.opcode, stmts, stmts_allocator);
            if (try self.handlePrintOp(sim, inst, stmts, stmts_allocator)) {
                continue;
            }
            if (inst.opcode == .IMPORT_NAME) {
                if (try self.tryDecompileImportFromGroup(sim, instructions, i, stmts, stmts_allocator)) |end_idx| {
                    i = end_idx;
                    continue;
                }
            }
            switch (inst.opcode) {
                .UNPACK_SEQUENCE, .UNPACK_EX => {
                    const count = if (inst.opcode == .UNPACK_EX) blk: {
                        const before = inst.arg & 0xFF;
                        const after = (inst.arg >> 8) & 0xFF;
                        break :blk before + 1 + after;
                    } else inst.arg;
                    if (skip_first_store) {
                        skip_first_store = false;
                        if (count == 0) {
                            _ = sim.stack.pop();
                            continue;
                        }
                        skip_store_count = count;
                        try sim.simulate(inst);
                        continue;
                    }
                    // Handle nested UNPACK_SEQUENCE when skipping for-loop targets
                    if (skip_store_count > 0) {
                        skip_store_count = skip_store_count - 1 + count;
                        try sim.simulate(inst);
                        continue;
                    }
                    const skip_count = try self.handleUnpack(sim, &chain_targets, instructions, i, stmts, stmts_allocator);
                    i += skip_count;
                    continue;
                },
                .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => {
                    if (skip_store_count > 0) {
                        skip_store_count -= 1;
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        val.deinit(sim.allocator, sim.stack_alloc);
                        continue;
                    }
                    if (skip_first_store) {
                        skip_first_store = false;
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        val.deinit(sim.allocator, sim.stack_alloc);
                        continue;
                    }
                    const abs_idx = inst_base + i;
                    const prev_was_dup = if (abs_idx > 0) blk: {
                        const prev = block.instructions[abs_idx - 1];
                        break :blk prev.opcode == .DUP_TOP or prev.opcode == .COPY;
                    } else false;

                    var name = switch (inst.opcode) {
                        .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                        .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                        .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                        else => "__unknown__",
                    };
                    if (inst.opcode == .STORE_DEREF and self.version.gte(3, 14) and std.mem.eql(u8, name, "__classdict__")) {
                        name = "__unknown__";
                    }

                    const is_classcell = inst.opcode == .STORE_NAME and std.mem.eql(u8, name, "__classcell__");

                    if (is_classcell) {
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                        self.saw_classcell = true;
                        continue;
                    }

                    // __annotate_func__ contains class annotations
                    if (inst.opcode == .STORE_NAME and self.version.gte(3, 14) and std.mem.eql(u8, name, "__annotate_func__")) {
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        if (val == .function_obj) {
                            const annotations = try sim.parseAnnotateCode(val.function_obj.code);
                            const arena = self.arena.allocator();
                            // Insert annotations after docstring (if present) at the beginning of class body
                            var insert_idx: usize = 0;
                            // Check if first statement is a docstring assignment (__doc__ = "...")
                            if (stmts.items.len > 0) {
                                const first = stmts.items[0];
                                if (first.* == .assign and first.assign.targets.len == 1) {
                                    const target = first.assign.targets[0];
                                    if (target.* == .name and std.mem.eql(u8, target.name.id, "__doc__") and
                                        first.assign.value.* == .constant and
                                        first.assign.value.constant == .string)
                                    {
                                        insert_idx = 1; // Insert after docstring
                                    }
                                }
                            }
                            for (annotations) |ann| {
                                const target = try self.makeName(ann.name, .store);
                                const stmt = try arena.create(Stmt);
                                stmt.* = .{ .ann_assign = .{
                                    .target = target,
                                    .annotation = ann.value,
                                    .value = null,
                                    .simple = true,
                                } };
                                try stmts.insert(stmts_allocator, insert_idx, stmt);
                                insert_idx += 1;
                            }
                        } else {
                            val.deinit(sim.allocator, sim.stack_alloc);
                        }
                        continue;
                    }

                    // Try to recover type alias (PEP 695)
                    if (self.version.gte(3, 12)) {
                        // Try simple type alias first
                        if (try self.tryRecoverTypeAlias(sim, instructions, i, name)) |type_stmt| {
                            try stmts.append(stmts_allocator, type_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        // Try generic type alias
                        if (try self.tryRecoverGenericTypeAlias(sim, instructions, i, name)) |type_stmt| {
                            try stmts.append(stmts_allocator, type_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        // Try generic function
                        if (try self.tryRecoverGenericFunction(sim, instructions, i, name)) |func_stmt| {
                            try stmts.append(stmts_allocator, func_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        // Try generic class
                        if (try self.tryRecoverGenericClass(sim, instructions, i, name)) |class_stmt| {
                            try stmts.append(stmts_allocator, class_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                    }

                    if (!prev_was_dup and i > 0 and instructions[i - 1].opcode == .ROT_TWO and
                        i + 1 < instructions.len)
                    {
                        const next_inst = instructions[i + 1];
                        const next_name: ?[]const u8 = switch (next_inst.opcode) {
                            .STORE_NAME, .STORE_GLOBAL => sim.getName(next_inst.arg),
                            .STORE_FAST => sim.getLocal(next_inst.arg),
                            .STORE_DEREF => sim.getDeref(next_inst.arg),
                            else => null,
                        };
                        if (next_name) |nn| {
                            if (std.mem.eql(u8, nn, "__classcell__")) {
                                // Don't fold __classcell__ into tuple assignment.
                                // Fall through to regular store handling.
                            } else {
                                const items = sim.stack.items.items;
                                if (items.len >= 2 and
                                    (items[items.len - 1] == .expr or items[items.len - 1] == .unknown) and
                                    (items[items.len - 2] == .expr or items[items.len - 2] == .unknown))
                                {
                                    const arena = self.arena.allocator();
                                    const target1 = try self.makeName(name, .store);
                                    const target2 = try self.makeName(nn, .store);
                                    const val1 = try sim.stack.popExpr();
                                    const val2 = try sim.stack.popExpr();
                                    const rhs_elts = try arena.alloc(*Expr, 2);
                                    rhs_elts[0] = val1;
                                    rhs_elts[1] = val2;
                                    const rhs_tuple = try ast.makeTuple(arena, rhs_elts, .load);
                                    const tgt_slice = try arena.alloc(*Expr, 2);
                                    tgt_slice[0] = target1;
                                    tgt_slice[1] = target2;
                                    const stmt = try self.makeUnpackAssignExprs(tgt_slice, rhs_tuple);
                                    try stmts.append(stmts_allocator, stmt);
                                    i += 1;
                                    continue;
                                }
                            }
                        }
                    }

                    if (prev_was_dup) {
                        // Check for walrus operator FIRST: COPY 1 followed by STORE_* with value used later
                        // Pattern: expr on stack, COPY 1 duplicates it, STORE_* stores the copy
                        // The original expr remains and is used in comparison/condition
                        const prev_inst: ?decoder.Instruction = if (abs_idx > 0) block.instructions[abs_idx - 1] else null;
                        const is_copy_1 = if (prev_inst) |pi| pi.opcode == .COPY and pi.arg == 1 else false;
                        if (is_copy_1) {
                            // Check if next instruction uses the stack value (not another DUP/STORE)
                            const next_idx = i + 1;
                            var is_walrus = false;
                            if (next_idx < instructions.len) {
                                const next_op = instructions[next_idx].opcode;
                                // Walrus if next instruction consumes the value for comparison, bool conversion, etc.
                                // NOT walrus if next is DUP/COPY/STORE (that's chain assignment)
                                is_walrus = switch (next_op) {
                                    .DUP_TOP, .COPY, .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => false,
                                    .COMPARE_OP, .CONTAINS_OP, .IS_OP,
                                    .TO_BOOL, .POP_JUMP_IF_TRUE, .POP_JUMP_IF_FALSE,
                                    .POP_JUMP_IF_NONE, .POP_JUMP_IF_NOT_NONE,
                                    .POP_JUMP_FORWARD_IF_TRUE, .POP_JUMP_FORWARD_IF_FALSE,
                                    .POP_JUMP_FORWARD_IF_NONE, .POP_JUMP_FORWARD_IF_NOT_NONE,
                                    .LOAD_SMALL_INT, .LOAD_CONST, .LOAD_FAST, .LOAD_FAST_BORROW,
                                    .LOAD_NAME, .LOAD_GLOBAL, .BINARY_OP,
                                    => true,
                                    else => false,
                                };
                            }

                            if (is_walrus) {
                                // Pop the copied value (what STORE_* would consume)
                                const copied = sim.stack.pop() orelse return error.StackUnderflow;
                                const val_expr = switch (copied) {
                                    .expr => |e| e,
                                    else => blk: {
                                        copied.deinit(sim.allocator, sim.stack_alloc);
                                        break :blk null;
                                    },
                                };

                                if (val_expr) |expr| {
                                    // Create named_expr: (name := expr)
                                    const arena = self.arena.allocator();
                                    const target = try self.makeName(name, .store);
                                    const named = try arena.create(Expr);
                                    named.* = .{ .named_expr = .{ .target = target, .value = expr } };

                                    // Replace the original on stack with the named_expr
                                    // Pop the original (which is now TOS after we popped the copy)
                                    if (sim.stack.pop()) |orig| {
                                        orig.deinit(sim.allocator, sim.stack_alloc);
                                    }
                                    try sim.stack.push(.{ .expr = named });
                                    continue;
                                }
                            }
                        }

                        // Not walrus - try chain assignment
                        var chain_idx = abs_idx;
                        if (try self.tryHandleChainAssignStore(sim, block.instructions, &chain_idx, name, stmts, stmts_allocator)) {
                            i = chain_idx - inst_base;
                            continue;
                        }
                    }

                    // Regular single assignment
                    const value_opt = sim.stack.pop();
                    if (value_opt == null) {
                        if (try self.tryRecoverFunctionDefFromMakeFunction(sim, instructions, i, name)) |stmt| {
                            try stmts.append(stmts_allocator, stmt);
                            continue;
                        }
                    }
                    var value = value_opt orelse StackValue.unknown;
                    errdefer value.deinit(sim.allocator, sim.stack_alloc);
                    if (value == .unknown or value == .null_marker) {
                        if (try self.tryRecoverTernaryStore(block.id, abs_idx)) |expr| {
                            value.deinit(sim.allocator, sim.stack_alloc);
                            value = .{ .expr = expr };
                        } else {
                            const expr = self.tryRecoverBoolOpStore(block.id, abs_idx) catch |err| switch (err) {
                                error.PatternNoMatch => null,
                                else => return err,
                            };
                            if (expr) |e| {
                                value.deinit(sim.allocator, sim.stack_alloc);
                                value = .{ .expr = e };
                            }
                        }
                    }

                    // Check for augmented assignment: x = x + 5 -> x += 5
                    if (value == .expr and value.expr.* == .bin_op and sim.isInplaceExpr(value.expr)) {
                        const binop = &value.expr.bin_op;
                        if (binop.left.* == .name and std.mem.eql(u8, binop.left.name.id, name)) {
                            const arena = self.arena.allocator();
                            binop.left.deinit(arena);
                            arena.destroy(binop.left);
                            const stmt = try arena.create(Stmt);
                            const target = try self.makeName(name, .store);
                            stmt.* = .{ .aug_assign = .{
                                .target = target,
                                .op = binop.op,
                                .value = binop.right,
                            } };
                            arena.destroy(value.expr);
                            try stmts.append(stmts_allocator, stmt);
                            continue;
                        }
                    }

                    if (try self.handleStoreValue(sim, name, value)) |stmt| {
                        try stmts.append(stmts_allocator, stmt);
                    }
                },
                .STORE_SUBSCR => {
                    var chain_idx = inst_base + i;
                    if (try self.tryHandleChainAssignSubscr(sim, block.instructions, &chain_idx, stmts, stmts_allocator)) {
                        i = chain_idx - inst_base;
                        continue;
                    }

                    // Regular single subscript assignment
                    const key_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const container_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const value_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };

                    // All three must be expressions to generate assignment
                    const key = if (key_val == .expr) key_val.expr else continue;
                    const container = if (container_val == .expr) container_val.expr else continue;
                    const value = if (value_val == .expr) value_val.expr else continue;

                    const a = self.arena.allocator();

                    // Check for variable annotation pattern: __annotations__['varname'] = type
                    if (container.* == .name and std.mem.eql(u8, container.name.id, "__annotations__") and
                        key.* == .constant and key.constant == .string)
                    {
                        const var_name = key.constant.string;
                        const target = try self.makeName(var_name, .store);

                        // Check if previous statement was an assignment to the same variable
                        // Pattern: x = value; __annotations__['x'] = type => x: type = value
                        var assign_value: ?*Expr = null;
                        if (stmts.items.len > 0) {
                            const prev = stmts.items[stmts.items.len - 1];
                            if (prev.* == .assign and prev.assign.targets.len == 1) {
                                const prev_target = prev.assign.targets[0];
                                if (prev_target.* == .name and std.mem.eql(u8, prev_target.name.id, var_name)) {
                                    assign_value = prev.assign.value;
                                    // Remove the previous assignment
                                    _ = stmts.pop();
                                }
                            }
                        }

                        const stmt = try a.create(Stmt);
                        stmt.* = .{ .ann_assign = .{
                            .target = target,
                            .annotation = value,
                            .value = assign_value,
                            .simple = true,
                        } };
                        try stmts.append(stmts_allocator, stmt);
                    } else {
                        const subscript = try a.create(Expr);
                        subscript.* = .{ .subscript = .{
                            .value = container,
                            .slice = key,
                            .ctx = .store,
                    } };
                        const stmt = try self.emitAssign(sim, subscript, value);
                        try stmts.append(stmts_allocator, stmt);
                    }
                },
                .STORE_SLICE => {
                    // STORE_SLICE (3.12+): TOS3[TOS2:TOS1] = TOS
                    // Stack: stop, start, container, value
                    // All stack values are arena-allocated, so no manual cleanup needed
                    const stop_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const start_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const container_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const value_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };

                    // All four must be expressions to generate assignment
                    const stop = if (stop_val == .expr) stop_val.expr else continue;
                    const start = if (start_val == .expr) start_val.expr else continue;
                    const container = if (container_val == .expr) container_val.expr else continue;
                    const value = if (value_val == .expr) value_val.expr else continue;

                    const a = self.arena.allocator();
                    // Build slice expression
                    const slice_expr = try a.create(Expr);
                    const lower = if (start.* == .constant and start.constant == .none) null else start;
                    const upper = if (stop.* == .constant and stop.constant == .none) null else stop;
                    slice_expr.* = .{ .slice = .{ .lower = lower, .upper = upper, .step = null } };

                    const subscript = try a.create(Expr);
                    subscript.* = .{ .subscript = .{
                        .value = container,
                        .slice = slice_expr,
                        .ctx = .store,
                    } };
                    const stmt = try self.emitAssign(sim, subscript, value);
                    try stmts.append(stmts_allocator, stmt);
                },
                .STORE_SLICE_0, .STORE_SLICE_1, .STORE_SLICE_2, .STORE_SLICE_3 => {
                    // Legacy STORE_SLICE+* (Python 2.x)
                    const value_val = sim.stack.pop() orelse {
                        try sim.simulate(inst);
                        continue;
                    };
                    const value = if (value_val == .expr) value_val.expr else continue;
                    var lower: ?*Expr = null;
                    var upper: ?*Expr = null;

                    const container_val = switch (inst.opcode) {
                        .STORE_SLICE_0 => sim.stack.pop() orelse {
                            try sim.simulate(inst);
                            continue;
                        },
                        .STORE_SLICE_1 => blk: {
                            const start_val = sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                            if (start_val == .expr) lower = start_val.expr;
                            break :blk sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                        },
                        .STORE_SLICE_2 => blk: {
                            const stop_val = sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                            if (stop_val == .expr) upper = stop_val.expr;
                            break :blk sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                        },
                        .STORE_SLICE_3 => blk: {
                            const stop_val = sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                            if (stop_val == .expr) upper = stop_val.expr;
                            const start_val = sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                            if (start_val == .expr) lower = start_val.expr;
                            break :blk sim.stack.pop() orelse {
                                try sim.simulate(inst);
                                continue;
                            };
                        },
                        else => unreachable,
                    };

                    const container = if (container_val == .expr) container_val.expr else continue;
                    const lower_val = if (lower) |l| (if (l.* == .constant and l.constant == .none) null else l) else null;
                    const upper_val = if (upper) |u| (if (u.* == .constant and u.constant == .none) null else u) else null;
                    const a = self.arena.allocator();
                    const slice_expr = try a.create(Expr);
                    slice_expr.* = .{ .slice = .{ .lower = lower_val, .upper = upper_val, .step = null } };
                    const subscript = try a.create(Expr);
                    subscript.* = .{ .subscript = .{
                        .value = container,
                        .slice = slice_expr,
                        .ctx = .store,
                    } };
                    const stmt = try self.emitAssign(sim, subscript, value);
                    try stmts.append(stmts_allocator, stmt);
                },
                .STORE_ATTR => {
                    var abs_idx = inst_base + i;
                    try self.emitStoreAttr(sim, &chain_targets, block.id, block.instructions, &abs_idx, stmts, stmts_allocator, 0, null);
                    i = abs_idx - inst_base;
                    continue;
                },
                .RETURN_VALUE => {
                    if (self.saw_classcell) {
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                        self.saw_classcell = false;
                        continue;
                    }
                    const value = try sim.stack.popExpr();
                    // Skip 'return None' at module level (implicit return)
                    if (self.isModuleLevel() and value.* == .constant and value.constant == .none) {
                        continue;
                    }
                    const stmt = try self.makeReturn(value);
                    try stmts.append(stmts_allocator, stmt);
                },
                .RETURN_CONST => {
                    if (sim.getConst(inst.arg)) |obj| {
                        const value = try sim.objToExpr(obj);
                        // Skip 'return None' at module level (implicit return)
                        if (self.isModuleLevel() and value.* == .constant and value.constant == .none) {
                            continue;
                        }
                        const stmt = try self.makeReturn(value);
                        try stmts.append(stmts_allocator, stmt);
                    }
                },
                .POP_TOP => {
                    try self.handlePopTopStmt(sim, block, stmts, stmts_allocator);
                },
                .YIELD_VALUE => {
                    if (self.version.lt(2, 5) and sim.comp_builder == null) {
                        const value = try sim.stack.popExpr();
                        const a = self.arena.allocator();
                        const expr = try a.create(Expr);
                        expr.* = .{ .yield_expr = .{ .value = value } };
                        if (self.makeExprStmt(expr)) |stmt| {
                            try stmts.append(stmts_allocator, stmt);
                        } else |err| {
                            if (err != error.SkipStatement) return err;
                        }
                    } else {
                        try sim.simulate(inst);
                    }
                },
                .END_FOR, .POP_ITER => {
                    // Loop cleanup opcodes - skip in non-loop context
                },
                .EXEC_STMT,
                .RAISE_VARARGS,
                .DELETE_NAME,
                .DELETE_FAST,
                .DELETE_GLOBAL,
                .DELETE_DEREF,
                .DELETE_ATTR,
                .DELETE_SUBSCR,
                .DELETE_SLICE_0,
                .DELETE_SLICE_1,
                .DELETE_SLICE_2,
                .DELETE_SLICE_3,
                => {
                    if (try self.tryEmitStatement(inst, sim, block.id, skip_first + extra_skip + i)) |stmt| {
                        try stmts.append(stmts_allocator, stmt);
                    }
                },
                else => {
                    try sim.simulate(inst);
                },
            }
        }
    }

    pub fn makeBoolPair(
        self: *Decompiler,
        left: *Expr,
        right: *Expr,
        op: ast.BoolOp,
    ) DecompileError!*Expr {
        const a = self.arena.allocator();
        const values = try a.alloc(*Expr, 2);
        values[0] = left;
        values[1] = right;
        const bool_expr = try a.create(Expr);
        bool_expr.* = .{ .bool_op = .{
            .op = op,
            .values = values,
        } };
        return bool_expr;
    }

    pub fn condReach(
        self: *Decompiler,
        start: u32,
        target: u32,
        true_block: u32,
        false_block: u32,
    ) DecompileError!bool {
        if (start == target) return true;
        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();

        try self.cond_stack.append(self.allocator, start);
        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (next == target) return true;
                if (next == true_block or next == false_block) continue;
                try self.cond_stack.append(self.allocator, next);
            }
        }
        return false;
    }

    fn branchEnd(self: *Decompiler, start: u32, stop: ?u32) DecompileError!u32 {
        var limit: u32 = stop orelse @intCast(self.cfg.blocks.len);
        if (self.br_limit) |lim| {
            if (lim < limit) limit = lim;
        }
        if (start >= limit) return start;

        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, start);

        var max_block = start;
        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (cur >= limit) continue;
            if (cur < start) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);
            if (cur > max_block) max_block = cur;

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (next < start) continue;
                if (next >= limit) continue;
                if (stop) |stop_id| {
                    if (next == stop_id) continue;
                }
                if (!self.cond_seen.isSet(next)) {
                    try self.cond_stack.append(self.allocator, next);
                }
            }
        }

        const end = max_block + 1;
        return if (end > limit) limit else end;
    }

    fn reachableInRange(
        self: *Decompiler,
        start: u32,
        limit: u32,
        stop: ?u32,
    ) DecompileError!std.DynamicBitSet {
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        if (start >= limit or start >= self.cfg.blocks.len) return seen;

        var stack: std.ArrayListUnmanaged(u32) = .{};
        defer stack.deinit(self.allocator);
        try stack.append(self.allocator, start);

        while (stack.items.len > 0) {
            const cur = stack.items[stack.items.len - 1];
            stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (cur >= limit) continue;
            if (cur < start) continue;
            if (seen.isSet(cur)) continue;
            seen.set(cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (stop) |stop_id| {
                    if (next == stop_id) continue;
                }
                if (next < start) continue;
                if (next >= limit) continue;
                if (!seen.isSet(next)) {
                    try stack.append(self.allocator, next);
                }
            }
        }

        return seen;
    }

    fn commonMerge(self: *Decompiler, then_block: u32, else_block: u32, start: u32) DecompileError!u32 {
        var limit: u32 = @intCast(self.cfg.blocks.len);
        if (self.br_limit) |lim| {
            if (lim < limit) limit = lim;
        }
        var reach_then = try self.reachableInRange(then_block, limit, null);
        defer reach_then.deinit();
        var reach_else = try self.reachableInRange(else_block, limit, null);
        defer reach_else.deinit();
        var bid: u32 = @min(then_block, else_block);
        while (bid < limit) : (bid += 1) {
            if (bid <= start) continue;
            if (reach_then.isSet(bid) and reach_else.isSet(bid)) return bid;
        }
        return limit;
    }

    fn commonMergeNoLoopBack(self: *Decompiler, then_block: u32, else_block: u32, start: u32) DecompileError!?u32 {
        var limit: u32 = @intCast(self.cfg.blocks.len);
        if (self.br_limit) |lim| {
            if (lim < limit) limit = lim;
        }
        var reach_then = try self.reachableNoLoopBack(then_block, limit, null);
        defer reach_then.deinit();
        var reach_else = try self.reachableNoLoopBack(else_block, limit, null);
        defer reach_else.deinit();
        var bid: u32 = @min(then_block, else_block);
        while (bid < limit) : (bid += 1) {
            if (bid <= start) continue;
            if (reach_then.isSet(bid) and reach_else.isSet(bid)) return bid;
        }
        return null;
    }

    fn findElseJoin(self: *Decompiler, else_block: u32, start: u32) DecompileError!?u32 {
        var limit: u32 = @intCast(self.cfg.blocks.len);
        if (self.br_limit) |lim| {
            if (lim < limit) limit = lim;
        }
        if (else_block + 1 >= limit or else_block >= self.cfg.blocks.len) return null;

        var reach = try self.reachableNoLoopBack(else_block, limit, null);
        defer reach.deinit();

        var bid: u32 = else_block + 1;
        while (bid < limit) : (bid += 1) {
            if (bid <= start) continue;
            if (!reach.isSet(bid)) continue;
            const blk = &self.cfg.blocks[bid];
            var outside_pred = false;
            for (blk.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                var skip = false;
                for (self.cfg.blocks[pred_id].successors) |edge| {
                    if (edge.target != bid) continue;
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) {
                        skip = true;
                        break;
                    }
                }
                if (skip) continue;
                if (!reach.isSet(pred_id)) {
                    outside_pred = true;
                    break;
                }
            }
            if (outside_pred) return bid;
        }
        return null;
    }

    fn reachableNoLoopBack(
        self: *Decompiler,
        start: u32,
        limit: u32,
        stop: ?u32,
    ) DecompileError!std.DynamicBitSet {
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        if (start >= limit or start >= self.cfg.blocks.len) return seen;

        var stack: std.ArrayListUnmanaged(u32) = .{};
        defer stack.deinit(self.allocator);
        try stack.append(self.allocator, start);

        while (stack.items.len > 0) {
            const cur = stack.items[stack.items.len - 1];
            stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (cur >= limit) continue;
            if (cur < start) continue;
            if (seen.isSet(cur)) continue;
            seen.set(cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                const next = edge.target;
                if (stop) |stop_id| {
                    if (next == stop_id) continue;
                }
                if (next < start) continue;
                if (next >= limit) continue;
                if (!seen.isSet(next)) {
                    try stack.append(self.allocator, next);
                }
            }
        }

        return seen;
    }

    fn isTerminalBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return true;
        const block = &self.cfg.blocks[block_id];
        for (block.successors) |edge| {
            if (edge.edge_type != .exception) return false;
        }
        return true;
    }

    fn postDominates(self: *Decompiler, post: u32, node: u32) DecompileError!bool {
        const n = self.cfg.blocks.len;
        if (post >= n or node >= n) return false;
        try self.ensurePostDom();
        const idom = self.postdom_idom orelse return false;
        const total: u32 = @intCast(n + 1);
        return cfg_mod.postDominatesIdom(idom, total, @intCast(n), post, node);
    }

    fn ensurePostDom(self: *Decompiler) DecompileError!void {
        if (self.postdom_idom != null) return;
        self.postdom_idom = try self.computePostDomIdom();
    }

    fn computePostDomIdom(self: *Decompiler) DecompileError![]u32 {
        const n = self.cfg.blocks.len;
        const total: usize = n + 1;
        const exit_id: u32 = @intCast(n);

        var succ_lists = try self.allocator.alloc(std.ArrayListUnmanaged(u32), total);
        errdefer self.allocator.free(succ_lists);
        var pred_lists = try self.allocator.alloc(std.ArrayListUnmanaged(u32), total);
        errdefer self.allocator.free(pred_lists);
        for (0..total) |i| {
            succ_lists[i] = .{};
            pred_lists[i] = .{};
        }
        errdefer {
            for (0..total) |i| {
                succ_lists[i].deinit(self.allocator);
                pred_lists[i].deinit(self.allocator);
            }
        }

        for (self.cfg.blocks, 0..) |blk, idx| {
            const u: u32 = @intCast(idx);
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const v = edge.target;
                if (v >= n) continue;
                try succ_lists[@intCast(v)].append(self.allocator, u);
                try pred_lists[@intCast(u)].append(self.allocator, v);
            }
        }

        for (0..n) |i| {
            const id: u32 = @intCast(i);
            if (self.isTerminalBlock(id)) {
                try succ_lists[@intCast(exit_id)].append(self.allocator, id);
                try pred_lists[@intCast(id)].append(self.allocator, exit_id);
            }
        }

        var succs = try self.allocator.alloc([]const u32, total);
        errdefer self.allocator.free(succs);
        var preds = try self.allocator.alloc([]const u32, total);
        errdefer self.allocator.free(preds);
        for (0..total) |i| {
            succs[i] = try succ_lists[i].toOwnedSlice(self.allocator);
            preds[i] = try pred_lists[i].toOwnedSlice(self.allocator);
        }
        for (0..total) |i| {
            succ_lists[i].deinit(self.allocator);
            pred_lists[i].deinit(self.allocator);
        }
        self.allocator.free(succ_lists);
        self.allocator.free(pred_lists);
        defer {
            for (0..total) |i| {
                if (succs[i].len > 0) self.allocator.free(succs[i]);
                if (preds[i].len > 0) self.allocator.free(preds[i]);
            }
            self.allocator.free(succs);
            self.allocator.free(preds);
        }

        return try cfg_mod.postIdomFrom(self.allocator, succs, preds, exit_id);
    }

    const TerminalResult = struct {
        block_id: u32,
        stmt: *Stmt,
    };

    fn optExprEqual(a: ?*Expr, b: ?*Expr) bool {
        if (a == null and b == null) return true;
        if (a == null or b == null) return false;
        return ast.exprEqual(a.?, b.?);
    }

    fn stmtIsTerminal(_: *Decompiler, stmt: *const Stmt) bool {
        return switch (stmt.*) {
            .return_stmt, .raise_stmt => true,
            else => false,
        };
    }

    fn stmtAlwaysTerminal(self: *Decompiler, stmt: *const Stmt) bool {
        return switch (stmt.*) {
            .return_stmt, .raise_stmt => true,
            .if_stmt => |ifs| blk: {
                if (ifs.body.len == 0 or ifs.else_body.len == 0) break :blk false;
                break :blk self.bodyEndsTerminal(ifs.body) and self.bodyEndsTerminal(ifs.else_body);
            },
            else => false,
        };
    }

    fn terminalStmtEqual(_: *Decompiler, left: *const Stmt, right: *const Stmt) bool {
        return switch (left.*) {
            .return_stmt => |l| switch (right.*) {
                .return_stmt => |r| optExprEqual(l.value, r.value),
                else => false,
            },
            .raise_stmt => |l| switch (right.*) {
                .raise_stmt => |r| optExprEqual(l.exc, r.exc) and optExprEqual(l.cause, r.cause),
                else => false,
            },
            else => false,
        };
    }

    fn pruneTrailingTerminalInStmt(self: *Decompiler, stmt: *Stmt, term: *const Stmt) void {
        switch (stmt.*) {
            .if_stmt => |*if_stmt| {
                if (if_stmt.body.len > 0) {
                    const last = if_stmt.body[if_stmt.body.len - 1];
                    if (self.stmtIsTerminal(last) and self.terminalStmtEqual(last, term)) {
                        if_stmt.body = if_stmt.body[0 .. if_stmt.body.len - 1];
                    } else if (last.* == .if_stmt) {
                        self.pruneTrailingTerminalInStmt(@constCast(last), term);
                    }
                }
                if (if_stmt.else_body.len > 0) {
                    const last = if_stmt.else_body[if_stmt.else_body.len - 1];
                    if (self.stmtIsTerminal(last) and self.terminalStmtEqual(last, term)) {
                        if_stmt.else_body = if_stmt.else_body[0 .. if_stmt.else_body.len - 1];
                    } else if (last.* == .if_stmt) {
                        self.pruneTrailingTerminalInStmt(@constCast(last), term);
                    }
                }
            },
            else => {},
        }
    }

    fn bodyEndsTerminal(self: *Decompiler, body: []const *Stmt) bool {
        if (body.len == 0) return false;
        return self.stmtAlwaysTerminal(body[body.len - 1]);
    }

    fn bodyEndsLoopTerminal(self: *Decompiler, body: []const *Stmt) bool {
        if (body.len == 0) return false;
        return self.stmtAlwaysLoopTerminal(body[body.len - 1]);
    }

    fn thenBodyIsContinueGuard(self: *Decompiler, body: []const *Stmt) bool {
        _ = self;
        if (body.len != 1) return false;
        const stmt = body[0];
        if (stmt.* != .if_stmt) return false;
        const inner = stmt.if_stmt;
        if (inner.else_body.len != 0 or inner.body.len == 0) return false;
        const last = inner.body[inner.body.len - 1];
        return last.* == .continue_stmt;
    }

    fn contGuardExpr(self: *Decompiler, stmt: *const Stmt) DecompileError!?*Expr {
        if (stmt.* != .if_stmt) return null;
        const ifs = stmt.if_stmt;
        if (ifs.else_body.len != 0) return null;
        if (ifs.body.len != 1) return null;
        const inner = ifs.body[0];
        if (inner.* == .continue_stmt) return ifs.condition;
        if (inner.* != .if_stmt) return null;
        const inner_expr = (try self.contGuardExpr(inner)) orelse return null;
        return try self.makeBoolPair(ifs.condition, inner_expr, .and_);
    }

    fn breakGuardExpr(self: *Decompiler, stmt: *const Stmt) DecompileError!?*Expr {
        if (stmt.* != .if_stmt) return null;
        const ifs = stmt.if_stmt;
        if (ifs.body.len != 1) return null;
        const inner = ifs.body[0];
        if (ifs.else_body.len == 0) {
            if (inner.* == .break_stmt) return ifs.condition;
            if (inner.* != .if_stmt) return null;
            const inner_expr = (try self.breakGuardExpr(inner)) orelse return null;
            return try self.makeBoolPair(ifs.condition, inner_expr, .and_);
        }
        if (ifs.else_body.len == 1 and ifs.else_body[0].* == .break_stmt) {
            if (inner.* != .if_stmt) return null;
            const inner_expr = (try self.breakGuardExpr(inner)) orelse return null;
            const inv = try self.invertConditionExpr(ifs.condition);
            return try self.makeBoolPair(inv, inner_expr, .or_);
        }
        return null;
    }

    fn isSimpleBreakGuard(self: *Decompiler, stmt: *const Stmt) bool {
        _ = self;
        if (stmt.* != .if_stmt) return false;
        const ifs = stmt.if_stmt;
        if (ifs.else_body.len != 0) return false;
        if (ifs.body.len != 1) return false;
        return ifs.body[0].* == .break_stmt;
    }

    fn mergeBreakGuards(self: *Decompiler, stmts: []const *Stmt) DecompileError![]const *Stmt {
        if (stmts.len == 0) return stmts;
        const a = self.arena.allocator();
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(a);

        var i: usize = 0;
        while (i < stmts.len) {
            const cond0 = try self.breakGuardExpr(stmts[i]);
            if (cond0 == null) {
                try out.append(a, stmts[i]);
                i += 1;
                continue;
            }
            var merged = cond0.?;
            var j = i + 1;
            while (j < stmts.len) {
                const condj = try self.breakGuardExpr(stmts[j]);
                if (condj == null) break;
                merged = try self.makeBoolPair(merged, condj.?, .or_);
                j += 1;
            }
            if (j == i + 1) {
                if (self.isSimpleBreakGuard(stmts[i])) {
                    try out.append(a, stmts[i]);
                } else {
                    const br = try self.makeBreak();
                    const body = try a.alloc(*Stmt, 1);
                    body[0] = br;
                    const if_stmt = try a.create(Stmt);
                    if_stmt.* = .{ .if_stmt = .{
                        .condition = merged,
                        .body = body,
                        .else_body = &.{},
                    } };
                    try out.append(a, if_stmt);
                }
                i += 1;
                continue;
            }
            const br = try self.makeBreak();
            const body = try a.alloc(*Stmt, 1);
            body[0] = br;
            const if_stmt = try a.create(Stmt);
            if_stmt.* = .{ .if_stmt = .{
                .condition = merged,
                .body = body,
                .else_body = &.{},
            } };
            try out.append(a, if_stmt);
            i = j;
        }

        return out.toOwnedSlice(a);
    }

    fn mergeContGuards(self: *Decompiler, stmts: []const *Stmt) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        const a = self.arena.allocator();
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(a);

        var i: usize = 0;
        while (i < stmts.len) {
            const cond0 = try self.contGuardExpr(stmts[i]);
            if (cond0 == null) {
                try out.append(a, stmts[i]);
                i += 1;
                continue;
            }
            var merged = cond0.?;
            var j = i + 1;
            while (j < stmts.len) {
                const condj = try self.contGuardExpr(stmts[j]);
                if (condj == null) break;
                merged = try self.makeBoolPair(merged, condj.?, .or_);
                j += 1;
            }
            if (j == i + 1) {
                try out.append(a, stmts[i]);
                i += 1;
                continue;
            }
            const cont = try self.makeContinue();
            const body = try a.alloc(*Stmt, 1);
            body[0] = cont;
            const if_stmt = try a.create(Stmt);
            if_stmt.* = .{ .if_stmt = .{
                .condition = merged,
                .body = body,
                .else_body = &.{},
            } };
            try out.append(a, if_stmt);
            i = j;
        }

        return out.toOwnedSlice(a);
    }

    fn rewriteContRaise(self: *Decompiler, stmts: []const *Stmt) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        const a = self.arena.allocator();
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(a);

        var i: usize = 0;
        while (i < stmts.len) {
            if (i + 1 < stmts.len) {
                const cur = stmts[i];
                const next = stmts[i + 1];
                if (cur.* == .if_stmt and next.* == .raise_stmt) {
                    const ifs = cur.if_stmt;
                    if (ifs.else_body.len == 0 and ifs.body.len == 1 and ifs.body[0].* == .continue_stmt) {
                        const inv = try self.invertConditionExpr(ifs.condition);
                        const body = try a.alloc(*Stmt, 1);
                        body[0] = next;
                        const stmt = try a.create(Stmt);
                        stmt.* = .{ .if_stmt = .{
                            .condition = inv,
                            .body = body,
                            .else_body = &.{},
                        } };
                        try out.append(a, stmt);
                        i += 2;
                        continue;
                    }
                }
            }
            try out.append(a, stmts[i]);
            i += 1;
        }

        return out.toOwnedSlice(a);
    }

    fn rewriteRetRaiseList(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(allocator);
        var changed = false;
        var i: usize = 0;
        while (i < stmts.len) {
            if (i + 1 < stmts.len) {
                const cur = stmts[i];
                const next = stmts[i + 1];
                if (cur.* == .if_stmt) {
                    var ifs = &cur.if_stmt;
                    if (ifs.else_body.len == 0 and ifs.body.len > 0 and next.* == .raise_stmt) {
                        const last_then = ifs.body[ifs.body.len - 1];
                        if (last_then.* == .raise_stmt and self.terminalStmtEqual(last_then, next)) {
                            try out.append(allocator, cur);
                            i += 2;
                            changed = true;
                            continue;
                        }
                        const prev_guard_chain = if (i > 0) blk: {
                            const prev = stmts[i - 1];
                            if (prev.* != .if_stmt) break :blk false;
                            const prev_if = prev.if_stmt;
                            if (prev_if.else_body.len != 0 or prev_if.body.len == 0) break :blk false;
                            const prev_last = prev_if.body[prev_if.body.len - 1];
                            break :blk self.stmtIsTerminal(prev_last);
                        } else false;
                        if (last_then.* == .return_stmt and !prev_guard_chain) {
                            const inv = try self.invertConditionExpr(ifs.condition);
                            const body = try allocator.alloc(*Stmt, 1);
                            body[0] = next;
                            const stmt = try allocator.create(Stmt);
                            stmt.* = .{ .if_stmt = .{
                                .condition = inv,
                                .body = body,
                                .else_body = &.{},
                            } };
                            try out.append(allocator, stmt);
                            try out.appendSlice(allocator, ifs.body);
                            var skip: usize = 2;
                            if (i + 2 < stmts.len) {
                                const follow = stmts[i + 2];
                                if (follow.* == .return_stmt and self.terminalStmtEqual(last_then, follow)) {
                                    skip = 3;
                                }
                            }
                            i += skip;
                            changed = true;
                            continue;
                        }
                    }
                    if (next.* == .return_stmt and ifs.body.len > 0) {
                        const last_then = ifs.body[ifs.body.len - 1];
                        if (last_then.* == .return_stmt and self.terminalStmtEqual(last_then, next)) {
                            ifs.body = ifs.body[0 .. ifs.body.len - 1];
                            changed = true;
                        }
                    }
                    if (ifs.else_body.len == 0 and ifs.body.len > 0 and ifs.body[ifs.body.len - 1].* == .return_stmt) {
                        const last_then = ifs.body[ifs.body.len - 1];
                        const ret_val = last_then.return_stmt.value;
                        const is_none = if (ret_val) |rv| rv.* == .constant and rv.constant == .none else true;
                        if (next.* == .return_stmt and !is_none) {
                            const next_val = next.return_stmt.value;
                            const bool_pair = if (ret_val != null and next_val != null)
                                (ret_val.?.* == .constant and next_val.?.* == .constant and
                                    ((ret_val.?.constant == .true_ and next_val.?.constant == .false_) or
                                        (ret_val.?.constant == .false_ and next_val.?.constant == .true_)))
                            else
                                false;
                            if (bool_pair) {
                                // Prefer guard-style boolean returns.
                                try out.append(allocator, cur);
                                i += 1;
                                continue;
                            }
                            const else_stmts = try allocator.alloc(*Stmt, 1);
                            else_stmts[0] = next;
                            ifs.else_body = else_stmts;
                            if (i + 2 < stmts.len) {
                                const follow = stmts[i + 2];
                                if (follow.* == .return_stmt and self.terminalStmtEqual(last_then, follow)) {
                                    ifs.body = ifs.body[0 .. ifs.body.len - 1];
                                }
                            }
                            try out.append(allocator, cur);
                            i += 2;
                            changed = true;
                            continue;
                        }
                    }
                }
            }
            try out.append(allocator, stmts[i]);
            i += 1;
        }
        if (!changed) {
            out.deinit(allocator);
            return stmts;
        }
        return out.toOwnedSlice(allocator);
    }

    fn rewriteRetRaiseDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.rewriteRetRaiseDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.rewriteRetRaiseDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.rewriteRetRaiseDeep(allocator, f.body);
                    f.else_body = try self.rewriteRetRaiseDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.rewriteRetRaiseDeep(allocator, w.body);
                    w.else_body = try self.rewriteRetRaiseDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.rewriteRetRaiseDeep(allocator, i.body);
                    i.else_body = try self.rewriteRetRaiseDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.rewriteRetRaiseDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.rewriteRetRaiseDeep(allocator, t.body);
                    t.else_body = try self.rewriteRetRaiseDeep(allocator, t.else_body);
                    t.finalbody = try self.rewriteRetRaiseDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, hidx| {
                            handlers[hidx] = h;
                            handlers[hidx].body = try self.rewriteRetRaiseDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, cidx| {
                            cases[cidx] = c;
                            cases[cidx].body = try self.rewriteRetRaiseDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }

        return try self.rewriteRetRaiseList(allocator, stmts);
    }

    fn rewriteLoopGuardElseList(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        _ = self;
        if (stmts.len < 2) return stmts;
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(allocator);
        var changed = false;
        var i: usize = 0;
        while (i < stmts.len) {
            const cur = stmts[i];
            if (cur.* == .if_stmt) {
                const ifs = cur.if_stmt;
                if (ifs.else_body.len == 0 and ifs.body.len >= 2) {
                    const last_then = ifs.body[ifs.body.len - 1];
                    if (last_then.* == .continue_stmt and i + 1 < stmts.len) {
                        const tail = stmts[i + 1 ..];
                        const new_body = try allocator.alloc(*Stmt, ifs.body.len - 1);
                        if (ifs.body.len > 1) {
                            std.mem.copyForwards(*Stmt, new_body, ifs.body[0 .. ifs.body.len - 1]);
                        }
                        const new_else = try allocator.alloc(*Stmt, tail.len);
                        std.mem.copyForwards(*Stmt, new_else, tail);
                        const new_if = try allocator.create(Stmt);
                        new_if.* = .{ .if_stmt = .{
                            .condition = ifs.condition,
                            .body = new_body,
                            .else_body = new_else,
                        } };
                        new_if.if_stmt.no_merge = ifs.no_merge;
                        try out.append(allocator, new_if);
                        changed = true;
                        return out.toOwnedSlice(allocator);
                    }
                }
            }
            try out.append(allocator, cur);
            i += 1;
        }
        if (!changed) {
            out.deinit(allocator);
            return stmts;
        }
        return out.toOwnedSlice(allocator);
    }

    fn rewriteLoopGuardElseDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.rewriteLoopGuardElseDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.rewriteLoopGuardElseDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.rewriteLoopGuardElseDeep(allocator, f.body);
                    f.else_body = try self.rewriteLoopGuardElseDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.rewriteLoopGuardElseDeep(allocator, w.body);
                    w.else_body = try self.rewriteLoopGuardElseDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.rewriteLoopGuardElseDeep(allocator, i.body);
                    i.else_body = try self.rewriteLoopGuardElseDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.rewriteLoopGuardElseDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.rewriteLoopGuardElseDeep(allocator, t.body);
                    t.else_body = try self.rewriteLoopGuardElseDeep(allocator, t.else_body);
                    t.finalbody = try self.rewriteLoopGuardElseDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, hidx| {
                            handlers[hidx] = h;
                            handlers[hidx].body = try self.rewriteLoopGuardElseDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, cidx| {
                            cases[cidx] = c;
                            cases[cidx].body = try self.rewriteLoopGuardElseDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }
        return try self.rewriteLoopGuardElseList(allocator, stmts);
    }

    fn stmtAlwaysLoopTerminal(self: *Decompiler, stmt: *const Stmt) bool {
        return switch (stmt.*) {
            .return_stmt, .raise_stmt, .break_stmt, .continue_stmt => true,
            .if_stmt => |ifs| blk: {
                if (ifs.body.len == 0 or ifs.else_body.len == 0) break :blk false;
                break :blk self.bodyEndsLoopTerminal(ifs.body) and self.bodyEndsLoopTerminal(ifs.else_body);
            },
            else => false,
        };
    }

    fn termSinglePred(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        var count: u32 = 0;
        for (self.cfg.blocks[block_id].predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            for (pred.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.target != block_id) continue;
                count += 1;
                break;
            }
            if (count > 1) return false;
        }
        return count == 1;
    }

    fn appendStmt(
        _: *Decompiler,
        allocator: Allocator,
        body: []const *Stmt,
        stmt: *Stmt,
    ) DecompileError![]const *Stmt {
        const out = try allocator.alloc(*Stmt, body.len + 1);
        if (body.len > 0) {
            std.mem.copyForwards(*Stmt, out[0..body.len], body);
        }
        out[body.len] = stmt;
        return out;
    }

    const ImportGroup = struct {
        module: ?[]const u8,
        level: u32,
        names: []const []const u8,
    };

    fn constInt(self: *Decompiler, idx: u32) ?i64 {
        if (idx >= self.code.consts.len) return null;
        const obj = self.code.consts[idx];
        return switch (obj) {
            .int => |v| switch (v) {
                .small => |n| n,
                .big => |b| b.toI64(),
            },
            else => null,
        };
    }

    fn collectImportFromGroups(self: *Decompiler, allocator: Allocator) DecompileError![]const ImportGroup {
        var groups: std.ArrayListUnmanaged(ImportGroup) = .{};
        errdefer groups.deinit(allocator);

        const insts = self.cfg.instructions;
        var i: usize = 0;
        while (i < insts.len) : (i += 1) {
            const inst = insts[i];
            if (inst.opcode != .IMPORT_NAME) continue;
            const module_name = if (inst.arg < self.code.names.len) self.code.names[inst.arg] else continue;
            var level: u32 = 0;
            if (self.version.gte(2, 5) and i >= 2) {
                const lvl_inst = insts[i - 2];
                if (lvl_inst.opcode == .LOAD_CONST) {
                    if (self.constInt(lvl_inst.arg)) |v| {
                        if (v >= 0) level = @intCast(v);
                    }
                }
            }

            var names: std.ArrayListUnmanaged([]const u8) = .{};
            defer names.deinit(allocator);
            var j = i + 1;
            while (j + 1 < insts.len and insts[j].opcode == .IMPORT_FROM) {
                const attr = if (insts[j].arg < self.code.names.len) self.code.names[insts[j].arg] else break;
                const store_inst = insts[j + 1];
                switch (store_inst.opcode) {
                    .STORE_NAME, .STORE_GLOBAL, .STORE_FAST, .STORE_DEREF => {},
                    else => break,
                }
                try names.append(allocator, attr);
                j += 2;
            }
            if (names.items.len > 1 and j < insts.len and insts[j].opcode == .POP_TOP) {
                const names_copy = try allocator.alloc([]const u8, names.items.len);
                std.mem.copyForwards([]const u8, names_copy, names.items);
                try groups.append(allocator, .{
                    .module = if (module_name.len == 0) null else module_name,
                    .level = level,
                    .names = names_copy,
                });
            }
            if (j > i) i = j;
        }

        return groups.toOwnedSlice(allocator);
    }

    fn namesMatchGroup(aliases: []const ast.Alias, group_names: []const []const u8) bool {
        if (aliases.len != group_names.len) return false;
        for (aliases, 0..) |alias, idx| {
            if (!std.mem.eql(u8, alias.name, group_names[idx])) return false;
        }
        return true;
    }

    fn mergeImportFromGroups(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        const groups = try self.collectImportFromGroups(allocator);
        if (groups.len == 0) return stmts;

        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(allocator);

        var i: usize = 0;
        while (i < stmts.len) {
            const stmt = stmts[i];
            if (stmt.* == .import_from) {
                const base = stmt.import_from;
                if (base.names.len > 0 and std.mem.eql(u8, base.names[0].name, "*")) {
                    try out.append(allocator, stmt);
                    i += 1;
                    continue;
                }
                var j = i;
                var aliases: std.ArrayListUnmanaged(ast.Alias) = .{};
                defer aliases.deinit(allocator);
                while (j < stmts.len and stmts[j].* == .import_from) : (j += 1) {
                    const cur = stmts[j].import_from;
                    if (cur.level != base.level) break;
                    if ((cur.module == null) != (base.module == null)) break;
                    if (cur.module != null and !std.mem.eql(u8, cur.module.?, base.module.?)) break;
                    if (cur.names.len > 0 and std.mem.eql(u8, cur.names[0].name, "*")) break;
                    try aliases.appendSlice(allocator, cur.names);
                }
                var merged = false;
                if (aliases.items.len > 1) {
                    for (groups) |group| {
                        if (group.level != base.level) continue;
                        if ((group.module == null) != (base.module == null)) continue;
                        if (group.module != null and !std.mem.eql(u8, group.module.?, base.module.?)) continue;
                        if (namesMatchGroup(aliases.items, group.names)) {
                            const a = allocator;
                            const names = try a.alloc(ast.Alias, aliases.items.len);
                            std.mem.copyForwards(ast.Alias, names, aliases.items);
                            const merged_stmt = try a.create(Stmt);
                            merged_stmt.* = .{ .import_from = .{
                                .module = base.module,
                                .names = names,
                                .level = base.level,
                            } };
                            try out.append(allocator, merged_stmt);
                            i = j;
                            merged = true;
                            break;
                        }
                    }
                }
                if (merged) continue;
            }

            try out.append(allocator, stmt);
            i += 1;
        }

        return out.toOwnedSlice(allocator);
    }

    fn mergeImportFromGroupsDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.mergeImportFromGroupsDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.mergeImportFromGroupsDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.mergeImportFromGroupsDeep(allocator, f.body);
                    f.else_body = try self.mergeImportFromGroupsDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.mergeImportFromGroupsDeep(allocator, w.body);
                    w.else_body = try self.mergeImportFromGroupsDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.mergeImportFromGroupsDeep(allocator, i.body);
                    i.else_body = try self.mergeImportFromGroupsDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.mergeImportFromGroupsDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.mergeImportFromGroupsDeep(allocator, t.body);
                    t.else_body = try self.mergeImportFromGroupsDeep(allocator, t.else_body);
                    t.finalbody = try self.mergeImportFromGroupsDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, idx| {
                            handlers[idx] = h;
                            handlers[idx].body = try self.mergeImportFromGroupsDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, idx| {
                            cases[idx] = c;
                            cases[idx].body = try self.mergeImportFromGroupsDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }

        return try self.mergeImportFromGroups(allocator, stmts);
    }

    fn rewriteGuardRetList(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        const last = stmts[stmts.len - 1];
        if (last.* != .return_stmt) return stmts;
        const last_val = last.return_stmt.value;
        var idx: usize = stmts.len - 1;
        while (idx > 0) {
            idx -= 1;
            const stmt = stmts[idx];
            if (stmt.* != .if_stmt) continue;
            const ifs = stmt.if_stmt;
            if (ifs.else_body.len != 0) continue;
            if (ifs.body.len != 1) continue;
            const body_stmt = ifs.body[0];
            if (body_stmt.* != .return_stmt) continue;
            const body_val = body_stmt.return_stmt.value;
            const same = if (body_val == null or last_val == null)
                body_val == last_val
            else
                ast.exprEqual(body_val.?, last_val.?);
            if (!same) continue;

            const cond = try self.invertConditionExpr(ifs.condition);
            const tail = stmts[idx + 1 .. stmts.len - 1];
            const new_body = if (tail.len == 0)
                &[_]*Stmt{}
            else blk: {
                const body = try allocator.alloc(*Stmt, tail.len);
                std.mem.copyForwards(*Stmt, body, tail);
                break :blk body;
            };
            const new_if = try allocator.create(Stmt);
            new_if.* = .{ .if_stmt = .{
                .condition = cond,
                .body = new_body,
                .else_body = &.{},
            } };

            const out_len = idx + 2;
            const out = try allocator.alloc(*Stmt, out_len);
            if (idx > 0) {
                std.mem.copyForwards(*Stmt, out[0..idx], stmts[0..idx]);
            }
            out[idx] = new_if;
            out[idx + 1] = last;
            return out;
        }
        return stmts;
    }

    fn rewriteGuardRetDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.rewriteGuardRetDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.rewriteGuardRetDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.rewriteGuardRetDeep(allocator, f.body);
                    f.else_body = try self.rewriteGuardRetDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.rewriteGuardRetDeep(allocator, w.body);
                    w.else_body = try self.rewriteGuardRetDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.rewriteGuardRetDeep(allocator, i.body);
                    i.else_body = try self.rewriteGuardRetDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.rewriteGuardRetDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.rewriteGuardRetDeep(allocator, t.body);
                    t.else_body = try self.rewriteGuardRetDeep(allocator, t.else_body);
                    t.finalbody = try self.rewriteGuardRetDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, hidx| {
                            handlers[hidx] = h;
                            handlers[hidx].body = try self.rewriteGuardRetDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, cidx| {
                            cases[cidx] = c;
                            cases[cidx].body = try self.rewriteGuardRetDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }

        return try self.rewriteGuardRetList(allocator, stmts);
    }

    fn rewriteTerminalElseList(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        var out: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer out.deinit(allocator);
        var changed = false;
        var i: usize = 0;
        while (i < stmts.len) {
            if (i + 1 < stmts.len) {
                const cur = stmts[i];
                if (cur.* == .if_stmt) {
                    var ifs = &cur.if_stmt;
                    if (ifs.no_merge) {
                        try out.append(allocator, cur);
                        i += 1;
                        continue;
                    }
                    if (ifs.else_body.len == 0 and ifs.body.len > 0) {
                        const last_then = ifs.body[ifs.body.len - 1];
                        if (self.stmtIsTerminal(last_then)) {
                            const next = stmts[i + 1];
                            if (self.stmtIsTerminal(next)) {
                                if (!(next.* == .raise_stmt and next.raise_stmt.exc == null and next.raise_stmt.cause == null)) {
                                    const else_stmts = try allocator.alloc(*Stmt, 1);
                                    else_stmts[0] = next;
                                    ifs.else_body = else_stmts;
                                    try out.append(allocator, cur);
                                    changed = true;
                                    i += 2;
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
            try out.append(allocator, stmts[i]);
            i += 1;
        }
        if (!changed) {
            out.deinit(allocator);
            return stmts;
        }
        return out.toOwnedSlice(allocator);
    }

    fn rewriteTerminalElseDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.rewriteTerminalElseDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.rewriteTerminalElseDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.rewriteTerminalElseDeep(allocator, f.body);
                    f.else_body = try self.rewriteTerminalElseDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.rewriteTerminalElseDeep(allocator, w.body);
                    w.else_body = try self.rewriteTerminalElseDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.rewriteTerminalElseDeep(allocator, i.body);
                    i.else_body = try self.rewriteTerminalElseDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.rewriteTerminalElseDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.rewriteTerminalElseDeep(allocator, t.body);
                    t.else_body = try self.rewriteTerminalElseDeep(allocator, t.else_body);
                    t.finalbody = try self.rewriteTerminalElseDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, hidx| {
                            handlers[hidx] = h;
                            handlers[hidx].body = try self.rewriteTerminalElseDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, cidx| {
                            cases[cidx] = c;
                            cases[cidx].body = try self.rewriteTerminalElseDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }
        return try self.rewriteTerminalElseList(allocator, stmts);
    }

    fn trimPostTerminalCleanupList(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        if (stmts.len < 2) return stmts;
        var i: usize = 0;
        while (i + 1 < stmts.len) : (i += 1) {
            if (!self.stmtIsTerminal(stmts[i])) continue;
            var j = i + 1;
            while (j < stmts.len) {
                if (Decompiler.isReturnNone(stmts[j])) {
                    j += 1;
                    continue;
                }
                if (j + 1 < stmts.len) {
                    if (self.cleanupPairName(stmts[j .. j + 2])) |_| {
                        j += 2;
                        continue;
                    }
                }
                j = 0;
                break;
            }
            if (j == 0) continue;
            const out = try allocator.alloc(*Stmt, i + 1);
            std.mem.copyForwards(*Stmt, out, stmts[0 .. i + 1]);
            return out;
        }
        return stmts;
    }

    fn trimPostTerminalCleanupDeep(
        self: *Decompiler,
        allocator: Allocator,
        stmts: []const *Stmt,
    ) DecompileError![]const *Stmt {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .function_def => |*f| {
                    f.body = try self.trimPostTerminalCleanupDeep(allocator, f.body);
                },
                .class_def => |*c| {
                    c.body = try self.trimPostTerminalCleanupDeep(allocator, c.body);
                },
                .for_stmt => |*f| {
                    f.body = try self.trimPostTerminalCleanupDeep(allocator, f.body);
                    f.else_body = try self.trimPostTerminalCleanupDeep(allocator, f.else_body);
                },
                .while_stmt => |*w| {
                    w.body = try self.trimPostTerminalCleanupDeep(allocator, w.body);
                    w.else_body = try self.trimPostTerminalCleanupDeep(allocator, w.else_body);
                },
                .if_stmt => |*i| {
                    i.body = try self.trimPostTerminalCleanupDeep(allocator, i.body);
                    i.else_body = try self.trimPostTerminalCleanupDeep(allocator, i.else_body);
                },
                .with_stmt => |*w| {
                    w.body = try self.trimPostTerminalCleanupDeep(allocator, w.body);
                },
                .try_stmt => |*t| {
                    t.body = try self.trimPostTerminalCleanupDeep(allocator, t.body);
                    t.else_body = try self.trimPostTerminalCleanupDeep(allocator, t.else_body);
                    t.finalbody = try self.trimPostTerminalCleanupDeep(allocator, t.finalbody);
                    if (t.handlers.len > 0) {
                        const handlers = try allocator.alloc(ast.ExceptHandler, t.handlers.len);
                        for (t.handlers, 0..) |h, hidx| {
                            handlers[hidx] = h;
                            handlers[hidx].body = try self.trimPostTerminalCleanupDeep(allocator, h.body);
                        }
                        t.handlers = handlers;
                    }
                },
                .match_stmt => |*m| {
                    if (m.cases.len > 0) {
                        const cases = try allocator.alloc(ast.MatchCase, m.cases.len);
                        for (m.cases, 0..) |c, cidx| {
                            cases[cidx] = c;
                            cases[cidx].body = try self.trimPostTerminalCleanupDeep(allocator, c.body);
                        }
                        m.cases = cases;
                    }
                },
                else => {},
            }
        }
        return try self.trimPostTerminalCleanupList(allocator, stmts);
    }

    fn reachesBlock(
        self: *Decompiler,
        start: u32,
        target: u32,
        stop: ?u32,
    ) DecompileError!bool {
        if (start == target) return true;
        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, start);

        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (stop) |stop_id| {
                    if (next == stop_id) continue;
                }
                if (next == target) return true;
                if (!self.cond_seen.isSet(next)) {
                    try self.cond_stack.append(self.allocator, next);
                }
            }
        }
        return false;
    }

    fn reachesBlockNoBack(
        self: *Decompiler,
        start: u32,
        target: u32,
        stop: ?u32,
    ) DecompileError!bool {
        if (start == target) return true;
        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, start);

        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                const next = edge.target;
                if (stop) |stop_id| {
                    if (next == stop_id) continue;
                }
                if (next == target) return true;
                if (!self.cond_seen.isSet(next)) {
                    try self.cond_stack.append(self.allocator, next);
                }
            }
        }
        return false;
    }

    fn findTerminalStmtFrom(
        self: *Decompiler,
        start: u32,
        stop: u32,
    ) DecompileError!?TerminalResult {
        if (start >= self.cfg.blocks.len) return null;
        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, start);

        const a = self.arena.allocator();
        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (cur == stop) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            if (self.isTerminalBlock(cur)) {
                var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                defer tmp.deinit(a);
                try self.decompileBlockIntoWithStackAndSkip(cur, &tmp, a, &.{}, 0);
                if (tmp.items.len == 1 and self.stmtIsTerminal(tmp.items[0])) {
                    return .{ .block_id = cur, .stmt = tmp.items[0] };
                }
            }

            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (next == stop) continue;
                if (!self.cond_seen.isSet(next)) {
                    try self.cond_stack.append(self.allocator, next);
                }
            }
        }

        return null;
    }

    pub fn buildCondTree(
        self: *Decompiler,
        block_id: u32,
        first_block: u32,
        first_expr: *Expr,
        true_block: u32,
        false_block: u32,
        base_vals: []const StackValue,
        stop_false: ?u32,
        cond_kind: ?ctrl.BoolOpKind,
        in_stack: *std.DynamicBitSet,
        memo: *std.AutoHashMapUnmanaged(u32, *Expr),
    ) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        if (stop_false) |stop_id| {
            if (block_id == stop_id) return null;
        }
        if (memo.get(block_id)) |expr| return expr;
        if (in_stack.isSet(block_id)) return null;
        in_stack.set(block_id);
        defer in_stack.unset(block_id);

        const block = &self.cfg.blocks[block_id];
        const term = block.terminator() orelse return null;
        if (!ctrl.Analyzer.isConditionalJump(undefined, term.opcode)) return null;

        var expr: *Expr = undefined;
        var extra = false;
        if (block_id == first_block) {
            expr = first_expr;
        } else {
            const eval = (try self.evalCondBlock(block_id, base_vals, cond_kind)) orelse return null;
            expr = eval.expr;
            extra = eval.extra;
        }

        var true_id: ?u32 = null;
        var false_id: ?u32 = null;
        for (block.successors) |edge| {
            if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                true_id = edge.target;
            } else if (edge.edge_type == .conditional_false) {
                false_id = edge.target;
            }
        }
        if (true_id == null or false_id == null) return null;

        var t_id = true_id.?;
        var f_id = false_id.?;
        if (extra) {
            const false_target = stop_false orelse false_block;
            if (try self.tryChainCond(expr, t_id, f_id, false_target)) |chain| {
                expr = chain.expr;
                t_id = chain.t_id;
                f_id = chain.f_id;
            } else {
                return null;
            }
        }
        const t_res = self.resolveJumpOnlyBlock(t_id);
        const f_res = self.resolveJumpOnlyBlock(f_id);
        const false_target = stop_false orelse false_block;
        const t_is_false = t_res == false_target;
        const f_is_false = f_res == false_target;

        if (t_res == true_block and f_is_false) {
            try memo.put(self.allocator, block_id, expr);
            return expr;
        }

        if (t_is_false and f_is_false) return null;

        if (t_res == true_block) {
            const rhs = (try self.buildCondTree(
                f_id,
                first_block,
                first_expr,
                true_block,
                false_block,
                base_vals,
                stop_false,
                cond_kind,
                in_stack,
                memo,
            )) orelse return null;
            const out = try self.makeBoolPair(expr, rhs, .or_);
            try memo.put(self.allocator, block_id, out);
            return out;
        }
        if (f_is_false) {
            const rhs = (try self.buildCondTree(
                t_id,
                first_block,
                first_expr,
                true_block,
                false_block,
                base_vals,
                stop_false,
                cond_kind,
                in_stack,
                memo,
            )) orelse return null;
            const out = try self.makeBoolPair(expr, rhs, .and_);
            try memo.put(self.allocator, block_id, out);
            return out;
        }
        if (t_is_false) {
            const rhs = (try self.buildCondTree(
                f_id,
                first_block,
                first_expr,
                true_block,
                false_block,
                base_vals,
                stop_false,
                cond_kind,
                in_stack,
                memo,
            )) orelse return null;
            const not_expr = try ast.makeUnaryOp(self.arena.allocator(), .not_, expr);
            const out = try self.makeBoolPair(not_expr, rhs, .and_);
            try memo.put(self.allocator, block_id, out);
            return out;
        }

        const t_expr = (try self.buildCondTree(
            t_id,
            first_block,
            first_expr,
            true_block,
            false_block,
            base_vals,
            stop_false,
            cond_kind,
            in_stack,
            memo,
        )) orelse return null;
        const f_expr = (try self.buildCondTree(
            f_id,
            first_block,
            first_expr,
            true_block,
            false_block,
            base_vals,
            stop_false,
            cond_kind,
            in_stack,
            memo,
        )) orelse return null;

        if (try self.condReach(t_id, f_id, true_block, false_block)) {
            var t_stop_expr: ?*Expr = null;
            if (stop_false == null) {
                t_stop_expr = try self.buildCondTreeStopped(
                    t_id,
                    first_block,
                    first_expr,
                    true_block,
                    false_block,
                    base_vals,
                    f_id,
                    cond_kind,
                );
            }
            const t_use = t_stop_expr orelse t_expr;
            const left = try self.makeBoolPair(expr, t_use, .and_);
            const out = try self.makeBoolPair(left, f_expr, .or_);
            try memo.put(self.allocator, block_id, out);
            return out;
        }
        if (try self.condReach(f_id, t_id, true_block, false_block)) {
            var f_stop_expr: ?*Expr = null;
            if (stop_false == null) {
                f_stop_expr = try self.buildCondTreeStopped(
                    f_id,
                    first_block,
                    first_expr,
                    true_block,
                    false_block,
                    base_vals,
                    t_id,
                    cond_kind,
                );
            }
            const f_use = f_stop_expr orelse f_expr;
            const left = try self.makeBoolPair(expr, f_use, .or_);
            const out = try self.makeBoolPair(left, t_expr, .and_);
            try memo.put(self.allocator, block_id, out);
            return out;
        }

        const not_expr = try ast.makeUnaryOp(self.arena.allocator(), .not_, expr);
        const left = try self.makeBoolPair(expr, t_expr, .and_);
        const right = try self.makeBoolPair(not_expr, f_expr, .and_);
        const out = try self.makeBoolPair(left, right, .or_);
        try memo.put(self.allocator, block_id, out);
        return out;
    }

    fn buildCondTreeStopped(
        self: *Decompiler,
        block_id: u32,
        first_block: u32,
        first_expr: *Expr,
        true_block: u32,
        false_block: u32,
        base_vals: []const StackValue,
        stop_false: u32,
        cond_kind: ?ctrl.BoolOpKind,
    ) DecompileError!?*Expr {
        var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer in_stack.deinit();

        var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
        defer memo.deinit(self.allocator);

        return self.buildCondTree(
            block_id,
            first_block,
            first_expr,
            true_block,
            false_block,
            base_vals,
            stop_false,
            cond_kind,
            &in_stack,
            &memo,
        );
    }

    fn loopHasCompAdd(self: *Decompiler, pattern: ctrl.ForPattern) DecompileError!bool {
        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, pattern.body_block);

        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (cur == pattern.exit_block or cur == pattern.header_block) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            const blk = &self.cfg.blocks[cur];
            for (blk.instructions) |inst| {
                if (inst.opcode == .LIST_APPEND or inst.opcode == .SET_ADD or inst.opcode == .MAP_ADD) {
                    return true;
                }
            }
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (next == pattern.exit_block or next == pattern.header_block) continue;
                if (self.cond_seen.isSet(next)) continue;
                try self.cond_stack.append(self.allocator, next);
            }
        }

        return false;
    }

    const CondEval = struct {
        expr: *Expr,
        extra: bool,
    };

    fn evalCondBlock(
        self: *Decompiler,
        block_id: u32,
        base_vals: []const StackValue,
        cond_kind: ?ctrl.BoolOpKind,
    ) DecompileError!?CondEval {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];

        var skip: usize = 0;
        if (cond_kind) |kind| {
            skip = self.boolOpBlockSkip(block, kind);
        }
        if (skip > block.instructions.len) return null;

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();

        for (base_vals) |val| {
            try sim.stack.push(try sim.cloneStackValue(val));
        }

        for (block.instructions[skip..], 0..) |inst, rel_idx| {
            const idx = skip + rel_idx;
            if (cond_kind) |kind| {
                if (kind == .pop_top) {
                    if (idx + 2 < block.instructions.len and
                        inst.opcode == .COPY and inst.arg == 1 and
                        block.instructions[idx + 1].opcode == .TO_BOOL and
                        ctrl.Analyzer.isConditionalJump(undefined, block.instructions[idx + 2].opcode))
                    {
                        break;
                    }
                }
            }
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            if (isStatementOpcode(inst.opcode)) return null;
            self.simOpt(&sim, inst) catch |err| switch (err) {
                error.PatternNoMatch => return null,
                else => return err,
            };
        }

        const expr = self.popExprMatch(&sim) catch |err| switch (err) {
            error.PatternNoMatch => return null,
            else => return err,
        };
        if (sim.stack.len() == base_vals.len) return .{ .expr = expr, .extra = false };
        if (sim.stack.len() == base_vals.len + 1) return .{ .expr = expr, .extra = true };
        return null;
    }

    const ChainCond = struct {
        expr: *Expr,
        t_id: u32,
        f_id: u32,
    };

    fn tryChainCond(
        self: *Decompiler,
        expr: *Expr,
        t_id: u32,
        f_id: u32,
        false_target: u32,
    ) DecompileError!?ChainCond {
        if (expr.* != .compare) return null;
        const cmp1 = expr.compare;
        if (cmp1.comparators.len == 0) return null;
        if (self.resolveJumpOnlyBlock(f_id) != false_target) return null;
        if (t_id >= self.cfg.blocks.len) return null;

        const then_blk = &self.cfg.blocks[t_id];
        if (condBlockHasPrelude(then_blk)) return null;
        const then_term = then_blk.terminator() orelse return null;
        if (!ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) return null;

        var t2_id: ?u32 = null;
        var f2_id: ?u32 = null;
        for (then_blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            if (edge.edge_type == .conditional_false) {
                f2_id = edge.target;
            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                t2_id = edge.target;
            }
        }
        if (t2_id == null or f2_id == null) return null;
        if (self.resolveJumpOnlyBlock(f2_id.?) != false_target) return null;

        const mid = cmp1.comparators[cmp1.comparators.len - 1];
        var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer then_sim.deinit();
        then_sim.lenient = true;
        then_sim.stack.allow_underflow = true;

        const mid_val: StackValue = .{ .expr = mid };
        try then_sim.stack.push(try then_sim.cloneStackValue(mid_val));

        const cond2 = (try self.condExprFromBlock(t_id, &then_sim, t2_id.?, f2_id.?, 0)) orelse return null;
        if (cond2.* != .compare) return null;
        if (!ast.exprEqual(mid, cond2.compare.left)) return null;

        const merged = (try self.mergeCompareChain(expr, cond2)) orelse return null;
        return .{
            .expr = merged,
            .t_id = self.resolveJumpOnlyBlock(t2_id.?),
            .f_id = self.resolveJumpOnlyBlock(f2_id.?),
        };
    }

    const InlineCompResult = struct {
        exit_block: u32,
        stack: []const StackValue,
    };

    const InlinePend = struct {
        block: u32,
        expr: *Expr,
    };

    fn tryDecompileInlineListComp(
        self: *Decompiler,
        pattern: ctrl.ForPattern,
    ) DecompileError!?InlineCompResult {
        const setup = &self.cfg.blocks[pattern.setup_block];
        const header = &self.cfg.blocks[pattern.header_block];
        var comp_start: ?u32 = null;
        var after_build = false;

        // Helper to check if opcode is a BUILD_* for comprehensions
        const isBuildComp = struct {
            fn check(op: Opcode, arg: u32) bool {
                return arg == 0 and (op == .BUILD_LIST or op == .BUILD_SET or op == .BUILD_MAP);
            }
        }.check;

        // Check setup block first (Python <3.12 pattern: BUILD_* before GET_ITER)
        for (setup.instructions) |inst| {
            if (isBuildComp(inst.opcode, inst.arg)) {
                comp_start = inst.offset;
                after_build = true;
                continue;
            }
            if (inst.opcode == .GET_ITER) break;
            if (after_build) {
                switch (inst.opcode) {
                    .STORE_NAME,
                    .STORE_GLOBAL,
                    .STORE_FAST,
                    .STORE_DEREF,
                    .POP_TOP,
                    => {
                        comp_start = null;
                        after_build = false;
                    },
                    else => {},
                }
            }
        }

        // Python 3.12+: BUILD_* is AFTER GET_ITER in setup block (before FOR_ITER)
        if (comp_start == null) {
            var past_get_iter = false;
            for (setup.instructions) |inst| {
                if (inst.opcode == .GET_ITER) {
                    past_get_iter = true;
                    continue;
                }
                if (!past_get_iter) continue;
                if (isBuildComp(inst.opcode, inst.arg)) {
                    comp_start = inst.offset;
                    break;
                }
            }
        }

        // Fallback: check header block for BUILD_* before FOR_ITER
        if (comp_start == null) {
            for (header.instructions) |inst| {
                if (isBuildComp(inst.opcode, inst.arg)) {
                    comp_start = inst.offset;
                    break;
                }
                if (inst.opcode == .FOR_ITER) break;
            }
        }

        // Python 3.14: BUILD_LIST may be in an intermediate block between setup and header
        // Check direct predecessors of header block that are not the setup block
        if (comp_start == null) {
            for (header.predecessors) |pred_id| {
                if (pred_id == pattern.setup_block) continue;
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                // Skip loop_back edges
                var is_loop_back = false;
                for (pred.successors) |edge| {
                    if (edge.target == pattern.header_block and edge.edge_type == .loop_back) {
                        is_loop_back = true;
                        break;
                    }
                }
                if (is_loop_back) continue;

                for (pred.instructions) |inst| {
                    if (isBuildComp(inst.opcode, inst.arg)) {
                        comp_start = inst.offset;
                        break;
                    }
                }
                if (comp_start != null) break;
            }
        }

        const start = comp_start orelse return null;

        const term = header.terminator() orelse return null;
        if (term.opcode != .FOR_ITER) return null;
        const exit_offset = term.jumpTarget(self.version) orelse return null;
        if (exit_offset <= start) return null;
        if (!try self.loopHasCompAdd(pattern)) return null;

        // Find GET_ITER position
        var get_iter_offset: ?u32 = null;
        for (setup.instructions) |inst| {
            if (inst.opcode == .GET_ITER) {
                get_iter_offset = inst.offset;
                break;
            }
        }

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();

        // Determine simulation start point based on pattern type
        var sim_start = start;

        // Python <3.12: BUILD_LIST comes before GET_ITER, simulate from BUILD_LIST
        // Python 3.12+: BUILD_LIST comes after GET_ITER, need to set up iterator first
        if (get_iter_offset) |gio| {
            if (start < gio) {
                // Python <3.12: BUILD_LIST before GET_ITER
                // Simulate from BUILD_LIST (start)
                sim_start = start;
            } else {
                // Python 3.12+: BUILD_LIST after GET_ITER
                // Simulate setup code to get iterator expression, then start from GET_ITER
                var setup_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                defer setup_sim.deinit();

                var setup_iter = decoder.InstructionIterator.init(self.code.code, self.version);
                while (setup_iter.next()) |inst| {
                    if (inst.offset >= gio) break;
                    if (inst.opcode == .RESUME) continue;
                    self.simOpt(&setup_sim, inst) catch |err| switch (err) {
                        error.PatternNoMatch => return null,
                        else => return err,
                    };
                }

                // Get the iterator expression from TOS
                if (setup_sim.stack.pop()) |val| {
                    switch (val) {
                        .expr => |e| try sim.stack.push(.{ .expr = e }),
                        else => {
                            const iter_placeholder = try self.makeName(".iter", .load);
                            try sim.stack.push(.{ .expr = iter_placeholder });
                        },
                    }
                } else {
                    const iter_placeholder = try self.makeName(".iter", .load);
                    try sim.stack.push(.{ .expr = iter_placeholder });
                }
                sim_start = gio;
            }
        }

        var iter = decoder.InstructionIterator.init(self.code.code, self.version);
        while (iter.next()) |inst| {
            if (inst.offset < sim_start) continue;
            if (inst.offset >= exit_offset) break;
            self.simOpt(&sim, inst) catch |err| switch (err) {
                error.PatternNoMatch => return null,
                else => return err,
            };
        }

        const expr = sim.buildInlineCompExpr() catch |err| {
            if (self.isSoftSimErr(err)) return null;
            return err;
        } orelse return null;

        if (self.version.gte(3, 14)) {
            // Python 3.14+ inline comprehensions with LOAD_FAST_AND_CLEAR / POP_ITER
            // Build stack for exit processing:
            // Exit block has: END_FOR, POP_ITER
            // Cleanup block has: SWAP N, STORE_FAST..., STORE_NAME
            // Stack entering exit: [saved_locals..., comp_result, iterator]
            // Nested comprehensions may have multiple saved_locals (one per loop var)
            var saved_count: usize = 0;
            for (sim.stack.items.items) |val| {
                if (val == .saved_local) saved_count += 1;
            }
            const stack_len: usize = 2 + saved_count;
            const clean_stack = try self.arena.allocator().alloc(StackValue, stack_len);
            var idx: usize = 0;
            // Add all saved_locals in order
            for (sim.stack.items.items) |val| {
                if (val == .saved_local) {
                    clean_stack[idx] = val;
                    idx += 1;
                }
            }
            clean_stack[idx] = .{ .expr = expr };
            idx += 1;
            clean_stack[idx] = .unknown; // iterator placeholder for POP_ITER

            const stack_copy = try self.cloneStackValues(clean_stack);
            return .{ .exit_block = pattern.exit_block, .stack = stack_copy };
        } else {
            // Pre-3.14: stash inline comp expr for exit block cleanup handling
            try self.inline_pend.append(self.allocator, .{
                .block = pattern.exit_block,
                .expr = expr,
            });

            const stack_copy = try self.cloneStackValues(sim.stack.items.items);
            return .{ .exit_block = pattern.exit_block, .stack = stack_copy };
        }
    }

    /// Try to decompile a try pattern as an inline comprehension.
    /// Python 3.12+ comprehensions have exception cleanup code that looks like try/except.
    fn tryDecompileTryAsComprehension(
        self: *Decompiler,
        pattern: ctrl.TryPattern,
        stmts: *std.ArrayListUnmanaged(*Stmt),
    ) DecompileError!?u32 {
        if (!self.version.gte(3, 12)) return null;
        if (pattern.handlers.len == 0) return null;

        // Check if try block has LOAD_FAST_AND_CLEAR (inline comprehension marker)
        const try_block = &self.cfg.blocks[pattern.try_block];
        var has_load_fast_and_clear = false;
        for (try_block.instructions) |inst| {
            if (inst.opcode == .LOAD_FAST_AND_CLEAR) {
                has_load_fast_and_clear = true;
                break;
            }
        }


        const handler_id = pattern.handlers[0].handler_block;
        if (handler_id >= self.cfg.blocks.len) return null;
        const handler = &self.cfg.blocks[handler_id];

        // Check if this is comprehension cleanup: SWAP, POP_TOP, SWAP, STORE_FAST, RERAISE
        var has_reraise = false;
        for (handler.instructions) |inst| {
            if (inst.opcode == .RERAISE) {
                has_reraise = true;
                break;
            }
        }
        if (!has_reraise) return null;

        // Look for FOR_ITER in try body that has LIST_APPEND/SET_ADD/MAP_ADD
        const try_id = pattern.try_block;
        var for_block_id: ?u32 = null;
        var exit_block_id: ?u32 = null;

        var bid = try_id;
        var body_block_id: ?u32 = null;
        while (bid < handler_id) : (bid += 1) {
            const block = &self.cfg.blocks[bid];
            const term = block.terminator() orelse continue;
            if (term.opcode == .FOR_ITER) {
                // Get body and exit from successors
                var body_id_opt: ?u32 = null;
                var exit_id_opt: ?u32 = null;
                for (block.successors) |edge| {
                    if (edge.edge_type == .normal) {
                        body_id_opt = edge.target;
                    } else if (edge.edge_type == .conditional_false) {
                        exit_id_opt = edge.target;
                    }
                }
                const body_id = body_id_opt orelse continue;
                const exit_id = exit_id_opt orelse continue;

                // Check if body has LIST_APPEND/SET_ADD/MAP_ADD
                if (body_id < self.cfg.blocks.len) {
                    const body = &self.cfg.blocks[body_id];
                    for (body.instructions) |inst| {
                        if (inst.opcode == .LIST_APPEND or
                            inst.opcode == .SET_ADD or
                            inst.opcode == .MAP_ADD)
                        {
                            for_block_id = bid;
                            body_block_id = body_id;
                            exit_block_id = exit_id;
                            break;
                        }
                    }
                }
            }
            if (for_block_id != null) break;
        }

        if (for_block_id == null) return null;

        const for_pattern = ctrl.ForPattern{
            .setup_block = try_id,
            .header_block = for_block_id.?,
            .body_block = body_block_id.?,
            .else_block = null,
            .exit_block = exit_block_id.?,
        };

        // Decompile blocks before the for loop
        if (for_block_id.? > try_id) {
            const pre_stmts = try self.decompileBlockRangeWithStack(try_id, for_block_id.?, &.{});
            defer self.allocator.free(pre_stmts);
            try stmts.appendSlice(self.allocator, pre_stmts);
        }

        // Try to decompile as inline comprehension
        if (try self.tryDecompileInlineListComp(for_pattern)) |result| {
            // Comprehension is now in inline_pend for the exit block
            // Process the exit block to pick it up
            defer self.deinitStackValues(result.stack);
            const exit_id = exit_block_id.?;
            if (exit_id < self.cfg.blocks.len) {
                const exit_stmts = try self.decompileBlockRangeWithStack(exit_id, handler_id, result.stack);
                defer self.allocator.free(exit_stmts);
                try stmts.appendSlice(self.allocator, exit_stmts);
            }
            self.allocator.free(pattern.handlers);
            return handler_id + 1;
        }

        return null;
    }

    /// Find the last block that's part of an if-elif-else chain.
    fn findIfChainEnd(self: *Decompiler, pattern: ctrl.IfPattern) DecompileError!u32 {
        if (self.innermostLoopHeader(pattern.condition_block)) |loop_header| {
            const then_res = self.resolveJumpOnlyBlock(pattern.then_block);
            const then_leads = then_res == loop_header or self.blockLeadsToHeader(pattern.then_block, loop_header);
            var else_leads = false;
            if (pattern.else_block) |else_id| {
                const else_res = self.resolveJumpOnlyBlock(else_id);
                else_leads = else_res == loop_header or self.blockLeadsToHeader(else_id, loop_header);
            }
            if (then_leads and else_leads) {
                const limit: u32 = @intCast(self.cfg.blocks.len);
                var end = pattern.condition_block + 1;
                if (pattern.then_block > pattern.condition_block) {
                    end = @max(end, try self.branchEnd(pattern.then_block, null));
                }
                if (pattern.else_block) |else_id| {
                    if (else_id > pattern.condition_block) {
                        end = @max(end, try self.branchEnd(else_id, null));
                    }
                }
                return if (end > limit) limit else end;
            }
        }
        if (pattern.merge_block) |merge| {
            const limit_ok = if (self.br_limit) |lim| merge < lim else true;
            if (limit_ok and merge > pattern.condition_block) {
                var use_merge = true;
                if (pattern.else_block) |else_id| {
                    if (else_id < self.cfg.blocks.len and merge < self.cfg.blocks.len) {
                        const else_reaches = try self.reachesBlock(else_id, merge, pattern.condition_block);
                        if (!else_reaches) {
                            if (merge != pattern.then_block and merge != else_id) {
                                use_merge = false;
                            }
                        } else if (merge == pattern.then_block) {
                            var other: ?u32 = null;
                            var multi = false;
                            const else_blk = &self.cfg.blocks[else_id];
                            for (else_blk.successors) |edge| {
                                if (edge.edge_type == .exception) continue;
                                if (edge.target == merge) continue;
                                if (other != null) {
                                    multi = true;
                                    break;
                                }
                                other = edge.target;
                            }
                            if (!multi and other != null) {
                                if (!self.isTerminalBlock(other.?)) {
                                    const reaches = try self.reachesBlock(other.?, merge, pattern.condition_block);
                                    if (!reaches) {
                                        use_merge = false;
                                    }
                                }
                            }
                        }
                    }
                }
                if (use_merge and merge == pattern.else_block) {
                    if (pattern.then_block < self.cfg.blocks.len and merge < self.cfg.blocks.len) {
                        if (try self.reachesBlock(pattern.then_block, merge, pattern.condition_block)) {
                            var other: ?u32 = null;
                            var multi = false;
                            const then_blk = &self.cfg.blocks[pattern.then_block];
                            for (then_blk.successors) |edge| {
                                if (edge.edge_type == .exception) continue;
                                if (edge.target == merge) continue;
                                if (other != null) {
                                    multi = true;
                                    break;
                                }
                                other = edge.target;
                            }
                            if (!multi and other != null) {
                                const reaches = try self.reachesBlock(other.?, merge, pattern.condition_block);
                                if (!reaches) {
                                    use_merge = false;
                                }
                            }
                        }
                    }
                }
                if (use_merge) return merge;
            }
        }

        var end = try self.branchEnd(pattern.then_block, null);
        if (pattern.else_block) |else_id| {
            const else_pattern = try self.analyzer.detectPattern(else_id);
            const else_is_chain = else_pattern == .if_stmt and else_pattern.if_stmt.is_elif;
            if (pattern.is_elif or else_is_chain) {
                const chain_end = if (else_pattern == .if_stmt)
                    try self.findIfChainEnd(else_pattern.if_stmt)
                else
                    try self.branchEnd(else_id, null);
                if (else_is_chain and chain_end > pattern.condition_block) {
                    const then_reaches = try self.reachesBlock(pattern.then_block, chain_end, pattern.condition_block);
                    const else_reaches = try self.reachesBlock(else_id, chain_end, pattern.condition_block);
                    if (then_reaches and else_reaches) return chain_end;
                }
                end = @max(end, chain_end);
            } else {
                end = @max(end, try self.branchEnd(else_id, null));
            }
        }

        return end;
    }

    fn loopIfMergeFromEnd(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        loop_header: u32,
    ) DecompileError!?u32 {
        const else_id = pattern.else_block orelse return null;
        const end = try self.findIfChainEnd(pattern);
        if (end <= pattern.condition_block + 1) return null;
        var idx = pattern.condition_block + 1;
        while (idx < end and idx < self.cfg.blocks.len) : (idx += 1) {
            if (idx == pattern.then_block or idx == else_id) continue;
            if (!self.analyzer.inLoop(idx, loop_header)) continue;
            if (!try self.reachesBlockNoBack(pattern.then_block, idx, pattern.condition_block)) continue;
            if (!try self.reachesBlockNoBack(else_id, idx, pattern.condition_block)) continue;
            return idx;
        }
        return null;
    }

    fn innermostLoopHeader(self: *Decompiler, block_id: u32) ?u32 {
        var best: ?u32 = null;
        var best_off: u32 = 0;
        for (self.cfg.blocks, 0..) |blk, idx| {
            if (!blk.is_loop_header) continue;
            const header: u32 = @intCast(idx);
            if (!self.analyzer.inLoop(block_id, header)) continue;
            const off = blk.start_offset;
            if (best == null or off > best_off) {
                best = header;
                best_off = off;
            }
        }
        return best;
    }

    pub fn needsPredecessorSeed(self: *Decompiler, block: *const BasicBlock) bool {
        const term = block.terminator();
        if (term != null and term.?.opcode == .FOR_LOOP) return true;
        if (block.instructions.len > 0) {
            const first = block.instructions[0].opcode;
            const quick = switch (first) {
                .SEND,
                .YIELD_VALUE,
                .STORE_FAST,
                .STORE_NAME,
                .STORE_GLOBAL,
                .STORE_ATTR,
                .STORE_SUBSCR,
                .POP_TOP,
                .ROT_TWO,
                .ROT_THREE,
                .ROT_FOUR,
                .DUP_TOP,
                .DUP_TOP_TWO,
                .COPY,
                .SWAP,
                .BINARY_OP,
                .COMPARE_OP,
                .CALL,
                .BUILD_TUPLE,
                .BUILD_LIST,
                .BUILD_MAP,
                .BUILD_SET,
                .UNPACK_SEQUENCE,
                .RETURN_VALUE,
                .END_SEND,
                => true,
                else => false,
            };
            if (quick) return true;
        }
        return self.blockNeedsPredecessorSeed(block);
    }

    fn stackAllUnknown(self: *Decompiler, stack: *const stack_mod.Stack) bool {
        _ = self;
        if (stack.items.items.len == 0) return true;
        for (stack.items.items) |val| {
            if (val != .unknown) return false;
        }
        return true;
    }

    fn blockNeedsPredecessorSeed(self: *Decompiler, block: *const BasicBlock) bool {
        if (block.instructions.len == 0) return false;
        const seed_arena = self.seed_arena;
        _ = seed_arena.reset(.retain_capacity);

        var sim = self.initSim(seed_arena.allocator(), seed_arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.flow_mode = true;
        sim.stack.allow_underflow = false;

        for (block.instructions) |inst| {
            if (inst.opcode == .NOT_TAKEN) continue;
            sim.simulate(inst) catch |err| {
                return err == error.StackUnderflow or err == error.InvalidStackDepth;
            };
        }
        return false;
    }

    pub fn seedFromPredecessors(self: *Decompiler, block_id: u32, sim: *SimContext) DecompileError!void {
        const prev_lenient = sim.lenient;
        const prev_underflow = sim.stack.allow_underflow;
        defer {
            sim.lenient = prev_lenient;
            sim.stack.allow_underflow = prev_underflow;
        }
        sim.lenient = true;
        sim.stack.allow_underflow = true;

        const PredStep = struct { pred: u32, edge: cfg_mod.Edge };
        var chain: std.ArrayListUnmanaged(PredStep) = .{};
        defer chain.deinit(self.allocator);

        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer seen.deinit();

        // Walk a unique non-exception predecessor chain.
        var cur_id = block_id;
        var seed_block = block_id;
        while (cur_id < self.cfg.blocks.len) {
            if (seen.isSet(cur_id)) return error.InvalidStackDepth;
            seen.set(cur_id);

            const cur_block = &self.cfg.blocks[cur_id];
            var found: ?PredStep = null;
            var multiple = false;
            pred_scan: for (cur_block.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                for (pred.successors) |edge| {
                    if (edge.target != cur_id) continue;
                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                    if (found != null) {
                        multiple = true;
                        break :pred_scan;
                    }
                    found = .{ .pred = pred_id, .edge = edge };
                }
            }

            if (multiple) {
                seed_block = cur_id;
                break;
            }
            if (found) |step| {
                try chain.append(self.allocator, step);
                cur_id = step.pred;
                continue;
            }
            seed_block = cur_id;
            break;
        }

        if (chain.items.len == 0) {
            if (seed_block < self.stack_in.len) {
                if (self.stack_in[seed_block]) |entry| {
                    for (entry) |val| {
                        const cloned = try sim.cloneStackValue(val);
                        try sim.stack.push(cloned);
                    }
                }
            }
            return;
        }

        // Seed with known entry stack for the oldest predecessor.
        if (seed_block < self.stack_in.len) {
            if (self.stack_in[seed_block]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }

        // Simulate from oldest predecessor to newest, applying edge-specific stack adjustments.
        var i = chain.items.len;
        while (i > 0) {
            i -= 1;
            const step = chain.items[i];
            const pred = &self.cfg.blocks[step.pred];
            for (pred.instructions) |inst| {
                if (inst.opcode == .NOT_TAKEN) continue;
                if (inst.isUnconditionalJump()) break;
                try sim.simulate(inst);
                if (inst.isConditionalJump()) break;
            }
            if (pred.terminator()) |term| switch (term.opcode) {
                .FOR_ITER => {
                    if (step.edge.edge_type == .conditional_false and !self.version.gte(3, 12)) {
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                    }
                },
                .JUMP_IF_TRUE_OR_POP => {
                    if (step.edge.edge_type == .conditional_false) {
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                    }
                },
                .JUMP_IF_FALSE_OR_POP => {
                    if (step.edge.edge_type == .conditional_true) {
                        _ = sim.stack.pop() orelse return error.StackUnderflow;
                    }
                },
                else => {},
            };
        }
    }

    /// Decompile the code object into a list of statements.
    pub fn decompile(self: *Decompiler) DecompileError![]const *Stmt {
        if (self.cfg.blocks.len == 0) {
            try self.insertModuleGlobals();
            return self.statements.items;
        }

        // Process blocks in order, using control flow patterns
        var block_idx: u32 = 0;
        while (block_idx < self.cfg.blocks.len) {
            const prev_idx = block_idx;
            if (self.consumed.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            // Try BoolOp pattern first (x and y, x or y)
            if (!hasTrySetup(&self.cfg.blocks[block_idx])) {
                if (try self.tryDecompileBoolOpInto(
                    block_idx,
                    @intCast(self.cfg.blocks.len),
                    &self.statements,
                    self.allocator,
                )) |next_block| {
                    block_idx = next_block;
                    if (block_idx <= prev_idx) {
                        if (self.last_error_ctx == null) {
                            self.last_error_ctx = .{
                                .code_name = self.code.name,
                                .block_id = prev_idx,
                                .offset = self.cfg.blocks[prev_idx].start_offset,
                                .opcode = "boolop_no_progress",
                            };
                        }
                        return error.InvalidBlock;
                    }
                    continue;
                }
            }
            if (try self.tryDecompileTernaryInto(
                block_idx,
                @intCast(self.cfg.blocks.len),
                &self.statements,
                self.allocator,
            )) |next_block| {
                block_idx = next_block;
                if (block_idx <= prev_idx) {
                    if (self.last_error_ctx == null) {
                        self.last_error_ctx = .{
                            .code_name = self.code.name,
                            .block_id = prev_idx,
                            .offset = self.cfg.blocks[prev_idx].start_offset,
                            .opcode = "ternary_no_progress",
                        };
                    }
                    return error.InvalidBlock;
                }
                continue;
            }
            if (try self.tryDecompileAndOrInto(
                block_idx,
                @intCast(self.cfg.blocks.len),
                &self.statements,
                self.allocator,
            )) |next_block| {
                block_idx = next_block;
                if (block_idx <= prev_idx) {
                    if (self.last_error_ctx == null) {
                        self.last_error_ctx = .{
                            .code_name = self.code.name,
                            .block_id = prev_idx,
                            .offset = self.cfg.blocks[prev_idx].start_offset,
                            .opcode = "and_or_no_progress",
                        };
                    }
                    return error.InvalidBlock;
                }
                continue;
            }
            const pattern = try self.analyzer.detectPattern(block_idx);

            switch (pattern) {
                .if_stmt => |p| {
                    var skip_first_store = false;
                    try self.processPartialBlock(&self.cfg.blocks[p.condition_block], &self.statements, self.allocator, &skip_first_store, null);
                    const stmt = try self.decompileIf(p);
                    if (stmt) |s| {
                        try self.statements.append(self.allocator, s);
                        try self.appendIfTail(&self.statements, self.allocator);
                    }
                    // Skip all processed blocks - use chained comparison override if set
                    var if_next = self.if_next;
                    if (if_next != null and if_next.? <= p.condition_block) {
                        self.if_next = null;
                        if_next = null;
                    }
                    if (if_next) |next| {
                        if (next < self.cfg.blocks.len) {
                            self.consumed.unset(next);
                        }
                        block_idx = next;
                        self.if_next = null;
                        self.chained_cmp_next_block = null;
                    } else if (self.chained_cmp_next_block) |chain_next| {
                        block_idx = chain_next;
                        self.chained_cmp_next_block = null;
                    } else {
                        block_idx = try self.findIfChainEnd(p);
                    }
                },
                .while_loop => |p| {
                    const stmt = try self.decompileWhile(p);
                    if (stmt) |s| {
                        try self.statements.append(self.allocator, s);
                    }
                    if (self.loop_next) |next| {
                        block_idx = next;
                        self.loop_next = null;
                    } else {
                        const header = &self.cfg.blocks[p.header_block];
                        const term = header.terminator();
                        const legacy_cond = if (term) |t| t.opcode == .JUMP_IF_FALSE or t.opcode == .JUMP_IF_TRUE else false;
                        const exit_block = &self.cfg.blocks[p.exit_block];
                        if (legacy_cond and exit_block.instructions.len > 0 and exit_block.instructions[0].opcode == .POP_TOP) {
                            const exit_stmts = try self.decompileBlockRangeWithStackAndSkip(
                                p.exit_block,
                                p.exit_block + 1,
                                &.{},
                                1,
                            );
                            defer self.arena.allocator().free(exit_stmts);
                            try self.statements.appendSlice(self.allocator, exit_stmts);
                            block_idx = p.exit_block + 1;
                        } else {
                            block_idx = p.exit_block;
                        }
                    }
                },
                .for_loop => |p| {
                    if (try self.tryDecompileInlineListComp(p)) |result| {
                        // Python 3.14+ inline comprehensions need special stack handling
                        // because of LOAD_FAST_AND_CLEAR / POP_ITER cleanup
                        if (self.version.gte(3, 14)) {
                            // Set stack_in for exit block so subsequent processing uses it
                            if (result.exit_block < self.stack_in.len) {
                                // Free old entry if any
                                if (self.stack_in[result.exit_block]) |old| {
                                    if (old.len > 0) self.allocator.free(old);
                                }
                                try self.clearPhiForBlock(result.exit_block);
                                self.stack_in[result.exit_block] = @constCast(result.stack);

                                // Also set stack for successor block (after POP_ITER consumes iterator)
                                // Exit block has END_FOR + POP_ITER, which consumes one stack value
                                const exit_blk = &self.cfg.blocks[result.exit_block];
                                for (exit_blk.successors) |edge| {
                                    if (edge.edge_type == .exception) continue;
                                    const succ = edge.target;
                                    if (succ >= self.stack_in.len) continue;
                                    // Stack after POP_ITER: one less element
                                    if (result.stack.len >= 1) {
                                        const succ_stack = try self.allocator.alloc(StackValue, result.stack.len - 1);
                                        for (result.stack[0 .. result.stack.len - 1], 0..) |val, i| {
                                            succ_stack[i] = val;
                                        }
                                        if (self.stack_in[succ]) |old| {
                                            if (old.len > 0) self.allocator.free(old);
                                        }
                                        try self.clearPhiForBlock(succ);
                                        self.stack_in[succ] = succ_stack;
                                    }
                                }
                            } else {
                                self.deinitStackValues(result.stack);
                            }
                            // Mark comprehension blocks as consumed
                            try self.consumed.set(self.allocator, p.setup_block);
                            try self.consumed.set(self.allocator, p.header_block);
                            try self.consumed.set(self.allocator, p.body_block);
                            // Continue from exit block - normal processing will use stack_in
                            block_idx = result.exit_block;
                            continue;
                        } else {
                            // Pre-3.14: comprehension expr is stashed in inline_pend
                            // Just free the stack and continue from exit block
                            self.deinitStackValues(result.stack);
                            block_idx = result.exit_block;
                            continue;
                        }
                    }
                    try self.emitForPrelude(p, &self.statements, self.allocator);
                    const stmt = try self.decompileFor(p);
                    if (stmt) |s| {
                        try self.statements.append(self.allocator, s);
                    }
                    if (self.analyzer.loopSet(p.header_block)) |body| {
                        var it = body.iterator(.{});
                        while (it.next()) |idx| {
                            const bid: u32 = @intCast(idx);
                            if (bid >= self.cfg.blocks.len) continue;
                            try self.consumed.set(self.allocator, bid);
                        }
                    }
                    block_idx = if (p.exit_block > prev_idx) p.exit_block else prev_idx + 1;
                },
                .try_stmt => |p| {
                    // Check for inline comprehension before try/except
                    if (try self.tryDecompileTryAsComprehension(p, &self.statements)) |next_block| {
                        block_idx = next_block;
                        continue;
                    }
                    if (try self.tryDecompileAsyncFor(p)) |result| {
                        if (result.stmt) |s| {
                            try self.statements.append(self.allocator, s);
                        }
                        block_idx = result.next_block;
                        continue;
                    }
                    const result = try self.decompileTry(p);
                    if (result.stmt) |s| {
                        try self.statements.append(self.allocator, s);
                    }
                    block_idx = result.next_block;
                },
                .with_stmt => |p| {
                    const result = try self.decompileWith(p);
                    if (result.stmt) |s| {
                        try self.statements.append(self.allocator, s);
                    }
                    block_idx = result.next_block;
                },
                .match_stmt => |p| {
                    try self.emitMatchPrelude(p.subject_block, &self.statements, self.allocator);
                    const result = try self.decompileMatch(p);
                    if (result.stmt) |s| {
                        try self.statements.append(self.allocator, s);
                    }
                    block_idx = result.next_block;
                },
                else => {
                    const block = &self.cfg.blocks[block_idx];
                    if (block.is_loop_header) {
                        if (try self.decompileLoopHeader(block_idx)) |result| {
                            if (result.stmt) |s| {
                                try self.statements.append(self.allocator, s);
                            }
                            block_idx = result.next_block;
                        }
                    }
                    // Skip exception handler blocks - they're decompiled as part of try/except
                    if (block.is_exception_handler or self.hasExceptionHandlerOpcodes(block)) {
                        block_idx += 1;
                        continue;
                    }
                    // Skip exception table infrastructure blocks
                    const term = block.terminator();
                    if (term != null and term.?.opcode == .POP_JUMP_FORWARD_IF_NOT_NONE) {
                        block_idx += 1;
                        continue;
                    }
                    if (try self.shouldDeferForPrelude(block_idx, @intCast(self.cfg.blocks.len))) {
                        block_idx += 1;
                        continue;
                    }
                    // Process block as sequential statements
                    try self.decompileBlock(block_idx);
                    block_idx += 1;
                },
            }
            if (block_idx <= prev_idx) {
                if (self.last_error_ctx == null) {
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = prev_idx,
                        .offset = self.cfg.blocks[prev_idx].start_offset,
                        .opcode = "decompile_no_progress",
                    };
                }
                return error.InvalidBlock;
            }
        }

        try self.insertModuleGlobals();
        return self.statements.items;
    }

    fn insertModuleGlobals(self: *Decompiler) DecompileError!void {
        _ = self;
    }

    /// Decompile a single basic block into statements.
    fn decompileBlock(self: *Decompiler, block_id: u32) DecompileError!void {
        if (block_id >= self.cfg.blocks.len) return;
        const block = &self.cfg.blocks[block_id];

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        if (self.hasExceptionSuccessor(block) or self.hasWithExitCleanup(block)) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        const exc_count = self.exceptionSeedCount(block_id, block);
        if (exc_count > 0) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }
        const seed = if (block_id < self.stack_in.len) blk: {
            if (self.stack_in[block_id]) |entry| break :blk entry;
            break :blk &.{};
        } else &.{};

        var seed_has_exc = false;
        if (exc_count > 0 and seed.len >= exc_count) {
            seed_has_exc = true;
            var i: usize = 0;
            while (i < exc_count) : (i += 1) {
                if (!self.isExcPlaceholderValue(seed[i])) {
                    seed_has_exc = false;
                    break;
                }
            }
        }
        if (exc_count > 0 and !seed_has_exc) {
            for (0..exc_count) |_| {
                const placeholder = try self.arena.allocator().create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                try sim.stack.push(.{ .expr = placeholder });
            }
        }
        if (seed.len > 0) {
            for (seed) |val| {
                const cloned = try sim.cloneStackValue(val);
                try sim.stack.push(cloned);
            }
        }

        // Inherit stack from fall-through predecessor if needed
        const needs_predecessor = self.needsPredecessorSeed(block);

        if (exc_count == 0 and seed.len == 0 and needs_predecessor) {
            try self.seedFromPredecessors(block_id, &sim);
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        try self.processBlockWithSim(block, &sim, &self.statements, self.allocator);
    }

    /// Decompile a range of blocks into a statement list.
    /// Returns statements from start_block up to (but not including) end_block.
    fn decompileBlockRange(self: *Decompiler, start_block: u32, end_block: ?u32) DecompileError![]const *Stmt {
        return self.decompileBlockRangeWithStack(start_block, end_block, &.{});
    }

    /// Decompile a range of blocks with initial stack values.
    fn decompileBlockRangeWithStack(
        self: *Decompiler,
        start_block: u32,
        end_block: ?u32,
        init_stack: []const StackValue,
    ) DecompileError![]const *Stmt {
        return self.decompileBlockRangeWithStackAndSkip(start_block, end_block, init_stack, 0);
    }

    /// Decompile a range of blocks, skipping first N instructions of the first block.
    fn decompileBlockRangeWithStackAndSkip(
        self: *Decompiler,
        start_block: u32,
        end_block: ?u32,
        init_stack: []const StackValue,
        skip_first: usize,
    ) DecompileError![]const *Stmt {
        const limit = end_block orelse @as(u32, @intCast(self.cfg.blocks.len));
        if (start_block >= limit) return &[_]*Stmt{};

        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        const defer_prelude = skip_first == 0 and init_stack.len == 0 and
            try self.shouldDeferForPrelude(start_block, limit);
        if (defer_prelude) {
            const rest = try self.decompileStructuredRange(start_block, limit);
            try stmts.appendSlice(a, rest);
        } else {
            try self.decompileBlockIntoWithStackAndSkip(start_block, &stmts, a, init_stack, skip_first);
            if (start_block + 1 < limit) {
                const rest = try self.decompileStructuredRange(start_block + 1, limit);
                try stmts.appendSlice(a, rest);
            }
        }

        if (stmts.items.len >= 2) {
            var i: usize = 0;
            while (i + 1 < stmts.items.len) : (i += 1) {
                const cur = stmts.items[i];
                const next = stmts.items[i + 1];
                if (cur.* == .try_stmt and next.* == .expr_stmt) {
                    const t = &cur.try_stmt;
                    if (t.body.len > 0) {
                        const last = t.body[t.body.len - 1];
                        if (last.* == .if_stmt) {
                            var ifs = &last.if_stmt;
                            if (ifs.else_body.len > 0) {
                                const else_last = ifs.else_body[ifs.else_body.len - 1];
                                if (else_last.* == .expr_stmt) {
                                    if (ast.exprEqual(else_last.expr_stmt.value, next.expr_stmt.value)) {
                                        ifs.else_body = ifs.else_body[0 .. ifs.else_body.len - 1];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        const merged_break = try self.mergeBreakGuards(stmts.items);
        const merged = try self.mergeContGuards(merged_break);
        return try self.rewriteContRaise(merged);
    }

    /// Decompile a single block's statements into the provided list.
    fn decompileBlockInto(self: *Decompiler, block_id: u32, stmts: *std.ArrayListUnmanaged(*Stmt), stmts_allocator: Allocator) DecompileError!void {
        return self.decompileBlockIntoWithStack(block_id, stmts, stmts_allocator, &.{});
    }

    /// Decompile a single block with initial stack values.
    fn decompileBlockIntoWithStack(
        self: *Decompiler,
        block_id: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        init_stack: []const StackValue,
    ) DecompileError!void {
        return self.decompileBlockIntoWithStackAndSkip(block_id, stmts, stmts_allocator, init_stack, 0);
    }

    /// Decompile a single block, optionally skipping first N instructions.
    fn decompileBlockIntoWithStackAndSkip(
        self: *Decompiler,
        block_id: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        init_stack: []const StackValue,
        skip_first: usize,
    ) DecompileError!void {
        if (block_id >= self.cfg.blocks.len) return;
        const block = &self.cfg.blocks[block_id];
        const base_len = stmts.items.len;

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        if (self.hasExceptionSuccessor(block) or self.hasWithExitCleanup(block)) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        const seed = if (init_stack.len > 0)
            init_stack
        else blk: {
            if (block_id < self.stack_in.len) {
                if (self.stack_in[block_id]) |entry| break :blk entry;
            }
            break :blk &.{};
        };

        const exc_count = self.exceptionSeedCount(block_id, block);
        if (exc_count > 0) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }
        var seed_all_unknown = true;
        if (seed.len > 0) {
            for (seed) |val| {
                if (val != .unknown) {
                    seed_all_unknown = false;
                    break;
                }
            }
        }
        var seed_has_exc = false;
        if (exc_count > 0 and seed.len >= exc_count) {
            seed_has_exc = true;
            var i: usize = 0;
            while (i < exc_count) : (i += 1) {
                if (!self.isExcPlaceholderValue(seed[i])) {
                    seed_has_exc = false;
                    break;
                }
            }
        }
        if (exc_count > 0 and !seed_has_exc) {
            for (0..exc_count) |_| {
                const placeholder = try self.arena.allocator().create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                try sim.stack.push(.{ .expr = placeholder });
            }
        }
        if (exc_count == 0 and self.needsPredecessorSeed(block) and (seed.len == 0 or seed_all_unknown)) {
            try self.seedFromPredecessors(block_id, &sim);
        } else if (seed.len > 0) {
            sim.stack.allow_underflow = true;
            for (seed) |val| {
                const cloned = try sim.cloneStackValue(val);
                try sim.stack.push(cloned);
            }
        }

        const needs_predecessor = self.needsPredecessorSeed(block);
        if (exc_count == 0 and seed.len == 0 and needs_predecessor) {
            try self.seedFromPredecessors(block_id, &sim);
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        try self.processBlockWithSimAndSkip(block, &sim, stmts, stmts_allocator, skip_first);
        try self.appendPhiAssignmentsForBlockEnd(block, stmts, stmts_allocator, base_len);
    }

    fn appendPhiAssignmentsForBlockEnd(
        self: *Decompiler,
        block: *const BasicBlock,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        base_len: usize,
    ) DecompileError!void {
        if (self.phi_by_block.count() == 0) return;

        var normal_target: ?u32 = null;
        for (block.successors) |edge| {
            switch (edge.edge_type) {
                .exception => continue,
                .conditional_true, .conditional_false, .loop_back => return,
                .normal => {
                    if (normal_target != null) return;
                    normal_target = edge.target;
                },
            }
        }
        const succ = normal_target orelse return;
        if (self.phi_merge_ok) |set| {
            if (set.isSet(@intCast(succ))) return;
        }

        const tail = stmts.items[base_len..];
        if (self.bodyEndsTerminal(tail)) return;
        const assigns = try self.phiAssignmentsForEdge(block.id, succ);
        if (assigns.len == 0) return;
        try stmts.appendSlice(stmts_allocator, assigns);
    }

    const ChainResult = struct {
        stmt: *Stmt,
        next_block: u32,
    };

    /// Try to decompile a chained comparison (e.g., a < b < c < d).
    /// Returns null if this is not a chained comparison.
    fn tryDecompileChainedComparison(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        first_cmp: *Expr,
        sim: *SimContext,
    ) DecompileError!?ChainResult {
        // Pattern: condition is a Compare, stack has values, then-block does POP_TOP + LOAD + COMPARE
        if (first_cmp.* != .compare) return null;
        if (sim.stack.len() == 0) return null;
        if (pattern.then_block >= self.cfg.blocks.len) return null;

        // Check if then-block starts with POP_TOP (chained comparison pattern)
        const then_block = &self.cfg.blocks[pattern.then_block];
        if (then_block.instructions.len < 3) return null;
        var pop_idx: usize = 0;
        if (then_block.instructions[0].opcode == .NOT_TAKEN) {
            if (then_block.instructions.len < 4) return null;
            pop_idx = 1;
        }
        if (then_block.instructions[pop_idx].opcode != .POP_TOP) return null;

        // Build the chain recursively
        var ops_list: std.ArrayListUnmanaged(ast.CmpOp) = .{};
        var comparators_list: std.ArrayListUnmanaged(*Expr) = .{};

        // Start with the first comparison's data
        try ops_list.append(self.allocator, first_cmp.compare.ops[0]);
        try comparators_list.append(self.allocator, first_cmp.compare.comparators[0]);

        const left = first_cmp.compare.left;
        var current_block_id = pattern.then_block;
        var current_mid = try sim.stack.popExpr();

        // Iterate through the chain
        while (current_block_id < self.cfg.blocks.len) {
            const blk = &self.cfg.blocks[current_block_id];
            if (blk.instructions.len < 3) break;

            // Check for POP_TOP pattern
            var idx: usize = 0;
            if (blk.instructions[0].opcode == .NOT_TAKEN) {
                if (blk.instructions.len < 4) break;
                idx = 1;
            }
            if (blk.instructions[idx].opcode != .POP_TOP) break;

            // Find COMPARE_OP - scan forward from POP_TOP
            var cmp_idx: usize = idx + 1;
            while (cmp_idx < blk.instructions.len) {
                if (blk.instructions[cmp_idx].opcode == .COMPARE_OP) break;
                cmp_idx += 1;
            }
            if (cmp_idx >= blk.instructions.len) break;

            // Determine start of simulation (after POP_TOP)
            const sim_start = idx + 1;

            // Simulate to get the comparison
            var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
            defer then_sim.deinit();
            try then_sim.stack.push(.{ .expr = current_mid });

            // Simulate instructions from after POP_TOP to compare (inclusive)
            for (blk.instructions[sim_start .. cmp_idx + 1]) |inst| {
                try then_sim.simulate(inst);
            }

            const cmp_expr = try then_sim.stack.popExpr();
            if (cmp_expr.* != .compare) {
                cmp_expr.deinit(self.allocator);
                self.allocator.destroy(cmp_expr);
                break;
            }

            // Add to chain
            try ops_list.append(self.allocator, cmp_expr.compare.ops[0]);
            try comparators_list.append(self.allocator, cmp_expr.compare.comparators[0]);

            // Check if there's another link (COPY, TO_BOOL, POP_JUMP after COMPARE)
            if (cmp_idx + 3 < blk.instructions.len and
                blk.instructions[cmp_idx + 1].opcode == .COPY and
                blk.instructions[cmp_idx + 2].opcode == .TO_BOOL and
                ctrl.Analyzer.isConditionalJump(undefined, blk.instructions[cmp_idx + 3].opcode))
            {
                // More chain - get the next middle value from stack
                current_mid = try then_sim.stack.popExpr();
                // Next block is the fallthrough
                var found_next = false;
                for (blk.successors) |edge| {
                    if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                        current_block_id = edge.target;
                        found_next = true;
                        break;
                    }
                }
                if (!found_next) break;
                continue;
            } else {
                // End of chain - check for RETURN_VALUE
                const has_return = cmp_idx + 1 < blk.instructions.len and
                    blk.instructions[cmp_idx + 1].opcode == .RETURN_VALUE;

                const a = self.arena.allocator();
                const ops = try a.dupe(ast.CmpOp, ops_list.items);
                const comparators = try a.dupe(*Expr, comparators_list.items);
                ops_list.deinit(self.allocator);
                comparators_list.deinit(self.allocator);

                const chain_expr = try a.create(Expr);
                chain_expr.* = .{ .compare = .{
                    .left = left,
                    .ops = ops,
                    .comparators = comparators,
                } };

                const stmt = try a.create(Stmt);
                if (has_return) {
                    stmt.* = .{ .return_stmt = .{ .value = chain_expr } };
                } else {
                    stmt.* = .{ .expr_stmt = .{ .value = chain_expr } };
                }
                // Skip to after the short-circuit block (which is else_block or merge_block)
                const short_circuit_block = pattern.else_block orelse pattern.merge_block orelse current_block_id;
                const next_block = @max(current_block_id + 1, short_circuit_block + 1);
                return .{ .stmt = stmt, .next_block = next_block };
            }
        }

        // Cleanup on failure
        ops_list.deinit(self.allocator);
        comparators_list.deinit(self.allocator);
        return null;
    }

    fn tryFoldChainCompare(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        condition: **Expr,
        then_block: *u32,
        else_block: *?u32,
        sim: *SimContext,
        chain_true_jump: *?bool,
    ) DecompileError!bool {
        if (condition.*.* != .compare) return false;
        const cmp = condition.*.compare;
        if (cmp.ops.len != 1 or cmp.comparators.len != 1) return false;
        const else_id = else_block.* orelse return false;
        if (pattern.then_block >= self.cfg.blocks.len or else_id >= self.cfg.blocks.len) return false;
        if (sim.stack.len() == 0) return false;
        const mid_val = sim.stack.items.items[sim.stack.items.items.len - 1];
        if (mid_val != .expr) return false;

        const then_blk = &self.cfg.blocks[pattern.then_block];
        if (condBlockHasPrelude(then_blk)) return false;
        const then_term = then_blk.terminator() orelse return false;
        if (!ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) return false;
        var t_id: ?u32 = null;
        var f_id: ?u32 = null;
        for (then_blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            if (edge.edge_type == .conditional_false) {
                f_id = edge.target;
            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                t_id = edge.target;
            }
        }
        if (t_id == null or f_id == null) return false;

        var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer then_sim.deinit();
        const mid_clone = try sim.cloneStackValue(mid_val);
        try then_sim.stack.push(mid_clone);
        for (then_blk.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            try then_sim.simulate(inst);
        }
        const cmp_expr = if (then_sim.stack.popExpr()) |expr| expr else |err| {
            if (self.isSoftSimErr(err)) return false;
            return err;
        };
        if (cmp_expr.* != .compare) return false;
        if (cmp_expr.compare.ops.len != 1 or cmp_expr.compare.comparators.len != 1) return false;
        if (!ast.exprEqual(mid_val.expr, cmp_expr.compare.left)) return false;

        const a = self.arena.allocator();
        const ops = try a.alloc(ast.CmpOp, 2);
        const comparators = try a.alloc(*Expr, 2);
        ops[0] = cmp.ops[0];
        ops[1] = cmp_expr.compare.ops[0];
        comparators[0] = cmp.comparators[0];
        comparators[1] = cmp_expr.compare.comparators[0];

        const chain_expr = try a.create(Expr);
        chain_expr.* = .{ .compare = .{
            .left = cmp.left,
            .ops = ops,
            .comparators = comparators,
        } };
        condition.* = chain_expr;

        then_block.* = t_id.?;
        else_block.* = f_id.?;
        chain_true_jump.* = self.isTrueJump(then_term.opcode);
        if (pattern.then_block < self.cfg.blocks.len) {
            try self.consumed.set(self.allocator, pattern.then_block);
        }
        if (pattern.else_block) |orig_else| {
            if (orig_else < self.cfg.blocks.len) {
                try self.consumed.set(self.allocator, orig_else);
            }
        }
        return true;
    }

    fn isLoadOpcode(op: Opcode) bool {
        return switch (op) {
            .LOAD_NAME, .LOAD_FAST, .LOAD_FAST_BORROW, .LOAD_GLOBAL, .SWAP, .COPY => true,
            else => false,
        };
    }

    fn appendIfTail(self: *Decompiler, stmts: *std.ArrayListUnmanaged(*Stmt), allocator: Allocator) DecompileError!void {
        if (self.if_tail) |tail| {
            try stmts.appendSlice(allocator, tail);
            self.if_tail = null;
        }
    }

    fn tryDecompileAssertBlock(
        self: *Decompiler,
        cond: *Expr,
        else_block: u32,
        skip: usize,
    ) DecompileError!?*Stmt {
        if (else_block >= self.cfg.blocks.len) return null;

        const resolved_else = self.resolveJumpOnlyBlock(else_block);
        if (resolved_else >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[resolved_else];
        // Pattern: [NOT_TAKEN,] LOAD_COMMON_CONSTANT 0, [LOAD_CONST msg, CALL,] RAISE_VARARGS 1
        var i: usize = skip;
        while (i < block.instructions.len and block.instructions[i].opcode == .NOT_TAKEN) : (i += 1) {}
        if (i >= block.instructions.len) return null;

        // Check for LOAD_COMMON_CONSTANT 0 (AssertionError) or LOAD_ASSERTION_ERROR
        const load_inst = block.instructions[i];
        const is_assertion_error = (load_inst.opcode == .LOAD_COMMON_CONSTANT and load_inst.arg == 0) or
            load_inst.opcode == .LOAD_ASSERTION_ERROR;
        if (!is_assertion_error) return null;

        i += 1;
        if (i >= block.instructions.len) return null;

        var raise_idx: ?usize = null;
        var call_idx: ?usize = null;
        var j = i;
        while (j < block.instructions.len) : (j += 1) {
            const inst = block.instructions[j];
            if (inst.opcode == .RAISE_VARARGS and inst.arg == 1) {
                raise_idx = j;
                break;
            }
            switch (inst.opcode) {
                .CALL,
                .CALL_FUNCTION,
                .CALL_FUNCTION_KW,
                .CALL_FUNCTION_EX,
                .CALL_METHOD,
                => call_idx = j,
                else => {},
            }
        }
        if (raise_idx == null) return null;

        var msg: ?*Expr = null;
        if (call_idx != null) {
            var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
            defer sim.deinit();
            sim.lenient = true;
            sim.stack.allow_underflow = true;
            try sim.stack.push(.unknown);
            for (block.instructions[i..call_idx.?]) |inst| {
                self.simOpt(&sim, inst) catch |err| switch (err) {
                    error.PatternNoMatch => return null,
                    else => return err,
                };
            }
            msg = self.popExprMatch(&sim) catch |err| switch (err) {
                error.PatternNoMatch => null,
                else => return err,
            };
        }

        // Create assert statement
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .{ .assert_stmt = .{
            .condition = cond,
            .msg = msg,
        } };
        if (resolved_else != else_block) {
            try self.consumed.set(self.allocator, else_block);
        }
        try self.consumed.set(self.allocator, resolved_else);
        return stmt;
    }

    fn isRaiseBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const resolved = self.resolveJumpOnlyBlock(block_id);
        if (resolved >= self.cfg.blocks.len) return false;
        const block = &self.cfg.blocks[resolved];
        var saw_raise = false;
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .RAISE_VARARGS, .RERAISE => saw_raise = true,
                .RETURN_VALUE, .RETURN_CONST => return false,
                else => {},
            }
        }
        return saw_raise;
    }

    fn isAssertRaiseBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const resolved = self.resolveJumpOnlyBlock(block_id);
        if (resolved >= self.cfg.blocks.len) return false;
        const block = &self.cfg.blocks[resolved];
        var i: usize = 0;
        while (i < block.instructions.len and block.instructions[i].opcode == .NOT_TAKEN) : (i += 1) {}
        if (i >= block.instructions.len) return false;
        const load_inst = block.instructions[i];
        const is_assertion_error = (load_inst.opcode == .LOAD_COMMON_CONSTANT and load_inst.arg == 0) or
            load_inst.opcode == .LOAD_ASSERTION_ERROR;
        if (!is_assertion_error) return false;
        i += 1;
        if (i >= block.instructions.len) return false;
        for (block.instructions[i..]) |inst| {
            if (inst.opcode == .RAISE_VARARGS and inst.arg == 1) return true;
        }
        return false;
    }

    /// Try to decompile assert pattern: if cond: pass else: raise AssertionError[(...)]
    fn tryDecompileAssert(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        cond: *Expr,
        else_block: u32,
        then_body: []const *Stmt,
        base_vals: []const StackValue,
        skip: usize,
    ) DecompileError!?*Stmt {
        _ = pattern;
        _ = base_vals;
        // Assert has empty then body and else raises AssertionError
        if (then_body.len != 0) return null;
        return self.tryDecompileAssertBlock(cond, else_block, skip);
    }

    fn elifEndsRaise(self: *Decompiler, start_else: u32) DecompileError!bool {
        if (start_else >= self.cfg.blocks.len) return false;
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer seen.deinit();
        var cur = start_else;
        while (cur < self.cfg.blocks.len) {
            if (seen.isSet(cur)) return false;
            seen.set(cur);
            const pat = try self.analyzer.detectPatternNoTry(cur);
            if (pat != .if_stmt) {
                const res = self.resolveJumpOnlyBlock(cur);
                return self.isRaiseBlock(res);
            }
            const p = pat.if_stmt;
            if (p.else_block == null) return false;
            const else_id = p.else_block.?;
            const else_res = self.resolveJumpOnlyBlock(else_id);
            const else_pat = if (else_id < self.cfg.blocks.len) try self.analyzer.detectPatternNoTry(else_id) else return false;
            if (else_pat != .if_stmt) {
                return self.isRaiseBlock(else_res);
            }
            cur = else_id;
        }
        return false;
    }

    const ChainThenInner = struct {
        condition: *Expr,
        then_block: u32,
        else_block: ?u32,
    };

    fn tryChainThenInner(
        self: *Decompiler,
        condition: *Expr,
        then_block: u32,
        else_block: ?u32,
    ) DecompileError!?ChainThenInner {
        if (else_block == null or then_block >= self.cfg.blocks.len) return null;
        var outer_else = self.resolveJumpOnlyBlock(else_block.?);
        const inner_pat = try self.analyzer.detectPatternNoTry(then_block);
        if (inner_pat != .if_stmt) return null;
        const inner = inner_pat.if_stmt;
        var inner_else_opt: ?u32 = inner.else_block;
        if (inner_else_opt == null) {
            if (inner.merge_block) |merge_id| {
                const merge_res = self.resolveJumpOnlyBlock(merge_id);
                if (merge_res == outer_else) {
                    inner_else_opt = merge_id;
                }
            }
        }
        if (inner_else_opt == null) return null;
        const inner_else = self.resolveJumpOnlyBlock(inner_else_opt.?);
        if (inner_else != outer_else) {
            if (try self.condChainFalseTarget(else_block.?, then_block)) |fb| {
                outer_else = self.resolveJumpOnlyBlock(fb);
            }
        }
        if (inner_else != outer_else) return null;
        if (inner.then_block >= self.cfg.blocks.len or self.cfg.blocks[inner.then_block].is_loop_header) return null;
        // Allow merging even when inner then is terminal (guard-style AND chains).

        const then_blk = &self.cfg.blocks[then_block];
        if (condBlockHasPrelude(then_blk)) return null;
        const cond2 = (try self.condExprFromBlockSeeded(then_block, inner.then_block, inner_else_opt)) orelse return null;
        var inner_cond = cond2;
        var inner_then_id = inner.then_block;
        var inner_else_id = inner_else_opt.?;
        if (cond2.* == .compare and cond2.compare.ops.len == 1 and cond2.compare.comparators.len == 1) {
            const mid = cond2.compare.comparators[0];
            const inner_then_pat = try self.analyzer.detectPatternNoTry(inner.then_block);
            if (inner_then_pat == .if_stmt) {
                const inner_then_if = inner_then_pat.if_stmt;
                if (inner_then_if.else_block != null) {
                    var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                    defer then_sim.deinit();
                    then_sim.lenient = true;
                    then_sim.stack.allow_underflow = true;
                    try then_sim.stack.push(.{ .expr = mid });
                    if (try self.condExprFromBlock(inner.then_block, &then_sim, inner_then_if.then_block, inner_then_if.else_block, 0)) |cond3| {
                        if (cond3.* == .compare and cond3.compare.ops.len == 1 and cond3.compare.comparators.len == 1 and
                            ast.exprEqual(mid, cond3.compare.left))
                        {
                            const a = self.arena.allocator();
                            const ops = try a.alloc(ast.CmpOp, 2);
                            const comparators = try a.alloc(*Expr, 2);
                            ops[0] = cond2.compare.ops[0];
                            ops[1] = cond3.compare.ops[0];
                            comparators[0] = cond2.compare.comparators[0];
                            comparators[1] = cond3.compare.comparators[0];
                            const chain_expr = try a.create(Expr);
                            chain_expr.* = .{ .compare = .{
                                .left = cond2.compare.left,
                                .ops = ops,
                                .comparators = comparators,
                            } };
                            inner_cond = chain_expr;
                            inner_then_id = inner_then_if.then_block;
                            inner_else_id = inner_then_if.else_block.?;
                            if (inner.then_block < self.cfg.blocks.len) {
                                try self.consumed.set(self.allocator, inner.then_block);
                            }
                            if (inner.else_block) |orig_else| {
                                if (orig_else < self.cfg.blocks.len) {
                                    try self.consumed.set(self.allocator, orig_else);
                                }
                            }
                        }
                    }
                }
            }
        }
        const combined = try self.makeBoolPair(condition, inner_cond, .and_);
        if (then_block < self.cfg.blocks.len) {
            try self.consumed.set(self.allocator, then_block);
        }
        return .{ .condition = combined, .then_block = inner_then_id, .else_block = inner_else_id };
    }

    /// Decompile an if statement pattern.
    fn decompileIf(self: *Decompiler, pattern: ctrl.IfPattern) DecompileError!?*Stmt {
        return self.decompileIfImpl(pattern, 0, false);
    }

    fn decompileIfWithSkip(self: *Decompiler, pattern: ctrl.IfPattern, skip_cond: usize) DecompileError!?*Stmt {
        return self.decompileIfImpl(pattern, skip_cond, false);
    }

    fn decompileIfInElifChain(self: *Decompiler, pattern: ctrl.IfPattern, skip_cond: usize) DecompileError!?*Stmt {
        return self.decompileIfImpl(pattern, skip_cond, true);
    }

    /// Decompile an if statement pattern, skipping first N instructions of condition block.
    /// If in_elif_chain is true, this is a nested if inside an elif chain - skip guard optimizations.
    fn decompileIfImpl(self: *Decompiler, pattern: ctrl.IfPattern, skip_cond: usize, in_elif_chain: bool) DecompileError!?*Stmt {
        if (self.if_in_progress) |*set| {
            if (set.isSet(pattern.condition_block)) return null;
            set.set(pattern.condition_block);
            defer set.unset(pattern.condition_block);
        }
        const cond_block = &self.cfg.blocks[pattern.condition_block];

        // Get the condition expression from the last instruction before the jump
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();

        if (pattern.condition_block < self.stack_in.len) {
            if (self.stack_in[pattern.condition_block]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }

        // Check if terminator is Python 3.0 style JUMP_IF_FALSE/TRUE
        // These don't pop the condition, so branches start with POP_TOP
        const term = cond_block.terminator();
        const legacy_cond = if (term) |t| t.opcode == .JUMP_IF_FALSE or t.opcode == .JUMP_IF_TRUE else false;

        // Simulate up to but not including the conditional jump, skipping first N instructions
        const insts = cond_block.instructions[skip_cond..];
        var inst_idx: usize = 0;
        while (inst_idx < insts.len) : (inst_idx += 1) {
            const inst = insts[inst_idx];
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;

            // Detect walrus operator: COPY 1 followed by STORE_*
            if (inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST or
                inst.opcode == .STORE_GLOBAL or inst.opcode == .STORE_DEREF)
            {
                if (inst_idx > 0 and insts[inst_idx - 1].opcode == .COPY and insts[inst_idx - 1].arg == 1) {
                    const next_idx = inst_idx + 1;
                    var is_walrus = false;
                    if (next_idx < insts.len) {
                        const next_op = insts[next_idx].opcode;
                        is_walrus = switch (next_op) {
                            .DUP_TOP, .COPY, .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => false,
                            .COMPARE_OP, .CONTAINS_OP, .IS_OP,
                            .TO_BOOL, .POP_JUMP_IF_TRUE, .POP_JUMP_IF_FALSE,
                            .POP_JUMP_IF_NONE, .POP_JUMP_IF_NOT_NONE,
                            .POP_JUMP_FORWARD_IF_TRUE, .POP_JUMP_FORWARD_IF_FALSE,
                            .POP_JUMP_FORWARD_IF_NONE, .POP_JUMP_FORWARD_IF_NOT_NONE,
                            .LOAD_SMALL_INT, .LOAD_CONST, .LOAD_FAST, .LOAD_FAST_BORROW,
                            .LOAD_NAME, .LOAD_GLOBAL, .BINARY_OP,
                            => true,
                            else => false,
                        };
                    }

                    if (is_walrus) {
                        const copied = sim.stack.pop() orelse return error.StackUnderflow;
                        if (copied == .expr) {
                            const expr = copied.expr;
                            const name = switch (inst.opcode) {
                                .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                                .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                                else => "__unknown__",
                            };
                            const arena = self.arena.allocator();
                            const target = try self.makeName(name, .store);
                            const named = try arena.create(Expr);
                            named.* = .{ .named_expr = .{ .target = target, .value = expr } };

                            if (sim.stack.pop()) |orig| {
                                orig.deinit(sim.allocator, sim.stack_alloc);
                            }
                            try sim.stack.push(.{ .expr = named });
                            continue;
                        } else {
                            copied.deinit(sim.allocator, sim.stack_alloc);
                        }
                    }
                }
            }

            try sim.simulate(inst);
        }

        var condition = try sim.stack.popExpr();
        var then_block = pattern.then_block;
        var else_block = pattern.else_block;
        var is_elif = pattern.is_elif;
        var folded_chain = false;
        var chain_true_jump: ?bool = null;
        if (try self.tryFoldChainCompare(pattern, &condition, &then_block, &else_block, &sim, &chain_true_jump)) {
            is_elif = false;
            _ = sim.stack.pop() orelse null;
            folded_chain = true;
        }
        var invert_true_jump = false;
        if (!folded_chain) {
            if (term) |t| {
                if (is_elif and self.isTrueJump(t.opcode)) {
                    if (else_block != null) {
                        const is_not = condition.* == .unary_op and condition.unary_op.op == .not_;
                        if (!is_not) {
                            condition = try self.invertConditionExpr(condition);
                            const tmp = then_block;
                            then_block = else_block.?;
                            else_block = tmp;
                            invert_true_jump = true;
                        }
                    }
                }
            }
        }
        var cond_true_jump: ?bool = null;
        if (folded_chain) {
            cond_true_jump = chain_true_jump;
        } else if (term) |t| {
            cond_true_jump = self.isTrueJump(t.opcode);
        }
        if (invert_true_jump and cond_true_jump != null) {
            cond_true_jump = !cond_true_jump.?;
        }
        var merge_block: ?u32 = pattern.merge_block;
        if (merge_block) |mid| {
            if (mid <= pattern.condition_block) {
                merge_block = try self.findIfChainEnd(pattern);
            } else if (mid == pattern.then_block) {
                var keep = false;
                if (pattern.else_block) |else_id| {
                    if (else_id < self.cfg.blocks.len and mid < self.cfg.blocks.len) {
                        if (try self.reachesBlock(else_id, mid, pattern.condition_block)) {
                            keep = true;
                        }
                    }
                }
                if (!keep) {
                    merge_block = try self.findIfChainEnd(pattern);
                }
            } else if (pattern.else_block != null and mid == pattern.else_block.?) {
                var keep = false;
                if (pattern.then_block < self.cfg.blocks.len and mid < self.cfg.blocks.len) {
                    if (try self.reachesBlock(pattern.then_block, mid, pattern.condition_block)) {
                        keep = true;
                    }
                }
                if (!keep) {
                    merge_block = try self.findIfChainEnd(pattern);
                }
            }
        }
        if (merge_block == null and else_block != null) {
            const else_id = else_block.?;
            if (!try self.reachesBlockNoBack(then_block, else_id, pattern.condition_block)) {
                if (try self.commonMergeNoLoopBack(then_block, else_id, pattern.condition_block)) |mid| {
                    merge_block = mid;
                }
            }
        }
        if (merge_block == null and else_block != null) {
            const else_id = else_block.?;
            const resolved_then = self.resolveJumpOnlyBlock(then_block);
            const resolved_else = self.resolveJumpOnlyBlock(else_id);
            if (resolved_then < self.cfg.blocks.len and
                resolved_else < self.cfg.blocks.len and
                self.isTerminalBlock(resolved_then) and
                !self.isTerminalBlock(resolved_else))
            {
                if (try self.findElseJoin(resolved_else, pattern.condition_block)) |mid| {
                    merge_block = mid;
                }
            }
        }
        if (is_elif and self.loop_depth == 0) {
            if (else_block) |else_id| {
                if (self.isTerminalBlock(then_block) and try self.elifEndsRaise(else_id)) {
                    is_elif = false;
                    else_block = null;
                    if (self.if_next == null) {
                        self.if_next = else_id;
                    }
                }
            }
        }
        if (is_elif and merge_block != null and merge_block.? == then_block) {
            merge_block = null;
        }
        var force_else = blk: {
            if (else_block) |eid| {
                if (self.isTerminalBlock(then_block) and self.isTerminalBlock(eid)) break :blk true;
            }
            break :blk false;
        };
        if (!force_else) {
            if (else_block) |else_id| {
                const else_pat = try self.analyzer.detectPatternNoTry(else_id);
                if (else_pat == .if_stmt and else_pat.if_stmt.is_elif) {
                    force_else = true;
                }
            }
        }
        if (!force_else and is_elif) {
            if (else_block) |eid| {
                if (term) |t| {
                    if (self.isFalseJump(t.opcode) and
                        self.isTerminalBlock(eid) and
                        !self.isTerminalBlock(then_block) and
                        !self.isRaiseBlock(eid) and
                        !self.isAssertRaiseBlock(eid))
                    {
                        force_else = true;
                    }
                }
            }
        }
        if (in_elif_chain) {
            if (else_block) |else_id| {
                if (else_id < self.cfg.blocks.len) {
                    var non_exc: usize = 0;
                    var pred_is_cond = false;
                    for (self.cfg.blocks[else_id].predecessors) |pred_id| {
                        if (pred_id >= self.cfg.blocks.len) continue;
                        var is_exc = false;
                        for (self.cfg.blocks[pred_id].successors) |edge| {
                            if (edge.target != else_id) continue;
                            if (edge.edge_type == .exception) {
                                is_exc = true;
                                break;
                            }
                        }
                        if (is_exc) continue;
                        non_exc += 1;
                        if (pred_id == pattern.condition_block) {
                            pred_is_cond = true;
                        }
                    }
                    if (pred_is_cond and non_exc == 1) {
                        force_else = true;
                    }
                }
            }
        }
        var prefer_false_body = false;
        if (folded_chain) {
            if (else_block) |else_id| {
                const merge = try self.commonMerge(then_block, else_id, pattern.condition_block);
                const a = self.arena.allocator();
                var then_body = try self.decompileBranchRange(then_block, merge, &.{}, 0);
                var else_body = try self.decompileBranchRange(else_id, merge, &.{}, 0);
                const then_is_pass = then_body.len == 1 and then_body[0].* == .pass;
                const else_is_pass = else_body.len == 1 and else_body[0].* == .pass;
                if ((then_body.len == 0 or then_is_pass) and (else_body.len == 0 or else_is_pass)) {
                    const stmt = try a.create(Stmt);
                    stmt.* = .{ .expr_stmt = .{ .value = condition } };
                    self.if_next = merge;
                    return stmt;
                } else {
                    const else_is_if = else_body.len == 1 and else_body[0].* == .if_stmt;
                    if ((then_body.len == 0 or then_is_pass) and else_body.len > 0 and !else_is_if and !else_is_pass) {
                        condition = try self.invertConditionExpr(condition);
                        try self.emitDecisionTrace(pattern.condition_block, "if_invert_empty_then_chain", condition);
                        then_body = else_body;
                        else_body = &[_]*Stmt{};
                    }
                    if (cond_true_jump == true and else_body.len == 1 and else_body[0].* == .raise_stmt and then_body.len > 0 and self.if_tail == null) {
                        condition = try self.invertConditionExpr(condition);
                        try self.emitDecisionTrace(pattern.condition_block, "if_guard_raise_chain", condition);
                        const guard_body = else_body;
                        else_body = &[_]*Stmt{};
                        self.if_tail = then_body;
                        then_body = guard_body;
                    }
                    const stmt = try a.create(Stmt);
                    stmt.* = .{ .if_stmt = .{
                        .condition = condition,
                        .body = then_body,
                        .else_body = else_body,
                    } };
                    self.if_next = merge;
                    return stmt;
                }
            }
        }
        if (!is_elif) {
            if (else_block) |else_id| {
                if (merge_block != null and merge_block.? == then_block and
                    self.isTerminalBlock(then_block) and !self.isTerminalBlock(else_id))
                {
                    const term_true_jump = if (term) |t| self.isTrueJump(t.opcode) else false;
                    const skip_invert = term_true_jump and self.isRaiseBlock(then_block);
                    if (!skip_invert) {
                        if (try self.reachesBlock(else_id, then_block, pattern.condition_block)) {
                            var else_guard_to_then = false;
                            const else_res = self.resolveJumpOnlyBlock(else_id);
                            if (else_res < self.cfg.blocks.len) {
                                const else_blk = &self.cfg.blocks[else_res];
                                if (!condBlockHasPrelude(else_blk)) {
                                    if (else_blk.terminator()) |else_term| {
                                        if (ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) {
                                            var t_id: ?u32 = null;
                                            var f_id: ?u32 = null;
                                            for (else_blk.successors) |edge| {
                                                if (edge.edge_type == .exception) continue;
                                                if (edge.edge_type == .conditional_false) {
                                                    f_id = edge.target;
                                                } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                                    t_id = edge.target;
                                                }
                                            }
                                            if (t_id != null and f_id != null) {
                                                const then_res = self.resolveJumpOnlyBlock(then_block);
                                                if (self.resolveJumpOnlyBlock(t_id.?) == then_res or
                                                    self.resolveJumpOnlyBlock(f_id.?) == then_res)
                                                {
                                                    else_guard_to_then = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (!else_guard_to_then) {
                                prefer_false_body = true;
                                force_else = true;
                            }
                        }
                    }
                }
            }
        }
        var forced_then_end: ?u32 = null;
        var deferred_if_next: ?u32 = null;
        var no_merge = false;
        if (is_elif) {
            if (else_block) |else_id| {
                if (self.analyzer.detectBoolOp(else_id)) |bool_pat| {
                    if (self.isExprOnlyBlock(bool_pat.second_block)) {
                        is_elif = false;
                    }
                }
                if (is_elif and try self.reachesBlock(else_id, then_block, pattern.condition_block) and
                    try self.postDominates(then_block, else_id))
                {
                    condition = try self.invertConditionExpr(condition);
                    try self.emitDecisionTrace(pattern.condition_block, "if_invert_elif_merge", condition);
                    const merge = then_block;
                    then_block = else_id;
                    else_block = null;
                    is_elif = false;
                    self.if_next = merge;
                    forced_then_end = merge;
                }
            }
        }
        if (!is_elif) {
            if (merge_block) |merge_id| {
                if (else_block) |else_id| {
                    const resolved_else = self.resolveJumpOnlyBlock(else_id);
                    if (resolved_else == merge_id and !self.isTerminalBlock(merge_id)) {
                        var keep_else = false;
                        if (then_block < self.cfg.blocks.len) {
                            const then_blk = &self.cfg.blocks[then_block];
                            if (!condBlockHasPrelude(then_blk)) {
                                if (then_blk.terminator()) |then_term| {
                                    if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                        var t_id: ?u32 = null;
                                        var f_id: ?u32 = null;
                                        for (then_blk.successors) |edge| {
                                            if (edge.edge_type == .exception) continue;
                                            if (edge.edge_type == .conditional_false) {
                                                f_id = edge.target;
                                            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                                t_id = edge.target;
                                            }
                                        }
                                        if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(t_id.?) == resolved_else) {
                                            keep_else = true;
                                        }
                                    }
                                }
                            }
                        }
                        if (!keep_else and !force_else) {
                            else_block = null;
                            if (self.if_next == null) {
                                self.if_next = merge_id;
                            }
                            if (resolved_else != else_id) {
                                try self.consumed.set(self.allocator, else_id);
                            }
                        }
                    }
                }
            }
        }
        if (else_block) |else_id| {
            if (self.br_limit) |lim| {
                if (else_id < lim and else_id < self.cfg.blocks.len) {
                    try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
                    self.cond_seen.reset();
                    self.cond_stack.clearRetainingCapacity();
                    try self.cond_stack.ensureTotalCapacity(self.allocator, self.cfg.blocks.len);
                    try self.cond_stack.append(self.allocator, pattern.condition_block);
                    while (self.cond_stack.items.len > 0) {
                        const bid = self.cond_stack.items[self.cond_stack.items.len - 1];
                        self.cond_stack.items.len -= 1;
                        if (bid >= lim or bid >= self.cfg.blocks.len) continue;
                        if (self.cond_seen.isSet(bid)) continue;
                        try self.cond_seen.set(self.allocator, bid);
                        const blk = &self.cfg.blocks[bid];
                        for (blk.successors) |edge| {
                            if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                            if (edge.target >= lim or edge.target >= self.cfg.blocks.len) continue;
                            if (!self.cond_seen.isSet(edge.target)) {
                                try self.cond_stack.append(self.allocator, edge.target);
                            }
                        }
                    }
                    var outside_pred = false;
                    for (self.cfg.blocks[else_id].predecessors) |pred_id| {
                        if (!self.cond_seen.isSet(pred_id)) {
                            outside_pred = true;
                            break;
                        }
                    }
                    if (outside_pred and !force_else) {
                        else_block = null;
                        self.if_next = else_id;
                        if (else_id < self.cfg.blocks.len) {
                            self.consumed.unset(else_id);
                        }
                        if (deferred_if_next == null) {
                            deferred_if_next = else_id;
                        }
                        try self.emitDecisionTrace(pattern.condition_block, "if_outside_pred_next", condition);
                    }
                }
            }
        }
        const merge_forward = if (merge_block) |merge| merge > pattern.condition_block else false;
        const merge_else = !is_elif and merge_forward and merge_block != null and merge_block == pattern.else_block;
        const orig_then = then_block;
        const orig_else = else_block;
        const orig_else_forward = if (orig_else) |eid| eid > pattern.condition_block else false;
        const orig_then_reaches_else = if (orig_else_forward)
            try self.reachesBlock(orig_then, orig_else.?, pattern.condition_block)
        else
            false;

        if (!is_elif) {
            if (merge_block) |merge| {
                if (merge_forward) {
                    if (else_block) |else_id| {
                        if (merge == else_id) {
                            const else_term = self.isTerminalBlock(else_id);
                            if (!else_term) {
                                var keep_else = false;
                                const else_res = self.resolveJumpOnlyBlock(else_id);
                                if (then_block < self.cfg.blocks.len) {
                                    const then_blk = &self.cfg.blocks[then_block];
                                    if (!condBlockHasPrelude(then_blk)) {
                                        if (then_blk.terminator()) |then_term| {
                                            if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                                var t_id: ?u32 = null;
                                                var f_id: ?u32 = null;
                                                for (then_blk.successors) |edge| {
                                                    if (edge.edge_type == .exception) continue;
                                                    if (edge.edge_type == .conditional_false) {
                                                        f_id = edge.target;
                                                    } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                                        t_id = edge.target;
                                                    }
                                                }
                                                if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(t_id.?) == else_res) {
                                                    keep_else = true;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (!keep_else and !force_else and try self.postDominates(else_id, then_block)) {
                                    else_block = null;
                                    self.if_next = merge;
                                }
                            }
                        }
                    }
                }
            }
            if (orig_then_reaches_else) {
                if (orig_else) |else_id| {
                    if (else_id > orig_then and try self.postDominates(else_id, orig_then)) {
                        self.if_next = else_id;
                    }
                }
            }
        }

        var swapped_true_jump = false;
        if (!is_elif and !legacy_cond) {
            if (term) |t| switch (t.opcode) {
                .POP_JUMP_IF_TRUE,
                .POP_JUMP_FORWARD_IF_TRUE,
                .POP_JUMP_BACKWARD_IF_TRUE,
                .JUMP_IF_TRUE,
                => {
                    if (else_block) |else_id| {
                        var cond_jump_count: usize = 0;
                        var has_call = false;
                        var has_cmp = false;
                        for (cond_block.instructions) |inst| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) cond_jump_count += 1;
                            switch (inst.opcode) {
                                .CALL_FUNCTION,
                                .CALL_METHOD,
                                .CALL_FUNCTION_KW,
                                .CALL_FUNCTION_EX,
                                .CALL,
                                => has_call = true,
                                .COMPARE_OP,
                                .CONTAINS_OP,
                                .IS_OP,
                                => has_cmp = true,
                                else => {},
                            }
                        }
                        if (cond_jump_count <= 1 and self.analyzer.detectBoolOp(pattern.condition_block) == null) {
                            const is_not = condition.* == .unary_op and condition.unary_op.op == .not_;
                            const can_invert = has_call and !has_cmp;
                            var has_short_circuit = false;
                            const resolved_else = self.resolveJumpOnlyBlock(else_id);
                            if (try self.condChainFalseTarget(resolved_else, then_block)) |_| {
                                has_short_circuit = true;
                            }
                            if (can_invert and !is_not and !has_short_circuit) {
                                const is_assert = self.isAssertRaiseBlock(else_id);
                                if (!is_assert) {
                                    condition = try self.invertConditionExpr(condition);
                                    try self.emitDecisionTrace(pattern.condition_block, "if_invert_true_jump", condition);
                                    const tmp = then_block;
                                    then_block = else_id;
                                    else_block = tmp;
                                    is_elif = false;
                                    swapped_true_jump = true;
                                }
                            }
                        }
                    }
                },
                else => {},
            };
        }

        // Check for chained comparison pattern (Python 3.14+)
        if (try self.tryDecompileChainedComparison(pattern, condition, &sim)) |chain_result| {
            // condition's parts have been transferred to chain_result.stmt, don't deinit
            self.chained_cmp_next_block = chain_result.next_block;
            return chain_result.stmt;
        }
        self.chained_cmp_next_block = null;

        var chain_else: ?u32 = null;
        if (!is_elif) {
            if (else_block) |else_id| {
                const resolved = self.resolveJumpOnlyBlock(else_id);
                if (resolved != else_id) {
                    chain_else = resolved;
                }
            }
        }

        // Save remaining stack values to transfer to branches
        var base_vals_buf = try self.cloneStackValues(sim.stack.items.items);
        var base_vals = base_vals_buf;
        var base_owned = true;
        errdefer if (base_owned) {
            self.deinitStackValues(base_vals_buf);
        };
        defer if (base_owned) {
            self.deinitStackValues(base_vals_buf);
        };

        // Collapse chained condition blocks on the then-path (x and y and z).
        var chained_cmp = false;
        var else_resolved = false;
        var cond_chain_then = false;
        var guard_or_else_applied = false;
        if (chain_else != null and condition.* == .compare) {
            const else_target = chain_else.?;
            if (then_block < self.cfg.blocks.len) {
                const then_blk = &self.cfg.blocks[then_block];
                if (!condBlockHasPrelude(then_blk)) {
                    if (then_blk.terminator()) |then_term| {
                        if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                            var t_id: ?u32 = null;
                            var f_id: ?u32 = null;
                            for (then_blk.successors) |edge| {
                                if (edge.edge_type == .exception) continue;
                                if (edge.edge_type == .conditional_false) {
                                    f_id = edge.target;
                                } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                    t_id = edge.target;
                                }
                            }
                            if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(f_id.?) == else_target) {
                                const cmp1 = condition.compare;
                                if (cmp1.comparators.len > 0) {
                                    const mid = cmp1.comparators[cmp1.comparators.len - 1];
                                    var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                    defer then_sim.deinit();
                                    then_sim.lenient = true;
                                    then_sim.stack.allow_underflow = true;
                                    try then_sim.stack.push(.{ .expr = mid });
                                    if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |cond2| {
                                        if (cond2.* == .compare and ast.exprEqual(mid, cond2.compare.left)) {
                                            const cmp2 = cond2.compare;
                                            const a = self.arena.allocator();
                                            const ops = try a.alloc(ast.CmpOp, cmp1.ops.len + cmp2.ops.len);
                                            const comparators = try a.alloc(*Expr, cmp1.comparators.len + cmp2.comparators.len);
                                            std.mem.copyForwards(ast.CmpOp, ops[0..cmp1.ops.len], cmp1.ops);
                                            std.mem.copyForwards(ast.CmpOp, ops[cmp1.ops.len..], cmp2.ops);
                                            std.mem.copyForwards(*Expr, comparators[0..cmp1.comparators.len], cmp1.comparators);
                                            std.mem.copyForwards(*Expr, comparators[cmp1.comparators.len..], cmp2.comparators);
                                            const chain_expr = try a.create(Expr);
                                            chain_expr.* = .{ .compare = .{
                                                .left = cmp1.left,
                                                .ops = ops,
                                                .comparators = comparators,
                                            } };
                                            condition = chain_expr;
                                            then_block = self.resolveJumpOnlyBlock(t_id.?);
                                            else_block = else_target;
                                            is_elif = false;
                                            chained_cmp = true;
                                            else_resolved = true;
                                            if (base_vals.len > 0) {
                                                const last_idx = base_vals.len - 1;
                                                const last = base_vals_buf[last_idx];
                                                last.deinit(self.allocator, self.allocator);
                                                base_vals_buf[last_idx] = .unknown;
                                                base_vals = base_vals_buf[0..last_idx];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (!chained_cmp) {
            var allow_cond_chain = true;
            if (!is_elif and then_block < self.cfg.blocks.len) {
                const then_pat = try self.analyzer.detectPatternNoTry(then_block);
                if (then_pat == .if_stmt) {
                    var chain_ok = false;
                    if (else_block) |else_id| {
                        if (then_pat.if_stmt.else_block) |inner_else| {
                            const else_res = self.resolveJumpOnlyBlock(else_id);
                            const inner_res = self.resolveJumpOnlyBlock(inner_else);
                            if (inner_res == else_res) {
                                chain_ok = true;
                            }
                        }
                    }
                    if (!chain_ok) {
                        allow_cond_chain = false;
                    }
                }
            }
            if (allow_cond_chain) {
                const cond_else = blk: {
                    if (else_block) |else_id| break :blk else_id;
                    if (!is_elif and merge_forward) {
                        if (merge_block) |merge_id| break :blk merge_id;
                    }
                    break :blk null;
                };
                if (cond_else) |else_id| {
                    if (then_block < self.cfg.blocks.len and self.cfg.blocks[then_block].is_loop_header) {
                        // Don't collapse condition chains into a loop header.
                    } else {
                        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                        defer seen.deinit();
                        const else_res = self.resolveJumpOnlyBlock(else_id);
                        if (self.isTerminalBlock(else_res)) {
                            // Keep guard-style if chains intact for parity.
                        } else {
                            var cur = then_block;
                            var final_then = then_block;
                            var progressed = false;
                            while (cur < self.cfg.blocks.len) {
                                if (seen.isSet(cur)) break;
                                seen.set(cur);
                                const blk = &self.cfg.blocks[cur];
                                const blk_term = blk.terminator() orelse break;
                                if (!ctrl.Analyzer.isConditionalJump(undefined, blk_term.opcode)) break;
                                if (condBlockHasPrelude(blk)) break;
                                var t_id: ?u32 = null;
                                var f_id: ?u32 = null;
                                for (blk.successors) |edge| {
                                    if (edge.edge_type == .exception) continue;
                                    if (edge.edge_type == .conditional_false) {
                                        f_id = edge.target;
                                    } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                        t_id = edge.target;
                                    }
                                }
                                if (t_id == null or f_id == null) break;
                                if (t_id.? < self.cfg.blocks.len and self.cfg.blocks[t_id.?].is_loop_header) break;
                                if (self.resolveJumpOnlyBlock(f_id.?) != else_res) break;
                                if (t_id.? == else_id) break;
                                progressed = true;
                                final_then = self.resolveJumpOnlyBlock(t_id.?);
                                cur = t_id.?;
                            }
                            if (progressed and final_then != then_block) {
                                var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                                defer in_stack.deinit();
                                var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
                                defer memo.deinit(self.allocator);
                                if (try self.buildCondTree(
                                    pattern.condition_block,
                                    pattern.condition_block,
                                    condition,
                                    final_then,
                                    else_res,
                                    base_vals,
                                    null,
                                    null,
                                    &in_stack,
                                    &memo,
                                )) |expr| {
                                    condition = expr;
                                    then_block = final_then;
                                    else_block = else_res;
                                    cond_chain_then = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        if (!chained_cmp and !cond_chain_then and !is_elif) {
            if (else_block) |else_id| {
                const else_res = self.resolveJumpOnlyBlock(else_id);
                var guard_or_applied = false;
                if (then_block < self.cfg.blocks.len) {
                    const then_blk = &self.cfg.blocks[then_block];
                    if (!condBlockHasPrelude(then_blk)) {
                        if (then_blk.terminator()) |then_term| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                var t_id: ?u32 = null;
                                var f_id: ?u32 = null;
                                for (then_blk.successors) |edge| {
                                    if (edge.edge_type == .exception) continue;
                                    if (edge.edge_type == .conditional_false) {
                                        f_id = edge.target;
                                    } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                        t_id = edge.target;
                                    }
                                }
                                // Check for `not A or not B` pattern:
                                // Outer: POP_JUMP_IF_FALSE to body (A false -> body)
                                // Inner: POP_JUMP_IF_TRUE to skip (B true -> skip)
                                // Both inner false and outer else point to body
                                if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(f_id.?) == else_res) {
                                    const true_res = self.resolveJumpOnlyBlock(t_id.?);
                                    // Inner true target is the skip block, inner false is body
                                    // Outer: POP_JUMP_IF_FALSE, Inner: POP_JUMP_IF_TRUE
                                    const allow_or_not = self.isTerminalBlock(else_res) and
                                        self.isFalseJump(term.?.opcode) and
                                        self.isTrueJump(then_term.opcode);
                                    if (allow_or_not) {
                                        var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                        defer then_sim.deinit();
                                        then_sim.lenient = true;
                                        then_sim.stack.allow_underflow = true;
                                        if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |cond2| {
                                            // not A or not B: invert A, invert B
                                            const inv0 = try self.invertConditionExpr(condition);
                                            const inv1 = try self.invertConditionExpr(cond2);
                                            condition = try self.makeBoolPair(inv0, inv1, .or_);
                                            then_block = else_res;
                                            else_block = null;
                                            cond_chain_then = true;
                                            guard_or_applied = true;
                                            deferred_if_next = true_res;
                                            try self.emitDecisionTrace(pattern.condition_block, "if_chain_or_not", condition);
                                        }
                                    }
                                }
                                if (!guard_or_applied and t_id != null and f_id != null and self.resolveJumpOnlyBlock(t_id.?) == else_res) {
                                    const false_res = self.resolveJumpOnlyBlock(f_id.?);
                                    const allow_guard_or = (self.isTerminalBlock(false_res) and !self.isAssertRaiseBlock(false_res)) or
                                        (self.isTerminalBlock(else_res) and self.isRaiseBlock(else_res) and !self.isAssertRaiseBlock(else_res));
                                    if (allow_guard_or and self.isFalseJump(then_term.opcode)) {
                                        var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                        defer then_sim.deinit();
                                        then_sim.lenient = true;
                                        then_sim.stack.allow_underflow = true;
                                        if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |cond2| {
                                            const inv0 = try self.invertConditionExpr(condition);
                                            condition = try self.makeBoolPair(inv0, cond2, .or_);
                                            then_block = else_res;
                                            else_block = null;
                                            cond_chain_then = true;
                                            guard_or_applied = true;
                                            if (false_res > else_res) {
                                                forced_then_end = false_res;
                                            }
                                            deferred_if_next = false_res;
                                            self.consumed.unset(false_res);
                                            try self.emitDecisionTrace(pattern.condition_block, "if_chain_guard_or", condition);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (!guard_or_applied) {
                    if (then_block < self.cfg.blocks.len) {
                        const then_blk = &self.cfg.blocks[then_block];
                        if (!condBlockHasPrelude(then_blk)) {
                            if (then_blk.terminator()) |then_term| {
                                if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                    var t_id: ?u32 = null;
                                    var f_id: ?u32 = null;
                                    for (then_blk.successors) |edge| {
                                        if (edge.edge_type == .exception) continue;
                                        if (edge.edge_type == .conditional_false) {
                                            f_id = edge.target;
                                        } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                            t_id = edge.target;
                                        }
                                    }
                                    if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(t_id.?) == else_res) {
                                        const false_res = self.resolveJumpOnlyBlock(f_id.?);
                                        if (else_res < self.cfg.blocks.len) {
                                            const else_blk = &self.cfg.blocks[else_res];
                                            if (!condBlockHasPrelude(else_blk)) {
                                                if (else_blk.terminator()) |else_term| {
                                                    if (ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) {
                                                        var et_id: ?u32 = null;
                                                        var ef_id: ?u32 = null;
                                                        for (else_blk.successors) |edge| {
                                                            if (edge.edge_type == .exception) continue;
                                                            if (edge.edge_type == .conditional_false) {
                                                                ef_id = edge.target;
                                                            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                                                et_id = edge.target;
                                                            }
                                                        }
                                                        if (et_id != null and ef_id != null) {
                                                            const res_t = self.resolveJumpOnlyBlock(et_id.?);
                                                            const res_f = self.resolveJumpOnlyBlock(ef_id.?);
                                                            const term_block = if (res_t == false_res and res_f != false_res)
                                                                res_f
                                                            else if (res_f == false_res and res_t != false_res)
                                                                res_t
                                                            else
                                                                null;
                                                            if (term_block != null) {
                                                                var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                                                defer then_sim.deinit();
                                                                then_sim.lenient = true;
                                                                then_sim.stack.allow_underflow = true;
                                                                if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |cond2| {
                                                                    var else_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                                                    defer else_sim.deinit();
                                                                    else_sim.lenient = true;
                                                                    else_sim.stack.allow_underflow = true;
                                                                    if (try self.condExprFromBlock(else_res, &else_sim, term_block.?, false_res, 0)) |cond3| {
                                                                        const inv0 = try self.invertConditionExpr(condition);
                                                                        const or_expr = try self.makeBoolPair(inv0, cond2, .or_);
                                                                        condition = try self.makeBoolPair(or_expr, cond3, .and_);
                                                                        then_block = term_block.?;
                                                                        else_block = false_res;
                                                                        cond_chain_then = true;
                                                                        try self.emitDecisionTrace(pattern.condition_block, "if_chain_term", condition);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if (!cond_chain_then) {
                                            var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                            defer then_sim.deinit();
                                            then_sim.lenient = true;
                                            then_sim.stack.allow_underflow = true;
                                            if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |cond2| {
                                                const inv = try self.invertConditionExpr(cond2);
                                                condition = try self.makeBoolPair(condition, inv, .and_);
                                                then_block = self.resolveJumpOnlyBlock(f_id.?);
                                                else_block = else_res;
                                                cond_chain_then = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (!guard_or_applied and !cond_chain_then and self.isTerminalBlock(then_block)) {
                    if (else_res < self.cfg.blocks.len) {
                        const then_res = self.resolveJumpOnlyBlock(then_block);
                        var cur_else = else_res;
                        var merged = false;
                        while (cur_else < self.cfg.blocks.len) {
                            const else_blk = &self.cfg.blocks[cur_else];
                            if (condBlockHasPrelude(else_blk)) break;
                            const else_term = else_blk.terminator() orelse break;
                            if (!ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) break;
                            var et_id: ?u32 = null;
                            var ef_id: ?u32 = null;
                            for (else_blk.successors) |edge| {
                                if (edge.edge_type == .exception) continue;
                                if (edge.edge_type == .conditional_false) {
                                    ef_id = edge.target;
                                } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                    et_id = edge.target;
                                }
                            }
                            if (et_id == null or ef_id == null) break;
                            const res_t = self.resolveJumpOnlyBlock(et_id.?);
                            const res_f = self.resolveJumpOnlyBlock(ef_id.?);
                            var alt_res: ?u32 = null;
                            var invert_second = false;
                            if (res_t == then_res and res_f != then_res) {
                                alt_res = res_f;
                                invert_second = false;
                            } else if (res_f == then_res and res_t != then_res) {
                                alt_res = res_t;
                                invert_second = true;
                            } else {
                                break;
                            }
                            if (alt_res == null or alt_res.? == then_res) break;
                            if (alt_res.? == cur_else) break;
                            var else_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                            defer else_sim.deinit();
                            else_sim.lenient = true;
                            else_sim.stack.allow_underflow = true;
                            const cond2 = (try self.condExprFromBlock(cur_else, &else_sim, et_id.?, ef_id.?, 0)) orelse break;
                            const rhs = if (invert_second) try self.invertConditionExpr(cond2) else cond2;
                            condition = try self.makeBoolPair(condition, rhs, .or_);
                            merged = true;
                            cond_chain_then = true;
                            guard_or_applied = true;
                            guard_or_else_applied = true;
                            prefer_false_body = false;
                            if (cur_else != else_id) {
                                try self.consumed.set(self.allocator, cur_else);
                            }
                            else_block = alt_res;
                            cur_else = alt_res.?;
                        }
                        if (merged) {
                            if (else_res != else_id) {
                                try self.consumed.set(self.allocator, else_id);
                            }
                            try self.consumed.set(self.allocator, else_res);
                            is_elif = false;
                            try self.emitDecisionTrace(pattern.condition_block, "if_chain_guard_or_else", condition);
                        }
                    }
                }
            }
        }

        // Collapse short-circuit condition chains that share the same then-block.
        var cond_tree_applied = false;
        if (!guard_or_else_applied) {
            if (else_block) |else_id| {
                if (else_id < self.cfg.blocks.len) {
                    const else_blk = &self.cfg.blocks[else_id];
                    if (else_blk.terminator()) |else_term| {
                        if (ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) {
                            if (try self.condChainFalseTarget(else_id, then_block)) |fb| {
                                var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                                defer in_stack.deinit();
                                var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
                                defer memo.deinit(self.allocator);
                                const cond_expr = (try self.buildCondTree(
                                    pattern.condition_block,
                                    pattern.condition_block,
                                    condition,
                                    then_block,
                                    fb,
                                    base_vals,
                                    null,
                                    null,
                                    &in_stack,
                                    &memo,
                                )) orelse null;
                                if (cond_expr) |expr| {
                                    condition = expr;
                                    else_block = fb;
                                    is_elif = false;
                                    cond_tree_applied = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        var inverted = swapped_true_jump;
        var guard_block: ?u32 = null;
        if (cond_tree_applied) {
            if (else_block) |else_id| {
                if (try self.condChainAllTrueJumps(pattern.condition_block, else_id)) {
                    condition = try self.invertConditionExpr(condition);
                    try self.emitDecisionTrace(pattern.condition_block, "if_invert_bool_chain", condition);
                    then_block = else_id;
                    else_block = pattern.then_block;
                    is_elif = false;
                    inverted = true;
                }
            }
        }
        if (!inverted and !cond_tree_applied) {
            if (term) |t| switch (t.opcode) {
                .POP_JUMP_IF_TRUE,
                .POP_JUMP_FORWARD_IF_TRUE,
                .POP_JUMP_BACKWARD_IF_TRUE,
                .JUMP_IF_TRUE,
                => {
                    if (!legacy_cond and !is_elif) {
                        if (else_block) |else_id| {
                            const then_term = self.isTerminalBlock(then_block);
                            const else_term = self.isTerminalBlock(else_id);
                            if ((!then_term or else_term) and !guard_or_else_applied) {
                                if (self.isAssertRaiseBlock(else_id)) {
                                    // keep condition; assert handling wants the original branch
                                } else {
                                    condition = try self.invertConditionExpr(condition);
                                    try self.emitDecisionTrace(pattern.condition_block, "if_invert_true_jump", condition);
                                    const tmp = then_block;
                                    then_block = else_id;
                                    else_block = tmp;
                                    is_elif = false;
                                    inverted = true;
                                }
                            }
                        }
                    }
                    if (!inverted) {
                        if (else_block) |else_id| {
                            if (self.isTerminalBlock(else_id) and !self.isTerminalBlock(then_block)) {
                                if (!self.isAssertRaiseBlock(else_id) and
                                    try self.condChainAllTrueJumps(pattern.condition_block, else_id))
                                {
                                    condition = try self.invertConditionExpr(condition);
                                    try self.emitDecisionTrace(pattern.condition_block, "if_invert_terminal_else", condition);
                                    then_block = else_id;
                                    else_block = pattern.then_block;
                                    is_elif = false;
                                    inverted = true;
                                }
                            }
                        }
                    }
                },
                else => {},
            };
        }
        if (!inverted) {
            if (else_block) |else_id| {
                const else_res = self.resolveJumpOnlyBlock(else_id);
                if (else_res < self.cfg.blocks.len and
                    self.isRaiseBlock(else_res) and
                    !self.isAssertRaiseBlock(else_res) and
                    then_block < self.cfg.blocks.len)
                {
                    const then_blk = &self.cfg.blocks[then_block];
                    if (!condBlockHasPrelude(then_blk)) {
                        if (then_blk.terminator()) |then_term| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                var t_id: ?u32 = null;
                                var f_id: ?u32 = null;
                                for (then_blk.successors) |edge| {
                                    if (edge.edge_type == .exception) continue;
                                    if (edge.edge_type == .conditional_false) {
                                        f_id = edge.target;
                                    } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                        t_id = edge.target;
                                    }
                                }
                                if (t_id != null and f_id != null) {
                                    const t_res = self.resolveJumpOnlyBlock(t_id.?);
                                    const f_res = self.resolveJumpOnlyBlock(f_id.?);
                                    var succ_id: ?u32 = null;
                                    var cond2: ?*Expr = null;
                                    var then_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                                    defer then_sim.deinit();
                                    then_sim.lenient = true;
                                    then_sim.stack.allow_underflow = true;
                                    if (try self.condExprFromBlock(then_block, &then_sim, t_id.?, f_id.?, 0)) |c2| {
                                        cond2 = c2;
                                    }
                                    if (cond2) |c2| {
                                        var inner = c2;
                                        if (t_res == else_res and f_res != else_res) {
                                            succ_id = f_id.?;
                                            inner = try self.invertConditionExpr(c2);
                                        } else if (f_res == else_res and t_res != else_res) {
                                            succ_id = t_id.?;
                                        }
                                        if (succ_id != null) {
                                            const combined = try self.makeBoolPair(condition, inner, .and_);
                                            condition = try self.invertConditionExpr(combined);
                                            try self.emitDecisionTrace(pattern.condition_block, "if_guard_chain_raise", condition);
                                            const guard_next = self.resolveJumpOnlyBlock(succ_id.?);
                                            then_block = else_res;
                                            else_block = null;
                                            is_elif = false;
                                            inverted = true;
                                            self.if_next = guard_next;
                                            if (else_res != else_id) {
                                                try self.consumed.set(self.allocator, else_id);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!inverted) {
            if (else_block) |else_id| {
                const resolved_else = self.resolveJumpOnlyBlock(else_id);
                if (resolved_else < self.cfg.blocks.len and
                    self.isTerminalBlock(resolved_else) and
                    !self.isTerminalBlock(then_block) and
                    !self.isRaiseBlock(resolved_else) and
                    !self.isAssertRaiseBlock(resolved_else))
                {
                    if (!force_else) {
                        const then_falls_through = self.blockFallsThrough(then_block, resolved_else);
                        const then_reaches_else = try self.reachesBlock(then_block, resolved_else, pattern.condition_block);
                        if (!then_falls_through and !then_reaches_else) {
                            var allow_guard = false;
                            if (term) |t| {
                                allow_guard = self.isTrueJump(t.opcode);
                                if (allow_guard) {
                                    const else_is_jump_target = self.elseIsJumpTarget(t.opcode);
                                    condition = try self.guardCondForBranch(condition, t.opcode, else_is_jump_target);
                                }
                            }
                            if (allow_guard) {
                                try self.emitDecisionTrace(pattern.condition_block, "if_guard_terminal_else_return", condition);
                                const guard_next = then_block;
                                then_block = resolved_else;
                                else_block = null;
                                is_elif = false;
                                inverted = true;
                                self.if_next = guard_next;
                                if (resolved_else != else_id) {
                                    try self.consumed.set(self.allocator, else_id);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!inverted) {
            if (else_block) |else_id| {
                const resolved_else = self.resolveJumpOnlyBlock(else_id);
                if (resolved_else < self.cfg.blocks.len and
                    resolved_else != else_id and
                    merge_block != null and merge_block.? == resolved_else and
                    self.isTerminalBlock(resolved_else) and
                    !self.isTerminalBlock(then_block) and
                    self.isRaiseBlock(resolved_else) and
                    !self.isAssertRaiseBlock(resolved_else))
                {
                    if (!force_else) {
                        const then_falls_through = self.blockFallsThrough(then_block, resolved_else);
                        const then_reaches_else = try self.reachesBlock(then_block, resolved_else, pattern.condition_block);
                        if (!then_falls_through and !then_reaches_else) {
                            if (term) |t| {
                                const else_is_jump_target = self.elseIsJumpTarget(t.opcode);
                                condition = try self.guardCondForBranch(condition, t.opcode, else_is_jump_target);
                            } else {
                                condition = try self.invertConditionExpr(condition);
                            }
                            try self.emitDecisionTrace(pattern.condition_block, "if_guard_terminal_else", condition);
                            const guard_next = then_block;
                            then_block = resolved_else;
                            else_block = null;
                            is_elif = false;
                            inverted = true;
                            self.if_next = guard_next;
                            guard_block = resolved_else;
                            if (resolved_else != else_id) {
                                try self.consumed.set(self.allocator, else_id);
                            }
                        }
                    }
                }
            }
        }
        if (!inverted) {
            if (else_block) |else_id| {
                const resolved_else = self.resolveJumpOnlyBlock(else_id);
                if (!in_elif_chain and
                    resolved_else < self.cfg.blocks.len and
                    resolved_else == else_id and
                    self.isTerminalBlock(resolved_else) and
                    !self.isTerminalBlock(then_block) and
                    self.isRaiseBlock(resolved_else) and
                    !self.isAssertRaiseBlock(resolved_else))
                {
                    if (!force_else) {
                        const then_falls_through = self.blockFallsThrough(then_block, resolved_else);
                        const then_reaches_else = try self.reachesBlock(then_block, resolved_else, pattern.condition_block);
                        if (!then_falls_through and !then_reaches_else) {
                            if (term) |t| {
                                const else_is_jump_target = self.elseIsJumpTarget(t.opcode);
                                condition = try self.guardCondForBranch(condition, t.opcode, else_is_jump_target);
                            } else {
                                condition = try self.invertConditionExpr(condition);
                            }
                            try self.emitDecisionTrace(pattern.condition_block, "if_guard_terminal_else_direct", condition);
                            const guard_next = then_block;
                            then_block = resolved_else;
                            else_block = null;
                            is_elif = false;
                            inverted = true;
                            self.if_next = guard_next;
                            guard_block = resolved_else;
                        }
                    }
                }
            }
        }
        if (!inverted) {
            if (else_block) |else_id| {
                const resolved_else = self.resolveJumpOnlyBlock(else_id);
                const resolved_then = self.resolveJumpOnlyBlock(then_block);
                const merge_is_then = merge_block != null and
                    (merge_block.? == then_block or merge_block.? == resolved_then);
                if (resolved_else < self.cfg.blocks.len and
                    resolved_else != else_id and
                    self.isTerminalBlock(resolved_else) and
                    !self.isTerminalBlock(then_block) and
                    self.isRaiseBlock(resolved_else) and
                    !self.isAssertRaiseBlock(resolved_else) and
                    (merge_is_then or merge_block == null))
                {
                    if (!force_else) {
                        const then_falls_through = self.blockFallsThrough(then_block, resolved_else);
                        const then_reaches_else = try self.reachesBlock(then_block, resolved_else, pattern.condition_block);
                        if (!then_falls_through and !then_reaches_else) {
                            if (term) |t| {
                                const else_is_jump_target = self.elseIsJumpTarget(t.opcode);
                                condition = try self.guardCondForBranch(condition, t.opcode, else_is_jump_target);
                            } else {
                                condition = try self.invertConditionExpr(condition);
                            }
                            try self.emitDecisionTrace(pattern.condition_block, "if_guard_terminal_then", condition);
                            const guard_next = then_block;
                            then_block = resolved_else;
                            else_block = null;
                            is_elif = false;
                            inverted = true;
                            self.if_next = guard_next;
                            guard_block = resolved_else;
                            if (resolved_else != else_id) {
                                try self.consumed.set(self.allocator, else_id);
                            }
                        }
                    }
                }
            }
        }

        if (!cond_chain_then and !is_elif) {
            if (try self.tryChainThenInner(condition, then_block, else_block)) |res| {
                condition = res.condition;
                then_block = res.then_block;
                else_block = res.else_block;
                cond_chain_then = true;
                try self.emitDecisionTrace(pattern.condition_block, "if_chain_then_inner", condition);
            }
        }
        if (!is_elif) {
            if (else_block) |else_id| {
                if (!force_else and else_id > then_block and
                    !self.isTerminalBlock(then_block) and
                    self.blockFallsThrough(then_block, else_id))
                {
                    else_block = null;
                    forced_then_end = else_id;
                    if (self.if_next == null) {
                        self.if_next = else_id;
                    }
                }
            }
        }

        const cond_is_and = condition.* == .bool_op and condition.bool_op.op == .and_;
        var fallthrough: ?u32 = null;
        if (!is_elif) {
            if (else_block) |else_id| {
                if (self.isTerminalBlock(then_block)) {
                    const else_term = self.isTerminalBlock(else_id);
                    if (!else_term) {
                        if (term) |t| {
                            const else_is_jump_target = self.elseIsJumpTarget(t.opcode);
                            if (!force_else and !else_is_jump_target and else_id < then_block) {
                                else_block = null;
                                self.if_next = else_id;
                            } else if (!force_else and else_id > then_block) {
                                fallthrough = else_id;
                                else_block = null;
                                self.if_next = else_id;
                            }
                        } else if (!force_else and else_id > then_block) {
                            fallthrough = else_id;
                            else_block = null;
                            self.if_next = else_id;
                        }
                    } else if (else_id > then_block and (chained_cmp or (cond_chain_then and cond_is_and))) {
                        fallthrough = else_id;
                        else_block = null;
                        self.if_next = else_id;
                    }
                }
            }
        }

        if (!is_elif) {
            if (else_block) |else_id| {
                if (merge_block) |merge_id| {
                    const resolved_else = self.resolveJumpOnlyBlock(else_id);
                    if (!force_else and resolved_else == merge_id and !self.isTerminalBlock(resolved_else) and !self.isTerminalBlock(then_block)) {
                        var keep_else = false;
                        if (then_block < self.cfg.blocks.len) {
                            const then_blk = &self.cfg.blocks[then_block];
                            if (!condBlockHasPrelude(then_blk)) {
                                if (then_blk.terminator()) |then_term| {
                                    if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                        var t_id: ?u32 = null;
                                        var f_id: ?u32 = null;
                                        for (then_blk.successors) |edge| {
                                            if (edge.edge_type == .exception) continue;
                                            if (edge.edge_type == .conditional_false) {
                                                f_id = edge.target;
                                            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                                t_id = edge.target;
                                            }
                                        }
                                        if (t_id != null and f_id != null and self.resolveJumpOnlyBlock(t_id.?) == resolved_else) {
                                            keep_else = true;
                                        }
                                    }
                                }
                            }
                        }
                        if (!keep_else and !cond_chain_then and !chained_cmp and !force_else) {
                            else_block = null;
                            if (self.if_next == null) {
                                self.if_next = resolved_else;
                            }
                            if (resolved_else != else_id) {
                                try self.consumed.set(self.allocator, else_id);
                            }
                        }
                    }
                }
            }
        }

        // For JUMP_IF_FALSE/TRUE (Python 3.0), skip the leading POP_TOP in each branch
        // that was used to clean up the condition left on stack
        const skip: usize = if (legacy_cond) 1 else 0;

        var then_vals = base_vals;
        var else_vals = base_vals;
        var then_owned = false;
        var else_owned = false;
        if (term) |t| switch (t.opcode) {
            .JUMP_IF_TRUE_OR_POP => {
                then_vals = try self.cloneStackValuesWithExpr(base_vals, condition);
                then_owned = true;
            },
            .JUMP_IF_FALSE_OR_POP => {
                else_vals = try self.cloneStackValuesWithExpr(base_vals, condition);
                else_owned = true;
            },
            else => {},
        };
        defer if (then_owned) self.deinitStackValues(then_vals);
        defer if (else_owned) self.deinitStackValues(else_vals);

        if (else_block) |else_id| {
            const resolved_else = self.resolveJumpOnlyBlock(else_id);
            const merge_ok = merge_block != null and
                (merge_block.? == resolved_else or merge_block.? == then_block);
            const assert_ok = self.isAssertRaiseBlock(resolved_else);
            if (merge_ok or assert_ok) {
                if (try self.tryDecompileAssertBlock(condition, else_id, skip)) |assert_stmt| {
                    self.deinitStackValues(base_vals_buf);
                    base_owned = false;
                    self.if_next = then_block;
                    return assert_stmt;
                }
            }
        }

        if (forced_then_end == null and merge_block != null and merge_block.? == then_block) {
            if (else_block) |else_id| {
                const then_res = self.resolveJumpOnlyBlock(then_block);
                if (self.isTerminalBlock(then_res)) {
                    // Keep terminal then-body attached to the guard.
                } else if (else_id < self.cfg.blocks.len and then_block < self.cfg.blocks.len) {
                    if (try self.reachesBlock(else_id, then_block, pattern.condition_block)) {
                        forced_then_end = then_block;
                        try self.emitDecisionTrace(pattern.condition_block, "if_force_empty_then_merge", condition);
                    }
                }
            }
        }

        // Decompile the then body with inherited stack
        const then_end = blk: {
            if (forced_then_end) |ft| break :blk ft;
            if (fallthrough) |fb| break :blk fb;
            if (else_block) |else_id| {
                if (else_id > then_block) break :blk else_id;
            }
            if (merge_block) |merge_id| {
                if (merge_id > then_block) break :blk merge_id;
            }
            break :blk try self.branchEnd(then_block, null);
        };
        var then_body = try self.decompileBranchRange(then_block, then_end, then_vals, skip);
        const a = self.arena.allocator();
        if (!self.bodyEndsTerminal(then_body)) {
            var appended_term_succ = false;
            if (then_block < self.cfg.blocks.len) {
                const then_blk = &self.cfg.blocks[then_block];
                const last_inst = if (then_blk.instructions.len > 0) then_blk.instructions[then_blk.instructions.len - 1] else null;
                if (last_inst != null and last_inst.?.opcode == .POP_BLOCK) {
                    var single_succ: ?u32 = null;
                    var multi = false;
                    for (then_blk.successors) |edge| {
                        if (edge.edge_type == .exception) continue;
                        if (single_succ != null) {
                            multi = true;
                            break;
                        }
                        single_succ = edge.target;
                    }
                    if (!multi) {
                        if (single_succ) |succ_id| {
                            if (else_block == null or succ_id != else_block.?) {
                                if (self.isTerminalBlock(succ_id) and self.termSinglePred(succ_id) and
                                    (merge_block == null or succ_id != merge_block.?))
                                {
                                    var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                                    defer tmp.deinit(a);
                                    try self.decompileBlockIntoWithStackAndSkip(succ_id, &tmp, a, &.{}, 0);
                                    if (tmp.items.len > 0) {
                                        const last = tmp.items[tmp.items.len - 1];
                                        if (self.stmtIsTerminal(last)) {
                                            then_body = try self.appendStmt(a, then_body, last);
                                            try self.consumed.set(self.allocator, succ_id);
                                            appended_term_succ = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!appended_term_succ and !self.bodyEndsTerminal(then_body)) {
                var single_succ: ?u32 = null;
                var multi = false;
                if (then_block < self.cfg.blocks.len) {
                    const then_blk = &self.cfg.blocks[then_block];
                    for (then_blk.successors) |edge| {
                        if (edge.edge_type == .exception) continue;
                        if (single_succ != null) {
                            multi = true;
                            break;
                        }
                        single_succ = edge.target;
                    }
                }
                if (!multi) {
                    if (single_succ) |succ_id| {
                        if (else_block == null or succ_id != else_block.?) {
                            if (self.isTerminalBlock(succ_id) and self.termSinglePred(succ_id) and
                                (merge_block == null or succ_id != merge_block.?))
                            {
                                var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                                defer tmp.deinit(a);
                                try self.decompileBlockIntoWithStackAndSkip(succ_id, &tmp, a, &.{}, 0);
                                if (tmp.items.len > 0) {
                                    const last = tmp.items[tmp.items.len - 1];
                                    if (self.stmtIsTerminal(last)) {
                                        then_body = try self.appendStmt(a, then_body, last);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (condition.* == .name and then_body.len > 0) {
            const last = then_body[then_body.len - 1];
            if (last.* == .return_stmt) {
                if (last.return_stmt.value) |val| {
                    if (self.isPlaceholderExpr(val)) {
                        last.return_stmt.value = try ast.cloneExpr(a, condition);
                    }
                }
            }
        }

        // Check for assert pattern: if cond: pass else: raise AssertionError
        if (else_block) |else_id| {
            if (try self.tryDecompileAssert(pattern, condition, else_id, then_body, base_vals, skip)) |assert_stmt| {
                self.deinitStackValues(base_vals_buf);
                base_owned = false;
                return assert_stmt;
            }
        }

        // If the "else" target is just the fallthrough/next block, don't
        // decompile it as an else body (avoid consuming following statements).
        if (else_block) |cur_else| {
            if (!force_else and !is_elif and cur_else > pattern.condition_block and
                (try self.reachesBlock(then_block, cur_else, pattern.condition_block)))
            {
                else_block = null;
                self.if_next = cur_else;
                if (cur_else < self.cfg.blocks.len) {
                    self.consumed.unset(cur_else);
                }
                if (deferred_if_next == null) {
                    deferred_if_next = cur_else;
                }
                try self.emitDecisionTrace(pattern.condition_block, "if_fallthrough_next", condition);
            } else if (!is_elif and !force_else and !guard_or_else_applied and cur_else > pattern.condition_block and
                self.bodyEndsTerminal(then_body) and self.isTerminalBlock(cur_else) and self.termSinglePred(cur_else))
            {
                else_block = null;
                no_merge = true;
                if (self.if_next == null) {
                    self.if_next = cur_else;
                }
            }
        }

        // Assert pattern: if cond: raise AssertionError[(...)]
        if (!is_elif and self.isAssertRaiseBlock(then_block)) {
            const inv = try self.invertConditionExpr(condition);
            if (try self.tryDecompileAssertBlock(inv, then_block, skip)) |assert_stmt| {
                self.deinitStackValues(base_vals_buf);
                base_owned = false;
                if (deferred_if_next) |next| {
                    self.if_next = next;
                } else if (else_block) |else_id| {
                    if (self.if_next == null) {
                        self.if_next = else_id;
                    }
                }
                return assert_stmt;
            }
        }

        // Decompile the else body
        var else_start: ?u32 = null;
        var else_end: ?u32 = null;
        var else_body = if (else_block) |else_id| blk: {
            // Check if else is an elif
            if (is_elif) {
                // Elif needs to start with fresh stack
                self.deinitStackValues(base_vals_buf);
                base_owned = false;
                if (else_id <= pattern.condition_block) {
                    break :blk &[_]*Stmt{};
                }

                // The else block is another if statement - recurse
                // For legacy conditionals, elif block starts with POP_TOP to clean up previous condition
                const else_pattern = try self.analyzer.detectPattern(else_id);
                if (else_pattern == .if_stmt) {
                    const elif_stmt = try self.decompileIfInElifChain(else_pattern.if_stmt, skip);
                    if (elif_stmt) |s| {
                        const body = try a.alloc(*Stmt, 1);
                        body[0] = s;
                        break :blk body;
                    }
                }
                const merge_before_else = if (merge_block) |merge_id| merge_id < else_id else false;
                const else_end_val = if (merge_block) |merge_id|
                    if (merge_before_else)
                        try self.branchEnd(else_id, null)
                    else
                        merge_id
                else
                    try self.branchEnd(else_id, null);
                else_end = else_end_val;
                // Save if_next - nested if processing may clear it
                const saved_if_next_elif = self.if_next;
                const elif_result = try self.decompileBranchRange(else_id, else_end_val, &.{}, skip);
                if (saved_if_next_elif != null and self.if_next == null) {
                    self.if_next = saved_if_next_elif;
                }
                break :blk elif_result;
            }
            // Regular else with inherited stack
            var else_next: ?u32 = null;
            if (else_resolved and else_id < self.cfg.blocks.len) {
                var succ: ?u32 = null;
                var multi = false;
                for (self.cfg.blocks[else_id].successors) |edge| {
                    if (edge.edge_type == .exception) continue;
                    if (succ != null) {
                        multi = true;
                        break;
                    }
                    succ = edge.target;
                }
                if (!multi) {
                    else_next = succ;
                    if (self.if_next == null) {
                        if (succ) |sid| {
                            if (!self.isTerminalBlock(sid)) {
                                self.if_next = sid;
                            }
                        }
                    }
                }
            }
            const else_start_val = if (else_resolved) self.resolveJumpOnlyBlock(else_id) else else_id;
            else_start = else_start_val;
            const merge_before_else = if (merge_block) |merge_id| merge_id < else_id else false;
            var else_end_val = if (merge_block) |merge_id|
                if (merge_before_else)
                    try self.branchEnd(else_start_val, null)
                else if (merge_id == else_id and !else_resolved)
                    try self.branchEnd(else_start_val, null)
                else if (else_resolved and merge_id == else_id and else_next != null)
                    else_next.?
                else if (else_resolved and merge_id == else_id)
                    try self.branchEnd(else_start_val, null)
                else
                    merge_id
            else if (else_resolved and else_next != null)
                else_next.?
            else
                try self.branchEnd(else_start_val, null);
            if (!is_elif and self.if_next == null and else_id < else_end_val) {
                var reach = try self.reachableInRange(then_block, else_end_val, null);
                defer reach.deinit();
                var common_start: ?u32 = null;
                var bid: u32 = else_id;
                while (bid < else_end_val) : (bid += 1) {
                    if (reach.isSet(bid)) {
                        common_start = bid;
                        break;
                    }
                }
                if (common_start) |mid| {
                    if (mid > else_id) {
                        else_end_val = mid;
                        self.if_next = mid;
                    }
                }
            }
            else_end = else_end_val;
            // Save if_next - nested if processing may clear it
            const saved_if_next = self.if_next;
            const result = try self.decompileBranchRange(else_start_val, else_end_val, else_vals, skip);
            // Restore if_next if it was set by outer merge detection
            if (saved_if_next != null and self.if_next == null) {
                self.if_next = saved_if_next;
            }
            break :blk result;
        } else blk: {
            // No else block - clean up base_vals
            self.deinitStackValues(base_vals_buf);
            base_owned = false;
            break :blk &[_]*Stmt{};
        };

        if (chained_cmp) {
            if (else_block) |else_id| {
                try self.consumed.set(self.allocator, else_id);
                const resolved_else = self.resolveJumpOnlyBlock(else_id);
                if (resolved_else != else_id) {
                    try self.consumed.set(self.allocator, resolved_else);
                }
            }
        }

        if (else_block) |else_id| {
            if (else_body.len == 0) {
                const else_res = self.resolveJumpOnlyBlock(else_id);
                if (else_res < self.cfg.blocks.len) {
                    var is_continue = false;
                    if (self.cfg.blocks[else_res].is_loop_header and
                        self.analyzer.inLoop(pattern.condition_block, else_res))
                    {
                        is_continue = true;
                    }
                    if (!is_continue) {
                        for (self.cfg.blocks[else_res].successors) |edge| {
                            if (edge.edge_type != .loop_back) continue;
                            if (self.analyzer.inLoop(pattern.condition_block, edge.target)) {
                                is_continue = true;
                                break;
                            }
                        }
                    }
                    if (is_continue) {
                        const cont = try self.makeContinue();
                        const body = try a.alloc(*Stmt, 1);
                        body[0] = cont;
                        else_body = body;
                    }
                }
            }
        }

        if (!is_elif) {
            if (else_block) |else_id| {
                if (self.if_next == null and else_id > pattern.condition_block and
                    else_body.len == 1 and else_body[0].* == .raise_stmt and then_body.len > 0)
                {
                    const last_then = then_body[then_body.len - 1];
                    if (last_then.* == .return_stmt) {
                        else_body = &[_]*Stmt{};
                        no_merge = true;
                        self.if_next = else_id;
                    }
                } else if (self.if_next == null and else_id > pattern.condition_block and
                    then_body.len == 1 and then_body[0].* == .raise_stmt and
                    else_body.len == 1 and else_body[0].* == .return_stmt)
                {
                    if (!Decompiler.isReturnNone(else_body[0])) {
                        else_body = &[_]*Stmt{};
                        no_merge = true;
                        self.if_next = else_id;
                    }
                } else if (self.if_next == null and else_id > pattern.condition_block and
                    then_body.len == 1 and then_body[0].* == .return_stmt and
                    else_body.len == 1 and else_body[0].* == .return_stmt)
                {
                    const then_ret = then_body[0].return_stmt;
                    const else_ret = else_body[0].return_stmt;
                    if (then_ret.value) |tval| {
                        if (else_ret.value) |eval| {
                            if (tval.* == .constant and eval.* == .constant and
                                tval.constant == .true_ and eval.constant == .false_)
                            {
                                else_body = &[_]*Stmt{};
                                no_merge = true;
                                self.if_next = else_id;
                            }
                        }
                    }
                } else if (then_body.len > 0 and else_body.len > 0) {
                    const last_then = then_body[then_body.len - 1];
                    const last_else = else_body[else_body.len - 1];
                    if (Decompiler.isReturnNone(last_then) and last_else.* == .return_stmt and
                        !Decompiler.isReturnNone(last_else))
                    {
                        else_body = &[_]*Stmt{};
                        no_merge = true;
                        self.if_next = else_id;
                    }
                }
            }
        }

        if (self.if_tail == null and then_body.len > 0 and else_body.len > 0) {
            const last_then = then_body[then_body.len - 1];
            const last_else = else_body[else_body.len - 1];
            if (Decompiler.isReturnNone(last_then) and last_else.* == .return_stmt and
                !Decompiler.isReturnNone(last_else))
            {
                self.if_tail = else_body;
                else_body = &[_]*Stmt{};
                no_merge = true;
                self.if_next = null;
            }
        }
        if (self.if_tail == null and !is_elif and then_body.len > 0 and else_body.len > 0) {
            const cond_is_or = condition.* == .bool_op and condition.bool_op.op == .or_;
            const else_starts_nonterm = else_body.len > 0 and !self.stmtIsTerminal(else_body[0]);
            if (cond_is_or and self.bodyEndsTerminal(then_body) and else_starts_nonterm) {
                self.if_tail = else_body;
                else_body = &[_]*Stmt{};
                no_merge = true;
                self.if_next = null;
            }
        }

        if (!is_elif and self.if_next == null) {
            if (else_block != null and self.bodyEndsTerminal(else_body)) {
                if (merge_block) |merge_id| {
                    if (merge_id < self.cfg.blocks.len and merge_id > pattern.condition_block and
                        merge_id != then_block and (else_block == null or merge_id != else_block.?))
                    {
                        if (try self.reachesBlock(then_block, merge_id, pattern.condition_block)) {
                            self.if_next = merge_id;
                        }
                    }
                }
            }
        }

        var synth_else = false;
        if (else_block != null) {
            if (else_body.len == 0) {
                if (merge_block) |merge_id| {
                    if (merge_id < self.cfg.blocks.len and merge_id > pattern.condition_block) {
                        var limit: u32 = @intCast(self.cfg.blocks.len);
                        if (self.br_limit) |lim| {
                            const lim_next = lim + 1;
                            if (lim_next < limit) limit = lim_next;
                        }
                        var reach = try self.reachableInRange(then_block, limit, merge_id);
                        defer reach.deinit();
                        var next_id: ?u32 = null;
                        var bid: u32 = merge_id + 1;
                        while (bid < limit) : (bid += 1) {
                            if (reach.isSet(bid)) {
                                next_id = bid;
                                break;
                            }
                        }
                        if (next_id != null) {
                            var term_id: ?u32 = null;
                            var cur = merge_id;
                            var steps: u32 = 0;
                            var linear = true;
                            while (cur < self.cfg.blocks.len) {
                                steps += 1;
                                if (steps > self.cfg.blocks.len) {
                                    linear = false;
                                    break;
                                }
                                const blk = &self.cfg.blocks[cur];
                                if (blk.terminator()) |t| {
                                    if (ctrl.Analyzer.isConditionalJump(undefined, t.opcode)) {
                                        linear = false;
                                        break;
                                    }
                                }
                                var next: ?u32 = null;
                                var count: u32 = 0;
                                for (blk.successors) |edge| {
                                    if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                                    count += 1;
                                    if (count == 1) next = edge.target;
                                }
                                if (count == 0) {
                                    term_id = cur;
                                    break;
                                }
                                if (count > 1 or next == null) {
                                    linear = false;
                                    break;
                                }
                                cur = next.?;
                            }
                            if (linear and term_id != null) {
                                var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                                defer tmp.deinit(a);
                                try self.decompileBlockIntoWithStackAndSkip(term_id.?, &tmp, a, &.{}, 0);
                                if (tmp.items.len == 1 and self.stmtIsTerminal(tmp.items[0])) {
                                    const body = try a.alloc(*Stmt, 1);
                                    body[0] = tmp.items[0];
                                    else_body = body;
                                    synth_else = true;

                                    if (self.if_next == null) {
                                        self.if_next = next_id.?;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        var appended_term: ?*Stmt = null;
        if (else_block) |else_id| {
            const then_reaches_else = try self.reachesBlock(then_block, else_id, pattern.condition_block);
            var collapsed_else = false;
            const else_preds = if (else_id < self.cfg.blocks.len) self.cfg.blocks[else_id].predecessors.len else 0;
            if (then_reaches_else and else_body.len > 1 and self.isTerminalBlock(else_id)) {
                else_body = &[_]*Stmt{};
                self.if_next = else_id;
                collapsed_else = true;
            } else if (then_reaches_else and else_body.len == 1 and self.stmtIsTerminal(else_body[0]) and self.isTerminalBlock(else_id) and try self.postDominates(else_id, then_block) and else_preds == 1) {
                else_body = &[_]*Stmt{};
                self.if_next = else_id;
                collapsed_else = true;
            }
            if (self.if_next == null and merge_block == null and !collapsed_else) {
                const else_terminal = self.bodyEndsTerminal(else_body) or self.isTerminalBlock(else_id);
                if (else_terminal) {
                    var limit = then_end;
                    if (then_end <= else_id) {
                        limit = @intCast(self.cfg.blocks.len);
                    }
                    var reach = try self.reachableInRange(then_block, limit, else_id);
                    defer reach.deinit();
                    const else_off = self.cfg.blocks[else_id].start_offset;
                    var fall_candidate: ?u32 = null;
                    var bid: u32 = 0;
                    while (bid < self.cfg.blocks.len) : (bid += 1) {
                        if (!reach.isSet(bid)) continue;
                        if (bid == else_id) continue;
                        const off = self.cfg.blocks[bid].start_offset;
                        if (off <= else_off) continue;
                        if (fall_candidate == null or
                            off < self.cfg.blocks[fall_candidate.?].start_offset)
                        {
                            fall_candidate = bid;
                        }
                    }
                    if (fall_candidate) |next_id| {
                        self.if_next = next_id;
                    }
                }
            }
            if (!collapsed_else and !synth_else and !self.bodyEndsTerminal(then_body) and else_body.len == 0) {
                const allow_append = if (else_block) |eid|
                    self.resolveJumpOnlyBlock(eid) != eid
                else
                    true;
                if (allow_append) {
                    if (try self.findTerminalStmtFrom(then_block, else_id)) |term_res| {
                        const term_from_else = try self.reachesBlock(else_id, term_res.block_id, pattern.condition_block);
                        if (!term_from_else) {
                            const term_off = self.cfg.blocks[term_res.block_id].start_offset;
                            const else_off = self.cfg.blocks[else_id].start_offset;
                            const same_block = term_res.block_id == else_id;
                            const term_before_else = term_off < else_off or same_block;
                            if (same_block and then_reaches_else and else_body.len == 1 and self.stmtIsTerminal(else_body[0]) and self.terminalStmtEqual(else_body[0], term_res.stmt) and try self.postDominates(else_id, then_block)) {
                                else_body = &[_]*Stmt{};
                                self.if_next = else_id;
                            } else {
                                const else_reaches = if (same_block) false else try self.reachesBlock(else_id, term_res.block_id, null);
                                const term_postdom = try self.postDominates(term_res.block_id, then_block);
                                const term_direct = self.hasSingleNormalSuccessor(then_block, term_res.block_id);
                                if (term_before_else and !else_reaches and (term_postdom or term_direct)) {
                                    const term_is_merge = merge_block != null and
                                        term_res.block_id == merge_block.?;
                                    if (!term_is_merge and self.termSinglePred(term_res.block_id)) {
                                        then_body = try self.appendStmt(a, then_body, term_res.stmt);
                                        appended_term = term_res.stmt;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (else_block) |else_id| {
            const resolved_then = self.resolveJumpOnlyBlock(then_block);
            const then_is_raise = resolved_then < self.cfg.blocks.len and self.isRaiseBlock(resolved_then);
            if (!force_else and !is_elif and then_is_raise and else_body.len > 0) {
                if (term) |t| {
                    if (self.elseIsJumpTarget(t.opcode)) {
                        else_body = &[_]*Stmt{};
                        else_block = null;
                        self.if_next = else_id;
                        if (else_id < self.cfg.blocks.len) {
                            self.consumed.unset(else_id);
                        }
                        if (deferred_if_next == null) {
                            deferred_if_next = else_id;
                        }
                        try self.emitDecisionTrace(pattern.condition_block, "if_guard_raise_fallthrough", condition);
                    }
                }
            }
        }
        if (appended_term) |term_stmt| {
            if (else_body.len == 1 and self.stmtIsTerminal(else_body[0]) and self.terminalStmtEqual(else_body[0], term_stmt)) {
                else_body = &[_]*Stmt{};
            }
        }
        if (merge_else and !cond_chain_then) {
            if (merge_block) |merge| {
                self.if_next = merge;
            }
            else_body = &[_]*Stmt{};
        }

        if (else_block) |else_id| {
            if (else_id > pattern.condition_block and else_body.len > 0 and
                !self.bodyEndsTerminal(else_body) and
                try self.reachesBlock(then_block, else_id, pattern.condition_block) and
                try self.postDominates(else_id, then_block))
            {
                const else_pat = try self.analyzer.detectPatternNoTry(else_id);
                const else_is_elif = else_pat == .if_stmt and else_pat.if_stmt.is_elif;
                if (!else_is_elif) {
                    else_body = &[_]*Stmt{};
                    self.if_next = else_id;
                }
            }
        }

        if (prefer_false_body and else_body.len > 0) {
            condition = try self.invertConditionExpr(condition);
            try self.emitDecisionTrace(pattern.condition_block, "if_invert_terminal_then_merge", condition);
            then_body = else_body;
            else_body = &[_]*Stmt{};
            if (self.if_next == null) {
                self.if_next = then_block;
            }
        }

        if (cond_true_jump == true and else_body.len == 1 and else_body[0].* == .raise_stmt and then_body.len > 0 and self.if_tail == null) {
            condition = try self.invertConditionExpr(condition);
            try self.emitDecisionTrace(pattern.condition_block, "if_guard_raise", condition);
            const guard_body = else_body;
            else_body = &[_]*Stmt{};
            self.if_tail = then_body;
            then_body = guard_body;
            // Clear if_next since the following code is handled via if_tail
            self.if_next = null;
        }
        if (else_block) |else_id| {
            if (self.if_tail == null and else_body.len > 0 and then_body.len == 1 and then_body[0].* == .raise_stmt) {
                const resolved_then = self.resolveJumpOnlyBlock(then_block);
                if (resolved_then < self.cfg.blocks.len and self.isTerminalBlock(resolved_then)) {
                    var else_has_loop = false;
                    if (else_id < self.cfg.blocks.len) {
                        for (self.cfg.blocks[else_id].successors) |edge| {
                            if (edge.edge_type == .loop_back) {
                                else_has_loop = true;
                                break;
                            }
                        }
                    }
                    if (self.trace_decisions and self.trace_file != null and else_has_loop) {
                        var buf: [128]u8 = undefined;
                        const tag = if (then_body.len > 0) @tagName(then_body[0].*) else "none";
                        const note = std.fmt.bufPrint(
                            &buf,
                            "guard_loop then_len={d} tag={s}",
                            .{ then_body.len, tag },
                        ) catch "guard_loop";
                        try self.emitDecisionTrace(pattern.condition_block, note, null);
                    }
                    if (else_has_loop) {
                        if (term) |t| {
                            if (self.elseIsJumpTarget(t.opcode)) {
                                self.if_tail = else_body;
                                else_body = &[_]*Stmt{};
                                no_merge = true;
                                self.if_next = null;
                                try self.emitDecisionTrace(pattern.condition_block, "if_guard_raise_fallthrough", condition);
                            }
                        }
                    }
                }
            }
        }
        if (else_block) |else_id| {
            if (self.if_next == null and else_id > pattern.condition_block and
                condition.* == .unary_op and condition.unary_op.op == .not_ and
                else_body.len == 1 and self.stmtIsTerminal(else_body[0]) and
                self.bodyEndsTerminal(then_body))
            {
                else_body = &[_]*Stmt{};
                self.if_next = else_id;
            }
        }
        if (deferred_if_next) |next| {
            self.if_next = next;
        }

        if (self.loop_depth > 0 and self.if_tail == null and
            else_body.len == 1 and else_body[0].* == .return_stmt and
            self.bodyEndsTerminal(then_body))
        {
            self.if_tail = else_body;
            else_body = &[_]*Stmt{};
            no_merge = true;
            self.if_next = null;
        }

        if (merge_block) |merge_id| {
            if (!no_merge and self.phi_by_block.contains(merge_id)) {
                then_body = try self.appendPhiAssignmentsForBranch(merge_id, then_block, then_body, a);
                if (else_block != null) {
                    if (else_start) |es| {
                        else_body = try self.appendPhiAssignmentsForBranch(merge_id, es, else_body, a);
                    }
                } else {
                    if (try self.findPredForBranch(merge_id, pattern.condition_block)) |pred| {
                        const assigns = try self.phiAssignmentsForEdge(pred, merge_id);
                        if (assigns.len > 0) {
                            else_body = assigns;
                        }
                    }
                }
            }
        }

        if (guard_block) |bid| {
            if (bid < self.cfg.blocks.len) {
                try self.consumed.set(self.allocator, bid);
            }
        }

        if (self.if_next == null and self.if_tail == null and else_block == null) {
            if (merge_block) |merge_id| {
                if (merge_id > pattern.condition_block and merge_id < self.cfg.blocks.len) {
                    self.if_next = merge_id;
                }
            }
        }

        // Create if statement
        const stmt = try a.create(Stmt);
        stmt.* = .{ .if_stmt = .{
            .condition = condition,
            .body = then_body,
            .else_body = else_body,
        } };
        stmt.if_stmt.no_merge = no_merge;

        return stmt;
    }

    fn decompileBranchRange(
        self: *Decompiler,
        start_block: u32,
        end_block: ?u32,
        base_vals: []const StackValue,
        skip_first: usize,
    ) DecompileError![]const *Stmt {
        var limit = end_block orelse @as(u32, @intCast(self.cfg.blocks.len));
        if (self.br_limit) |lim| {
            if (lim < limit) limit = lim;
        }
        if (start_block >= limit) return &[_]*Stmt{};

        var reachable = try self.reachableInRange(start_block, limit, end_block);
        defer reachable.deinit();
        var masked: std.ArrayListUnmanaged(u32) = .{};
        defer masked.deinit(self.allocator);
        var bid = start_block;
        while (bid < limit) : (bid += 1) {
            if (!reachable.isSet(bid)) {
                if (!self.consumed.isSet(bid)) {
                    try self.consumed.set(self.allocator, bid);
                    try masked.append(self.allocator, bid);
                }
            }
        }
        defer {
            for (masked.items) |id| {
                self.consumed.unset(id);
            }
        }

        if (skip_first > 0) {
            const a = self.arena.allocator();
            var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
            errdefer stmts.deinit(a);

            try self.decompileBlockIntoWithStackAndSkip(start_block, &stmts, a, base_vals, skip_first);
            try self.consumed.set(self.allocator, start_block);

            if (start_block + 1 < limit) {
                const rest = try self.decompileStructuredRange(start_block + 1, limit);
                try stmts.appendSlice(a, rest);
            }

            return stmts.toOwnedSlice(a);
        } else if (base_vals.len > 0) {
            return self.decompileStructuredRangeWithStackInner(start_block, limit, base_vals, false, false);
        }

        return self.decompileStructuredRange(start_block, limit);
    }

    /// Decompile a while loop pattern.
    fn decompileWhile(self: *Decompiler, pattern: ctrl.WhilePattern) DecompileError!?*Stmt {
        self.loop_next = null;
        const header = &self.cfg.blocks[pattern.header_block];
        var body_true = true;
        for (header.successors) |edge| {
            if (edge.target == pattern.body_block) {
                if (edge.edge_type == .conditional_false) {
                    body_true = false;
                }
                break;
            }
        }

        // Get the condition expression
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();

        var cond_idx: usize = header.instructions.len;
        const insts = header.instructions;
        var inst_idx: usize = 0;
        while (inst_idx < insts.len) : (inst_idx += 1) {
            const inst = insts[inst_idx];
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;

            // Detect walrus operator: COPY 1 followed by STORE_*
            if (inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST or
                inst.opcode == .STORE_GLOBAL or inst.opcode == .STORE_DEREF)
            {
                if (inst_idx > 0 and insts[inst_idx - 1].opcode == .COPY and insts[inst_idx - 1].arg == 1) {
                    const next_idx = inst_idx + 1;
                    var is_walrus = false;
                    if (next_idx < insts.len) {
                        const next_op = insts[next_idx].opcode;
                        is_walrus = switch (next_op) {
                            .DUP_TOP, .COPY, .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => false,
                            .COMPARE_OP, .CONTAINS_OP, .IS_OP,
                            .TO_BOOL, .POP_JUMP_IF_TRUE, .POP_JUMP_IF_FALSE,
                            .POP_JUMP_IF_NONE, .POP_JUMP_IF_NOT_NONE,
                            .POP_JUMP_FORWARD_IF_TRUE, .POP_JUMP_FORWARD_IF_FALSE,
                            .POP_JUMP_FORWARD_IF_NONE, .POP_JUMP_FORWARD_IF_NOT_NONE,
                            .LOAD_SMALL_INT, .LOAD_CONST, .LOAD_FAST, .LOAD_FAST_BORROW,
                            .LOAD_NAME, .LOAD_GLOBAL, .BINARY_OP,
                            => true,
                            else => false,
                        };
                    }

                    if (is_walrus) {
                        const copied = sim.stack.pop() orelse return error.StackUnderflow;
                        if (copied == .expr) {
                            const expr = copied.expr;
                            const name = switch (inst.opcode) {
                                .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                                .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                                else => "__unknown__",
                            };
                            const arena = self.arena.allocator();
                            const target = try self.makeName(name, .store);
                            const named = try arena.create(Expr);
                            named.* = .{ .named_expr = .{ .target = target, .value = expr } };

                            if (sim.stack.pop()) |orig| {
                                orig.deinit(sim.allocator, sim.stack_alloc);
                            }
                            try sim.stack.push(.{ .expr = named });
                            cond_idx = inst_idx + 1;
                            continue;
                        } else {
                            copied.deinit(sim.allocator, sim.stack_alloc);
                        }
                    }
                }
            }

            try sim.simulate(inst);
            cond_idx = inst_idx + 1;
        }

        var condition = try sim.stack.popExpr();

        var body_block_id = pattern.body_block;
        var ignore_header_while = false;
        const exit_in_loop = self.analyzer.inLoop(pattern.exit_block, pattern.header_block);
        const exit_is_continue = exit_in_loop or self.blockLeadsToHeader(pattern.exit_block, pattern.header_block);
        if (exit_is_continue) {
            const a = self.arena.allocator();
            condition = try ast.makeConstant(a, .true_);
            body_block_id = pattern.header_block;
            ignore_header_while = true;
            cond_idx = 0;
        }
        if (!exit_is_continue) {
            var alt_id: ?u32 = null;
            for (header.successors) |edge| {
                if (edge.target == body_block_id) continue;
                if (self.analyzer.inLoop(edge.target, pattern.header_block)) {
                    alt_id = edge.target;
                    break;
                }
            }
            if (alt_id) |cid| {
                const alt_blk = &self.cfg.blocks[cid];
                if (alt_blk.terminator()) |alt_term| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, alt_term.opcode)) {
                        var alt_body_taken: ?bool = null;
                        var has_exit = false;
                        for (alt_blk.successors) |edge| {
                            if (edge.edge_type == .exception) continue;
                            if (edge.target == body_block_id) {
                                alt_body_taken = edge.edge_type == .conditional_true or edge.edge_type == .normal;
                            } else if (edge.target == pattern.exit_block) {
                                has_exit = true;
                            }
                        }
                        if (alt_body_taken != null and has_exit) {
                            var alt_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                            defer alt_sim.deinit();
                            for (alt_blk.instructions) |inst| {
                                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                                try alt_sim.simulate(inst);
                            }
                            var alt_cond = try alt_sim.stack.popExpr();
                            alt_cond = try self.guardCondForBranch(alt_cond, alt_term.opcode, alt_body_taken.?);
                            condition = try self.makeBoolPair(condition, alt_cond, .or_);
                        }
                    }
                }
            }
        }

        if (body_block_id < self.cfg.blocks.len) {
            const body_pattern = try self.analyzer.detectPattern(body_block_id);
            if (body_pattern == .if_stmt) {
                const guard = body_pattern.if_stmt;
                if (guard.condition_block == body_block_id and guard.else_block != null) {
                    const else_id = guard.else_block.?;
                    const merge_is_then = guard.merge_block != null and
                        (guard.merge_block.? == guard.then_block or guard.merge_block.? == pattern.header_block);
                    const else_is_exit = else_id == pattern.exit_block;
                    const merge_is_exit = guard.merge_block != null and guard.merge_block.? == pattern.exit_block;
                    const then_in_loop = self.analyzer.inLoop(guard.then_block, pattern.header_block);
                    const can_merge = (merge_is_then or merge_is_exit or (guard.merge_block == null and else_is_exit)) and then_in_loop;
                    if (can_merge and else_is_exit) {
                        var guard_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                        defer guard_sim.deinit();
                        const guard_block = &self.cfg.blocks[guard.condition_block];
                        for (guard_block.instructions) |inst| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                            try guard_sim.simulate(inst);
                        }
                        const guard_cond = try guard_sim.stack.popExpr();
                        const a = self.arena.allocator();
                        const values = try a.alloc(*Expr, 2);
                        values[0] = condition;
                        values[1] = guard_cond;
                        const combined = try a.create(Expr);
                        combined.* = .{ .bool_op = .{ .op = .and_, .values = values } };
                        condition = combined;
                        body_block_id = guard.then_block;
                    }
                }
            }
        }

        var visited = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer visited.deinit();

        var skip_first = false;
        const term = header.terminator();
        const legacy_cond = if (term) |t| t.opcode == .JUMP_IF_FALSE or t.opcode == .JUMP_IF_TRUE else false;
        const body_block = &self.cfg.blocks[body_block_id];
        var body_skip: usize = 0;
        if (body_block_id == pattern.header_block and !ignore_header_while) {
            for (header.instructions, 0..) |inst, idx| {
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                    body_skip = idx + 1;
                    break;
                }
            }
        }
        var seed_pop = false;
        if (legacy_cond) {
            if (body_block_id == pattern.header_block) {
                if (body_skip < header.instructions.len and header.instructions[body_skip].opcode == .POP_TOP) {
                    seed_pop = true;
                }
            } else if (body_block.instructions.len > 0 and body_block.instructions[0].opcode == .POP_TOP) {
                seed_pop = true;
            }
        }
        if (ignore_header_while) {
            seed_pop = false;
        }
        var body = try self.decompileLoopBody(
            body_block_id,
            pattern.header_block,
            &skip_first,
            &seed_pop,
            &visited,
            null,
            body_skip,
            ignore_header_while,
        );

        if (body.len > 0) {
            const last_stmt = body[body.len - 1];
            if (last_stmt.* == .if_stmt) {
                const ifs = &last_stmt.if_stmt;
                if (ifs.body.len == 1 and ifs.body[0].* == .raise_stmt and
                    ifs.else_body.len == 1 and !self.stmtIsTerminal(ifs.else_body[0]))
                {
                    const a = self.arena.allocator();
                    const new_body = try a.alloc(*Stmt, body.len + 1);
                    std.mem.copyForwards(*Stmt, new_body[0..body.len], body);
                    new_body[body.len] = ifs.else_body[0];
                    ifs.else_body = &[_]*Stmt{};
                    body = new_body;
                }
            }
        }

        const a = self.arena.allocator();
        var header_stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer header_stmts.deinit(a);
        var skip_first_store = false;
        if (cond_idx > 0) {
            try self.processPartialBlock(header, &header_stmts, a, &skip_first_store, cond_idx);
        }

        var guard_if: ?*Stmt = null;
        var guard_next: ?u32 = null;
        if (pattern.exit_block < self.cfg.blocks.len) {
            const exit_block = &self.cfg.blocks[pattern.exit_block];
            // Process exit block as guard if header has prelude OR exit block has content
            const should_process = condBlockHasPrelude(header) or exitBlockHasContent(exit_block);
            if (should_process and exit_block.predecessors.len == 1 and exit_block.predecessors[0] == pattern.header_block) {
                var has_cond = false;
                for (exit_block.instructions) |inst| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                        has_cond = true;
                        break;
                    }
                }
                if (!has_cond) {
                    var succ: ?u32 = null;
                    var multi_succ = false;
                    for (exit_block.successors) |edge| {
                        if (edge.edge_type == .exception) continue;
                        if (succ != null) {
                            multi_succ = true;
                            break;
                        }
                        succ = edge.target;
                    }
                    if (!multi_succ) {
                        const exit_jump = self.jumpTargetIfJumpOnly(pattern.exit_block, true);
                        if (exit_jump == null or (succ != null and exit_jump.? != succ.?)) {
                            const succ_outside = if (succ) |sid| !self.analyzer.inLoop(sid, pattern.header_block) else true;
                            if (succ_outside and (succ == null or self.isTerminalBlock(succ.?))) {
                                var next_block: u32 = pattern.exit_block;
                                if (succ) |sid| {
                                    if (!self.analyzer.inLoop(sid, pattern.header_block)) {
                                        next_block = sid;
                                    }
                                }
                                if (next_block == pattern.exit_block) {
                                    const limit: u32 = @intCast(self.cfg.blocks.len);
                                    while (next_block < limit) : (next_block += 1) {
                                        if (next_block == pattern.exit_block) continue;
                                        if (self.analyzer.inLoop(next_block, pattern.header_block)) continue;
                                        break;
                                    }
                                }
                                const exit_stmts = try self.decompileBlockRangeWithStackAndSkip(
                                    pattern.exit_block,
                                    pattern.exit_block + 1,
                                    &.{},
                                    0,
                                );
                                var succ_stmts: []const *Stmt = &.{};
                                var inline_succ = false;
                                if (succ) |sid| {
                                    if (sid != next_block) {
                                        inline_succ = true;
                                    }
                                }
                                if (inline_succ) {
                                    if (succ) |sid| {
                                        succ_stmts = try self.decompileBlockRangeWithStackAndSkip(sid, sid + 1, &.{}, 0);
                                    }
                                }

                                const guard_cond = if (body_true)
                                    try self.invertConditionExpr(condition)
                                else
                                    condition;

                                const guard_len = exit_stmts.len + succ_stmts.len;
                                const needs_break = if (guard_len == 0) true else blk: {
                                    const last = if (succ_stmts.len > 0)
                                        succ_stmts[succ_stmts.len - 1]
                                    else
                                        exit_stmts[exit_stmts.len - 1];
                                    break :blk !self.stmtIsTerminal(last);
                                };
                                const extra = if (needs_break) @as(usize, 1) else 0;
                                const guard_body = try a.alloc(*Stmt, guard_len + extra);
                                if (exit_stmts.len > 0) {
                                    std.mem.copyForwards(*Stmt, guard_body[0..exit_stmts.len], exit_stmts);
                                }
                                if (succ_stmts.len > 0) {
                                    std.mem.copyForwards(
                                        *Stmt,
                                        guard_body[exit_stmts.len .. exit_stmts.len + succ_stmts.len],
                                        succ_stmts,
                                    );
                                }
                                if (needs_break) {
                                    guard_body[guard_len] = try self.makeBreak();
                                }

                                const gs = try a.create(Stmt);
                                gs.* = .{ .if_stmt = .{
                                    .condition = guard_cond,
                                    .body = guard_body,
                                    .else_body = &.{},
                                } };
                                guard_if = gs;
                                try self.consumed.set(self.allocator, pattern.exit_block);
                                if (inline_succ) {
                                    if (succ) |sid| {
                                        try self.consumed.set(self.allocator, sid);
                                    }
                                }
                                guard_next = next_block;
                            }
                        }
                    }
                }
            }
        }

        const trace_on = self.trace_loop_guards and self.trace_file != null;
        var exit_path: std.ArrayListUnmanaged(u32) = .{};
        const exit_to_header = if (pattern.exit_block < self.cfg.blocks.len)
            try self.continuesToHeader(
                pattern.exit_block,
                pattern.header_block,
                if (trace_on) &exit_path else null,
            )
        else
            false;

        var loop_cond = condition;
        if (!body_true) {
            loop_cond = try self.invertConditionExpr(condition);
        }

        var final_condition = loop_cond;
        var final_body = body;
        const term_true_jump = if (term) |t| self.isTrueJump(t.opcode) else false;
        const force_guard = term_true_jump and guard_if == null and header_stmts.items.len == 0 and !condBlockHasPrelude(header);
        if (guard_if) |gs| {
            const true_expr = try ast.makeConstant(a, .true_);
            const new_body = try a.alloc(*Stmt, header_stmts.items.len + 1 + body.len);
            if (header_stmts.items.len > 0) {
                std.mem.copyForwards(*Stmt, new_body[0..header_stmts.items.len], header_stmts.items);
            }
            new_body[header_stmts.items.len] = gs;
            if (body.len > 0) {
                std.mem.copyForwards(*Stmt, new_body[header_stmts.items.len + 1 ..], body);
            }
            final_condition = true_expr;
            final_body = new_body;
            if (guard_next) |next| {
                self.loop_next = next;
            }
        } else if (force_guard) {
            const true_expr = try ast.makeConstant(a, .true_);
            const guard_cond = if (body_true)
                try self.invertConditionExpr(condition)
            else
                condition;
            const loop_stmt = if (exit_to_header)
                try self.makeContinue()
            else
                try self.makeBreak();
            const break_body = try a.alloc(*Stmt, 1);
            break_body[0] = loop_stmt;
            const guard_stmt = try a.create(Stmt);
            guard_stmt.* = .{ .if_stmt = .{
                .condition = guard_cond,
                .body = break_body,
                .else_body = &.{},
            } };
            const new_body = try a.alloc(*Stmt, 1 + body.len);
            new_body[0] = guard_stmt;
            if (body.len > 0) {
                std.mem.copyForwards(*Stmt, new_body[1..], body);
            }
            final_condition = true_expr;
            final_body = new_body;
        } else if (header_stmts.items.len > 0) {
            const true_expr = try ast.makeConstant(a, .true_);
            const guard_cond = if (body_true)
                try self.invertConditionExpr(condition)
            else
                condition;
            const loop_stmt = if (exit_to_header)
                try self.makeContinue()
            else
                try self.makeBreak();
            const break_body = try a.alloc(*Stmt, 1);
            break_body[0] = loop_stmt;
            const guard_stmt = try a.create(Stmt);
            guard_stmt.* = .{ .if_stmt = .{
                .condition = guard_cond,
                .body = break_body,
                .else_body = &.{},
            } };
            if (trace_on) {
                if (term) |t| {
                    try self.emitGuardTrace(
                        pattern.header_block,
                        pattern.header_block,
                        t,
                        pattern.exit_block,
                        guard_cond,
                        header_stmts.items.len,
                        exit_path.items,
                    );
                }
            }

            const new_body = try a.alloc(*Stmt, header_stmts.items.len + 1 + body.len);
            std.mem.copyForwards(*Stmt, new_body[0..header_stmts.items.len], header_stmts.items);
            new_body[header_stmts.items.len] = guard_stmt;
            if (body.len > 0) {
                std.mem.copyForwards(*Stmt, new_body[header_stmts.items.len + 1 ..], body);
            }
            final_condition = true_expr;
            final_body = new_body;
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{
            .while_stmt = .{
                .condition = final_condition,
                .body = final_body,
                .else_body = &.{},
            },
        };

        var max_visited: ?u32 = null;
        var it = visited.iterator(.{});
        while (it.next()) |bit| {
            const bid: u32 = @intCast(bit);
            if (max_visited == null or bid > max_visited.?) {
                max_visited = bid;
            }
            try self.consumed.set(self.allocator, bid);
        }
        if (self.loop_next == null) {
            if (max_visited) |max_block| {
                if (pattern.exit_block <= max_block) {
                    const next_block = max_block + 1;
                    if (next_block < self.cfg.blocks.len) {
                        self.loop_next = next_block;
                    }
                }
            }
        }

        return stmt;
    }

    fn decompileLoopHeader(self: *Decompiler, header: u32) DecompileError!?PatternResult {
        const body_set = self.analyzer.loopSet(header) orelse return null;
        if (!body_set.isSet(@intCast(header))) return null;

        var visited = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer visited.deinit();

        const a = self.arena.allocator();
        var guard_stmt: ?*Stmt = null;
        var header_stmt_count: usize = 0;
        var header_stmts: []const *Stmt = &.{};
        var guard_body_start: ?u32 = null;
        const trace_on = self.trace_loop_guards and self.trace_file != null;
        if (header < self.cfg.blocks.len) {
            const header_block = &self.cfg.blocks[header];
            if (header_block.terminator()) |term| {
                if (ctrl.Analyzer.isConditionalJump(undefined, term.opcode)) {
                    if (try self.guardBranchToHeader(header_block, term, header, trace_on)) |branch| {
                        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                        defer sim.deinit();
                        sim.lenient = true;
                        sim.stack.allow_underflow = true;
                        if (header < self.stack_in.len) {
                            if (self.stack_in[header]) |entry| {
                                for (entry) |val| {
                                    const cloned = try sim.cloneStackValue(val);
                                    try sim.stack.push(cloned);
                                }
                            }
                        }
                        for (header_block.instructions) |inst| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                            try sim.simulate(inst);
                        }
                        const cond = try sim.stack.popExpr();
                        const guard_cond = try self.guardCondForBranch(cond, term.opcode, branch.taken);
                        var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                        defer tmp.deinit(self.arena.allocator());
                        var skip_first_store = false;
                        var term_idx: usize = header_block.instructions.len;
                        for (header_block.instructions, 0..) |inst, idx| {
                            if (inst.offset == term.offset) {
                                term_idx = idx;
                                break;
                            }
                        }
                        if (term_idx > 0) {
                            try self.processPartialBlock(header_block, &tmp, self.arena.allocator(), &skip_first_store, term_idx);
                            if (tmp.items.len > 0) {
                                header_stmt_count = tmp.items.len;
                                const stmts = try a.alloc(*Stmt, tmp.items.len);
                                std.mem.copyForwards(*Stmt, stmts, tmp.items);
                                header_stmts = stmts;
                            }
                        }
                        const cont_stmt = try self.makeContinue();
                        const body = try a.alloc(*Stmt, 1);
                        body[0] = cont_stmt;
                        const if_stmt = try a.create(Stmt);
                        if_stmt.* = .{ .if_stmt = .{
                            .condition = guard_cond,
                            .body = body,
                            .else_body = &.{},
                        } };
                        guard_stmt = if_stmt;
                        if (trace_on) {
                            try self.emitGuardTrace(
                                header,
                                header,
                                term,
                                branch.target,
                                guard_cond,
                                header_stmt_count,
                                branch.path,
                            );
                        }
                        if (term.jumpTarget(self.cfg.version)) |target_off| {
                            if (self.cfg.blockAtOffset(target_off)) |jump_id| {
                                if (jump_id == header) {
                                    var fall_id: ?u32 = null;
                                    for (header_block.successors) |edge| {
                                        if (edge.edge_type == .exception) continue;
                                        if (edge.target == jump_id) continue;
                                        if (fall_id != null) {
                                            fall_id = null;
                                            break;
                                        }
                                        fall_id = edge.target;
                                    }
                                    if (fall_id) |fid| {
                                        if (self.analyzer.inLoop(fid, header)) {
                                            guard_body_start = fid;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        var skip_first = false;
        var seed_pop = false;
        const body = try self.decompileLoopBody(
            guard_body_start orelse header,
            header,
            &skip_first,
            &seed_pop,
            &visited,
            null,
            0,
            false,
        );
        const cond = try ast.makeConstant(a, .true_);
        var final_body = body;
        if (guard_body_start != null and header_stmts.len > 0) {
            const new_body = try a.alloc(*Stmt, header_stmts.len + final_body.len);
            std.mem.copyForwards(*Stmt, new_body[0..header_stmts.len], header_stmts);
            if (final_body.len > 0) {
                std.mem.copyForwards(*Stmt, new_body[header_stmts.len..], final_body);
            }
            final_body = new_body;
        }
        if (guard_stmt) |gs| {
            var wrapped_guard = false;
            if (gs.* == .if_stmt) {
                const guard_if = gs.if_stmt;
                const guard_body = guard_if.body;
                if (guard_if.else_body.len == 0 and guard_body.len == 1 and guard_body[0].* == .continue_stmt) {
                    if (header_stmt_count <= final_body.len) {
                        const rest = final_body[header_stmt_count..];
                        if (rest.len > 0) {
                            const exec_cond = try self.invertConditionExpr(guard_if.condition);
                            const wrap_stmt = try a.create(Stmt);
                            wrap_stmt.* = .{ .if_stmt = .{
                                .condition = exec_cond,
                                .body = rest,
                                .else_body = &.{},
                            } };
                            const new_body = try a.alloc(*Stmt, header_stmt_count + 1);
                            if (header_stmt_count > 0) {
                                std.mem.copyForwards(*Stmt, new_body[0..header_stmt_count], final_body[0..header_stmt_count]);
                            }
                            new_body[header_stmt_count] = wrap_stmt;
                            final_body = new_body;
                            wrapped_guard = true;
                        }
                    }
                }
            }
            if (!wrapped_guard and final_body.len > 0 and final_body[0].* == .try_stmt and header_stmt_count <= final_body[0].try_stmt.body.len) {
                const old = final_body[0].try_stmt.body;
                const guard_dup = if (gs.* == .if_stmt and header_stmt_count < old.len)
                    self.isContGuard(old[header_stmt_count], gs.if_stmt.condition)
                else
                    false;
                if (!guard_dup) {
                    const new_body = try a.alloc(*Stmt, old.len + 1);
                    if (header_stmt_count > 0) {
                        std.mem.copyForwards(*Stmt, new_body[0..header_stmt_count], old[0..header_stmt_count]);
                    }
                    new_body[header_stmt_count] = gs;
                    if (header_stmt_count < old.len) {
                        std.mem.copyForwards(
                            *Stmt,
                            new_body[header_stmt_count + 1 ..],
                            old[header_stmt_count..],
                        );
                    }
                    final_body[0].try_stmt.body = new_body;
                }
            } else if (!wrapped_guard and header_stmt_count <= final_body.len) {
                const guard_dup = if (gs.* == .if_stmt and header_stmt_count < final_body.len)
                    self.isContGuard(final_body[header_stmt_count], gs.if_stmt.condition)
                else
                    false;
                if (!guard_dup) {
                    const new_body = try a.alloc(*Stmt, final_body.len + 1);
                    if (header_stmt_count > 0) {
                        std.mem.copyForwards(*Stmt, new_body[0..header_stmt_count], final_body[0..header_stmt_count]);
                    }
                    new_body[header_stmt_count] = gs;
                    if (header_stmt_count < final_body.len) {
                        std.mem.copyForwards(
                            *Stmt,
                            new_body[header_stmt_count + 1 ..],
                            final_body[header_stmt_count..],
                        );
                    }
                    final_body = new_body;
                }
            }
        }
        const stmt = try a.create(Stmt);
        stmt.* = .{
            .while_stmt = .{
                .condition = cond,
                .body = final_body,
                .else_body = &.{},
            },
        };

        var exit_block: ?u32 = null;
        var max_block: u32 = header;
        var it = body_set.iterator(.{});
        while (it.next()) |bit| {
            const bid: u32 = @intCast(bit);
            if (bid > max_block) max_block = bid;
            const blk = &self.cfg.blocks[bid];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (!body_set.isSet(@intCast(edge.target))) {
                    exit_block = if (exit_block) |prev|
                        @min(prev, edge.target)
                    else
                        edge.target;
                }
            }
        }

        const limit: u32 = @intCast(self.cfg.blocks.len);
        const next_block = exit_block orelse blk: {
            const candidate = max_block + 1;
            break :blk if (candidate < limit) candidate else limit;
        };

        const consume_limit = if (self.br_limit) |lim| lim else limit;
        var consume_it = body_set.iterator(.{});
        while (consume_it.next()) |bit| {
            const bid: u32 = @intCast(bit);
            if (bid >= consume_limit) continue;
            try self.consumed.set(self.allocator, bid);
        }

        return .{ .stmt = stmt, .next_block = next_block };
    }

    const PatternResult = struct {
        stmt: ?*Stmt,
        next_block: u32,
    };

    fn tryDecompileAsyncFor(self: *Decompiler, pattern: ctrl.TryPattern) DecompileError!?PatternResult {
        if (self.version.lt(3, 5)) return null;
        if (pattern.handlers.len == 0) return null;

        var handled = false;
        defer if (handled) self.allocator.free(pattern.handlers);

        var handler_id: ?u32 = null;
        for (pattern.handlers) |handler_info| {
            if (handler_info.handler_block >= self.cfg.blocks.len) continue;
            const handler = &self.cfg.blocks[handler_info.handler_block];

            var has_stop = false;
            var has_cmp = false;
            var has_jump = false;
            for (handler.instructions) |inst| {
                switch (inst.opcode) {
                    .LOAD_GLOBAL => {
                        if (self.code.names.len > inst.arg) {
                            if (std.mem.eql(u8, self.code.names[inst.arg], "StopAsyncIteration")) {
                                has_stop = true;
                            }
                        }
                    },
                    .COMPARE_OP => {
                        if (inst.arg == 10) has_cmp = true;
                    },
                    .POP_JUMP_IF_TRUE, .POP_JUMP_IF_FALSE => has_jump = true,
                    else => {},
                }
            }
            if (has_stop and has_cmp and has_jump) {
                handler_id = handler_info.handler_block;
                break;
            }
        }
        if (handler_id == null) return null;

        const try_id = pattern.try_block;
        if (try_id >= self.cfg.blocks.len) return null;
        const try_block = &self.cfg.blocks[try_id];

        var setup_id: ?u32 = null;
        var setup_off: ?u32 = null;
        var aiter_id: ?u32 = null;
        const setup_scan = blk: {
            if (try_block.predecessors.len == 0) break :blk &[_]u32{try_id};
            const tmp = try self.allocator.alloc(u32, try_block.predecessors.len + 1);
            tmp[0] = try_id;
            @memcpy(tmp[1..], try_block.predecessors);
            break :blk tmp;
        };
        defer if (try_block.predecessors.len > 0) self.allocator.free(setup_scan);
        for (setup_scan) |block_id| {
            if (block_id >= self.cfg.blocks.len) continue;
            const block = &self.cfg.blocks[block_id];
            var has_aiter = false;
            var has_setup = false;
            var setup_offset: u32 = 0;
            for (block.instructions) |inst| {
                if (inst.opcode == .GET_AITER) has_aiter = true;
                if (inst.opcode == .SETUP_EXCEPT) {
                    has_setup = true;
                    setup_offset = inst.offset;
                }
            }
            if (!has_setup) continue;
            if (has_aiter) {
                setup_id = block_id;
                setup_off = setup_offset;
                aiter_id = block_id;
                break;
            }
            for (block.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                for (pred.instructions) |inst| {
                    if (inst.opcode == .GET_AITER) {
                        setup_id = block_id;
                        setup_off = setup_offset;
                        aiter_id = pred_id;
                        break;
                    }
                }
                if (aiter_id != null) break;
            }
            if (setup_id != null) break;
        }
        const setup_block_id = setup_id orelse return null;
        const setup_block = &self.cfg.blocks[setup_block_id];
        const setup_except_off = setup_off orelse return null;
        const aiter_block_id = aiter_id orelse setup_block_id;
        const aiter_block = &self.cfg.blocks[aiter_block_id];

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        for (aiter_block.instructions) |inst| {
            if (inst.opcode == .GET_AITER) break;
            try sim.simulate(inst);
        }
        const iter_expr = try sim.stack.popExpr();

        const a = self.arena.allocator();
        var target: *Expr = undefined;
        var found_target = false;
        var saw_yield = false;
        var idx: usize = 0;
        while (idx < try_block.instructions.len) : (idx += 1) {
            const inst = try_block.instructions[idx];
            if (inst.opcode == .YIELD_FROM) {
                saw_yield = true;
                continue;
            }
            if (!saw_yield) continue;
            switch (inst.opcode) {
                .UNPACK_SEQUENCE => {
                    const count = inst.arg;
                    if (count == 0) {
                        target = try a.create(Expr);
                        target.* = .{ .tuple = .{ .elts = &.{}, .ctx = .store } };
                        found_target = true;
                        break;
                    }
                    if (idx + count >= try_block.instructions.len) return null;
                    const elts = try a.alloc(*Expr, count);
                    var j: u32 = 0;
                    while (j < count) : (j += 1) {
                        const store_inst = try_block.instructions[idx + 1 + j];
                        const name = switch (store_inst.opcode) {
                            .STORE_FAST => sim.getLocal(store_inst.arg) orelse "_",
                            .STORE_DEREF => sim.getDeref(store_inst.arg) orelse "_",
                            .STORE_NAME, .STORE_GLOBAL => sim.getName(store_inst.arg) orelse "_",
                            else => return null,
                        };
                        elts[j] = try self.makeName(name, .store);
                    }
                    target = try a.create(Expr);
                    target.* = .{ .tuple = .{ .elts = elts, .ctx = .store } };
                    found_target = true;
                    break;
                },
                .STORE_FAST => {
                    const name = sim.getLocal(inst.arg) orelse "_";
                    target = try self.makeName(name, .store);
                    found_target = true;
                    break;
                },
                .STORE_DEREF => {
                    const name = sim.getDeref(inst.arg) orelse "_";
                    target = try self.makeName(name, .store);
                    found_target = true;
                    break;
                },
                .STORE_NAME, .STORE_GLOBAL => {
                    const name = sim.getName(inst.arg) orelse "_";
                    target = try self.makeName(name, .store);
                    found_target = true;
                    break;
                },
                else => {},
            }
            if (found_target) break;
        }
        if (!found_target) return null;

        var body_start_off: ?u32 = null;
        var body_empty = false;
        var found_pop = false;
        var next_after_pop: ?decoder.Instruction = null;
        var pop_block = try_block;
        var pop_idx: usize = 0;
        for (try_block.instructions, 0..) |inst, i| {
            if (inst.opcode != .POP_BLOCK) continue;
            found_pop = true;
            pop_idx = i;
            break;
        }
        if (!found_pop) {
            for (try_block.successors) |edge| {
                if (edge.edge_type != .normal) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                const succ = &self.cfg.blocks[edge.target];
                for (succ.instructions, 0..) |inst, i| {
                    if (inst.opcode != .POP_BLOCK) continue;
                    found_pop = true;
                    pop_block = succ;
                    pop_idx = i;
                    break;
                }
                if (found_pop) break;
            }
        }
        if (!found_pop) return null;
        if (pop_idx + 1 < pop_block.instructions.len) {
            next_after_pop = pop_block.instructions[pop_idx + 1];
        } else if (pop_block.end_offset < self.code.code.len) {
            if (self.cfg.blockAtOffset(pop_block.end_offset)) |next_id| {
                const next_block = &self.cfg.blocks[next_id];
                if (next_block.instructions.len > 0) {
                    next_after_pop = next_block.instructions[0];
                }
            }
        }
        if (next_after_pop) |next_inst| {
            switch (next_inst.opcode) {
                .JUMP_FORWARD,
                .JUMP_ABSOLUTE,
                .JUMP_BACKWARD,
                .JUMP_BACKWARD_NO_INTERRUPT,
                => {
                    const target_off = next_inst.jumpTarget(self.version) orelse return null;
                    if (target_off == setup_except_off and next_inst.opcode != .JUMP_FORWARD) {
                        body_empty = true;
                    } else {
                        body_start_off = target_off;
                    }
                },
                else => {
                    body_start_off = next_inst.offset;
                },
            }
        }

        var loop_end_off: ?u32 = null;
        // Search setup block and predecessors for SETUP_LOOP
        const search_blocks = blk: {
            if (setup_block.predecessors.len == 0) break :blk &[_]u32{setup_block_id};
            const tmp = try self.allocator.alloc(u32, setup_block.predecessors.len + 1);
            tmp[0] = setup_block_id;
            @memcpy(tmp[1..], setup_block.predecessors);
            break :blk tmp;
        };
        defer if (setup_block.predecessors.len > 0) self.allocator.free(search_blocks);
        for (search_blocks) |bid| {
            if (bid >= self.cfg.blocks.len) continue;
            const blk = &self.cfg.blocks[bid];
            for (blk.instructions) |inst| {
                if (inst.opcode == .SETUP_LOOP) {
                    const multiplier: u32 = if (self.version.gte(3, 10)) 2 else 1;
                    loop_end_off = inst.offset + inst.size + inst.arg * multiplier;
                    break;
                }
            }
            if (loop_end_off != null) break;
        }
        const exit_off = loop_end_off orelse return null;
        const exit_ptr = self.cfg.blockContaining(exit_off) orelse return null;
        const exit_block = exit_ptr.id;

        var body: []const *Stmt = &.{};
        if (!body_empty) {
            const body_off = body_start_off orelse return null;
            const body_block = self.cfg.blockAtOffset(body_off) orelse return null;
            // Initialize stack with 3 placeholder exprs for exception handler context
            const exc_stack = &[_]StackValue{
                .{ .expr = blk: {
                    const e = try a.create(Expr);
                    e.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                    break :blk e;
                } },
                .{ .expr = blk: {
                    const e = try a.create(Expr);
                    e.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                    break :blk e;
                } },
                .{ .expr = blk: {
                    const e = try a.create(Expr);
                    e.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                    break :blk e;
                } },
            };
            body = try self.decompileStructuredRangeWithStack(body_block, exit_block, exc_stack);
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{ .for_stmt = .{
            .target = target,
            .iter = iter_expr,
            .body = body,
            .else_body = &.{},
            .type_comment = null,
            .is_async = true,
        } };

        handled = true;
        return .{ .stmt = stmt, .next_block = exit_block };
    }

    fn decompileTry(self: *Decompiler, pattern: ctrl.TryPattern) DecompileError!PatternResult {
        return self.decompileTryWithLoop(pattern, null, null);
    }

    fn decompileTryWithLoop(
        self: *Decompiler,
        pattern: ctrl.TryPattern,
        loop_header: ?u32,
        visited: ?*std.DynamicBitSet,
    ) DecompileError!PatternResult {
        if (pattern.handlers_owned) {
            defer self.allocator.free(pattern.handlers);
        }

        var handler_blocks: std.ArrayListUnmanaged(u32) = .{};
        defer handler_blocks.deinit(self.allocator);
        if (pattern.handlers.len > 0) {
            try handler_blocks.ensureTotalCapacity(self.allocator, pattern.handlers.len);
        }

        for (pattern.handlers) |handler| {
            if (handler.handler_block >= self.cfg.blocks.len) continue;
            try handler_blocks.append(self.allocator, handler.handler_block);
        }
        if (handler_blocks.items.len == 0) {
            return .{ .stmt = null, .next_block = pattern.try_block + 1 };
        }

        std.mem.sort(u32, handler_blocks.items, {}, std.sort.asc(u32));
        const handler_start = handler_blocks.items[0];

        if (self.version.gte(3, 11)) {
            return try self.decompileTry311(pattern, handler_blocks.items);
        }
        const scratch = try self.getTryScratch(self.cfg.blocks.len);
        var handler_final: std.ArrayListUnmanaged(bool) = .{};
        defer handler_final.deinit(self.allocator);
        if (handler_blocks.items.len > 0) {
            try handler_final.ensureTotalCapacity(self.allocator, handler_blocks.items.len);
        }
        var has_finally = false;
        var except_count: usize = 0;
        for (handler_blocks.items) |hid| {
            const is_finally = try self.isFinallyHandler(hid, scratch);
            try handler_final.append(self.allocator, is_finally);
            if (is_finally) {
                has_finally = true;
            } else {
                except_count += 1;
            }
        }
        var handler_set = &scratch.handler_set;
        handler_set.reset();
        for (handler_blocks.items) |hid| {
            try handler_set.set(self.allocator, hid);
        }

        var protected_set = &scratch.protected_set;
        protected_set.reset();
        for (handler_blocks.items) |hid| {
            if (hid >= self.cfg.blocks.len) continue;
            const handler = &self.cfg.blocks[hid];
            for (handler.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                for (pred.successors) |edge| {
                    if (edge.edge_type == .exception and edge.target == hid) {
                        try protected_set.set(self.allocator, pred_id);
                        break;
                    }
                }
            }
        }
        if (visited) |v| {
            for (protected_set.list.items) |bid| {
                if (bid < self.cfg.blocks.len) {
                    v.set(bid);
                }
            }
        }

        var try_break = false;
        if (loop_header) |header_id| {
            for (protected_set.list.items) |bid| {
                if (bid >= self.cfg.blocks.len) continue;
                if (self.hasConditionalPred(bid)) continue;
                const blk = &self.cfg.blocks[bid];
                for (blk.successors) |edge| {
                    if (edge.edge_type == .exception) continue;
                    if (edge.edge_type != .normal) continue;
                    const cand = edge.target;
                    if (cand >= self.cfg.blocks.len) continue;
                    if (!self.analyzer.inLoop(cand, header_id)) continue;
                    if (self.loopBlockLeadsToBreak(cand, header_id) and self.jumpTargetIfJumpOnly(cand, true) != null) {
                        try_break = true;
                        break;
                    }
                }
                if (try_break) break;
            }
        }

        var post_try_entry: ?u32 = null;
        for (protected_set.list.items) |bid| {
            const block = &self.cfg.blocks[bid];
            for (block.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (protected_set.isSet(edge.target)) continue;
                if (handler_set.isSet(edge.target)) continue;
                var candidate = edge.target;
                if (candidate < handler_start) {
                    const resolved = self.resolveJumpOnlyBlockNoCleanup(candidate);
                    if (resolved > handler_start) {
                        candidate = resolved;
                    } else if (loop_header) |header_id| {
                        const resolved_in_loop = resolved < self.cfg.blocks.len and
                            self.analyzer.inLoop(resolved, header_id);
                        if (!resolved_in_loop or resolved == header_id or
                            self.loopBlockLeadsToContinue(candidate, header_id) or
                            self.loopBlockLeadsToBreak(candidate, header_id))
                        {
                            continue;
                        }
                    } else if (!has_finally) {
                        continue;
                    }
                }
                if (candidate >= self.cfg.blocks.len) continue;
                if (protected_set.isSet(candidate)) continue;
                if (handler_set.isSet(candidate)) continue;
                if (block.instructions.len > 0 and block.instructions[block.instructions.len - 1].opcode == .POP_BLOCK) {
                    if (self.isTryReturnCleanupBlock(candidate)) {
                        continue;
                    }
                }
                // Skip blocks ending with terminal instructions (inlined finally with return/raise)
                // Only skip if there's actually a finally block that could have been inlined
                if (has_finally) {
                    const cand_blk = &self.cfg.blocks[candidate];
                    if (cand_blk.terminator()) |term| {
                        if (term.opcode == .RETURN_VALUE or term.opcode == .RETURN_CONST or
                            term.opcode == .RAISE_VARARGS or term.opcode == .RERAISE)
                        {
                            continue;
                        }
                    }
                }
                post_try_entry = if (post_try_entry) |prev|
                    @min(prev, candidate)
                else
                    candidate;
            }
        }

        var handler_reach = &scratch.handler_reach;
        const allow_loop_back = loop_header == null;
        try self.collectReachableNoExceptionFromStarts(
            handler_blocks.items,
            handler_set,
            handler_reach,
            &scratch.queue,
            allow_loop_back,
        );

        var join_block: ?u32 = null;
        if (post_try_entry) |entry| {
            try self.collectReachableNoExceptionInto(
                entry,
                handler_set,
                &scratch.normal_reach,
                &scratch.queue,
                false,
                allow_loop_back,
            );
            for (scratch.normal_reach.list.items) |bid| {
                if (handler_reach.isSet(bid)) {
                    // Skip blocks ending with terminal instructions (return/raise)
                    if (bid < self.cfg.blocks.len) {
                        const blk = &self.cfg.blocks[bid];
                        if (blk.terminator()) |term| {
                            if (term.opcode == .RETURN_VALUE or term.opcode == .RETURN_CONST or
                                term.opcode == .RAISE_VARARGS or term.opcode == .RERAISE)
                            {
                                continue;
                            }
                        }
                    }
                    join_block = bid;
                    break;
                }
            }
        }
        if (self.trace_decisions and self.trace_file != null) {
            const ev = .{
                .kind = "try_join",
                .block = pattern.try_block,
                .post_try_entry = post_try_entry,
                .join_block = join_block,
            };
            try self.writeTrace(ev);
        }

        var pattern_exit = pattern.exit_block;
        if (pattern_exit) |exit| {
            if (handler_reach.isSet(exit)) {
                var in_normal = false;
                if (post_try_entry != null) {
                    in_normal = scratch.normal_reach.isSet(exit);
                }
                if (!in_normal) {
                    pattern_exit = null;
                }
            }
        }

        const effective_exit: ?u32 = if (pattern_exit) |exit|
            self.resolveJumpOnlyBlock(exit)
        else if (join_block) |join|
            self.resolveJumpOnlyBlock(join)
        else if (post_try_entry) |entry|
            self.resolveJumpOnlyBlock(entry)
        else
            null;
        var exit_block = effective_exit;
        if (exit_block) |exit| {
            if (exit <= handler_start) {
                exit_block = null;
            }
        }

        var handler_tail: ?u32 = null;
        for (handler_reach.list.items) |hid| {
            if (effective_exit) |exit_id| {
                if (hid == exit_id) continue;
            }
            if (post_try_entry) |entry_id| {
                if (hid == entry_id) continue;
                if (scratch.normal_reach.isSet(hid)) continue;
            }
            if (join_block) |join_id| {
                if (hid == join_id) continue;
            }
            if (handler_tail == null or hid > handler_tail.?) {
                handler_tail = hid;
            }
        }

        var handler_tail_start: ?u32 = null;
        for (handler_blocks.items, 0..) |hid, idx| {
            if (hid >= self.cfg.blocks.len) continue;
            if (handler_final.items[idx]) continue;
            var handler_end = blk: {
                const next_handler = if (idx + 1 < handler_blocks.items.len)
                    handler_blocks.items[idx + 1]
                else
                    (exit_block orelse @as(u32, @intCast(self.cfg.blocks.len)));
                break :blk next_handler;
            };
            const info = try self.extractHandlerHeader(hid);
            if (handler_end <= info.body_block) {
                handler_end = @intCast(self.cfg.blocks.len);
            }
            var scan_block = info.body_block;
            while (scan_block < handler_end and scan_block < self.cfg.blocks.len) : (scan_block += 1) {
                const scan_blk = &self.cfg.blocks[scan_block];
                var has_pop_except = false;
                for (scan_blk.instructions) |inst| {
                    if (inst.opcode == .POP_EXCEPT) {
                        has_pop_except = true;
                        break;
                    }
                }
                if (!has_pop_except) continue;
                if (scan_blk.terminator()) |term| {
                    if (term.isUnconditionalJump()) {
                        if (term.jumpTarget(self.cfg.version)) |toff| {
                            if (self.cfg.blockAtOffset(toff)) |tid| {
                                if (!handler_set.isSet(tid) and !protected_set.isSet(tid)) {
                                    if (handler_tail_start == null or tid < handler_tail_start.?) {
                                        handler_tail_start = tid;
                                    }
                                }
                            }
                        }
                    }
                }
                break;
            }
        }

        var effective_finally_block = if (has_finally) pattern.finally_block else null;
        if (effective_finally_block != null) {
            var try_entry: ?u32 = null;
            const try_blk = &self.cfg.blocks[pattern.try_block];
            for (try_blk.successors) |edge| {
                if (edge.edge_type == .normal) {
                    try_entry = edge.target;
                    break;
                }
            }
            if (effective_finally_block.? == pattern.try_block or (try_entry != null and effective_finally_block.? == try_entry.?)) {
                var cleanup_candidate: ?u32 = null;
                for (self.cfg.blocks) |*blk| {
                    if (blk.instructions.len != 1) continue;
                    if (blk.instructions[0].opcode != .POP_BLOCK) continue;
                    var has_exc = false;
                    var normal_target: ?u32 = null;
                    var multi = false;
                    for (blk.successors) |edge| {
                        if (edge.edge_type == .exception) {
                            for (handler_blocks.items) |hid| {
                                if (edge.target == hid) {
                                    has_exc = true;
                                    break;
                                }
                            }
                        } else if (edge.edge_type == .normal) {
                            if (normal_target != null) {
                                multi = true;
                                break;
                            }
                            normal_target = edge.target;
                        }
                    }
                    if (multi or !has_exc or normal_target == null) continue;
                    var is_handler = false;
                    for (handler_blocks.items) |hid| {
                        if (normal_target.? == hid) {
                            is_handler = true;
                            break;
                        }
                    }
                    if (is_handler) continue;
                    // Skip blocks ending with terminal instructions (inlined finally with return/raise)
                    const target_blk = &self.cfg.blocks[normal_target.?];
                    if (target_blk.terminator()) |term| {
                        if (term.opcode == .RETURN_VALUE or term.opcode == .RETURN_CONST or
                            term.opcode == .RAISE_VARARGS or term.opcode == .RERAISE)
                        {
                            continue;
                        }
                    }
                    if (cleanup_candidate == null or
                        self.cfg.blocks[normal_target.?].start_offset <
                            self.cfg.blocks[cleanup_candidate.?].start_offset)
                    {
                        cleanup_candidate = normal_target.?;
                    }
                }
                if (cleanup_candidate) |cand| {
                    effective_finally_block = cand;
                }
            }
        }

        var loop_exit: ?u32 = null;
        if (loop_header) |header_id| {
            if (header_id < self.cfg.blocks.len) {
                const header_blk = &self.cfg.blocks[header_id];
                for (header_blk.successors) |edge| {
                    if (edge.edge_type == .conditional_false) {
                        loop_exit = edge.target;
                        break;
                    }
                }
            }
        }

        var else_start: ?u32 = pattern.else_block orelse blk: {
            if (post_try_entry) |entry| {
                if (!handler_reach.isSet(entry)) {
                    if (join_block == null or entry != join_block.?) {
                        break :blk entry;
                    }
                }
            }
            break :blk null;
        };

        if (has_finally and except_count == 0) {
            else_start = null;
        }
        var force_tail: ?u32 = null;
        if (else_start != null and loop_header != null) {
            if (try self.analyzer.allHandlerBlocksTerminal(handler_blocks.items, loop_exit)) {
                force_tail = else_start;
                else_start = null;
            }
        }
        if (loop_header) |header_id| {
            if (else_start) |start| {
                const resolved = self.resolveJumpOnlyBlock(start);
                const leads_cont = self.loopBlockLeadsToContinue(start, header_id);
                const has_exit = if (leads_cont) try self.loopBlockHasExit(start, header_id) else false;
                const in_loop = self.inLoopRelaxed(resolved, header_id, loop_exit);
                if (!in_loop or resolved == header_id or
                    (leads_cont and !has_exit))
                {
                    else_start = null;
                }
            }
        }
        if (else_start) |start| {
            try self.collectReachableNoExceptionInto(
                pattern.try_block,
                handler_set,
                &scratch.normal_reach,
                &scratch.queue,
                false,
                allow_loop_back,
            );
            var has_outside_pred = false;
            if (start < self.cfg.blocks.len) {
                const preds = self.cfg.blocks[start].predecessors;
                for (preds) |pred_id| {
                    if (pred_id < self.cfg.blocks.len and self.resolveJumpOnlyBlock(pred_id) == start) continue;
                    if (handler_set.isSet(pred_id)) continue;
                    if (!scratch.normal_reach.isSet(pred_id)) {
                        has_outside_pred = true;
                        break;
                    }
                }
            }
            if (has_outside_pred) {
                else_start = null;
            }
        }

        const exit_for_range: ?u32 = if (exit_block) |exit|
            if (else_start) |start|
                (if (exit == start) null else exit)
            else
                exit
        else
            null;

        var finally_start: ?u32 = effective_finally_block orelse blk: {
            if (has_finally) {
                const candidate = join_block orelse post_try_entry;
                // Validate that finally_start is not inside the protected try region
                // (which would indicate an early return path, not the actual finally)
                if (candidate) |cand| {
                    if (cand < handler_start and protected_set.isSet(cand)) {
                        break :blk null;
                    }
                }
                break :blk candidate;
            }
            break :blk null;
        };
        if (has_finally and except_count == 0) {
            if (post_try_entry) |entry| {
                if (entry < handler_start and !protected_set.isSet(entry) and !handler_set.isSet(entry)) {
                    finally_start = entry;
                }
            }
        }

        var try_end: u32 = handler_start;
        if (else_start) |start| {
            if (start < try_end) try_end = start;
        }
        if (finally_start) |start| {
            if (start < try_end) try_end = start;
        }

        var try_body = if (pattern.try_block < try_end)
            try self.decompileTryBody(pattern.try_block, try_end, loop_header, if (loop_header != null) null else visited)
        else
            &[_]*Stmt{};
        if (loop_header) |header_id| {
            scratch.normal_reach.reset();
            try self.collectReachableNoExceptionInto(
                pattern.try_block,
                handler_set,
                &scratch.normal_reach,
                &scratch.queue,
                false,
                allow_loop_back,
            );
            for (scratch.normal_reach.list.items) |bid| {
                if (bid >= self.cfg.blocks.len) continue;
                if (bid >= try_end) continue;
                if (!self.analyzer.inLoop(bid, header_id)) continue;
                if (!self.consumed.isSet(bid)) {
                    try self.consumed.set(self.allocator, bid);
                }
                if (visited) |v| {
                    v.set(bid);
                }
            }
        }

        const a = self.arena.allocator();

        var else_end: u32 = @as(u32, @intCast(self.cfg.blocks.len));
        if (exit_for_range) |exit| {
            if (else_start) |start| {
                if (exit > start) else_end = exit;
            } else {
                else_end = exit;
            }
        }
        if (loop_exit) |exit| {
            if (else_start) |start| {
                if (exit > start and exit < else_end) else_end = exit;
            }
        }
        if (else_start) |start| {
            if (handler_start > start and handler_start < else_end) else_end = handler_start;
            if (finally_start) |final_start| {
                if (final_start > start and final_start < else_end) else_end = final_start;
            }
            if (join_block) |join| {
                if (join > start and join < else_end) else_end = join;
            }
        }
        if (self.br_limit) |lim| {
            if (else_end > lim) else_end = lim;
        }

        var else_body = if (else_start) |start| blk: {
            if (start >= else_end) break :blk &[_]*Stmt{};
            if (loop_header) |header_id| {
                if (start < self.cfg.blocks.len and self.inLoopRelaxed(start, header_id, loop_exit)) {
                    var local_vis = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                    defer local_vis.deinit();
                    var skip_first_store = false;
                    var seed_pop = false;
                    const stop_id: ?u32 = if (else_end < self.cfg.blocks.len) else_end else null;
                    break :blk try self.decompileLoopBody(
                        start,
                        header_id,
                        &skip_first_store,
                        &seed_pop,
                        &local_vis,
                        stop_id,
                        0,
                        false,
                    );
                }
                break :blk try self.decompileBranchRange(start, else_end, &.{}, 0);
            }
            break :blk try self.decompileStructuredRange(start, else_end);
        } else &[_]*Stmt{};
        if (else_body.len == 1 and Decompiler.isReturnNone(else_body[0])) {
            else_body = &[_]*Stmt{};
        }
        if (else_body.len > 0) {
            if (exit_for_range) |exit_id| {
                if (self.blockIsReturnNone(exit_id)) {
                    else_body = try self.trimTrailingReturnNone(else_body);
                }
            }
        }
        var tail_start: ?u32 = force_tail;
        if (else_start) |start| {
            if (else_body.len == 0 and !self.blockIsReturnNone(start)) {
                tail_start = start;
                else_start = null;
            }
        }
        if (self.trace_decisions and self.trace_file != null) {
            const ev = .{
                .kind = "try_else",
                .block = pattern.try_block,
                .else_start = else_start,
                .else_end = else_end,
                .else_len = else_body.len,
                .tail_start = tail_start,
            };
            try self.writeTrace(ev);
        }
        if (loop_header) |header_id| {
            if (else_start) |start| {
                var bid = start;
                while (bid < else_end and bid < self.cfg.blocks.len) : (bid += 1) {
                    if (!self.inLoopRelaxed(bid, header_id, loop_exit)) continue;
                    if (!self.consumed.isSet(bid)) {
                        try self.consumed.set(self.allocator, bid);
                    }
                    if (visited) |v| {
                        v.set(bid);
                    }
                }
            }
        }
        if (else_start) |start| {
            var bid = start;
            while (bid < else_end and bid < self.cfg.blocks.len) : (bid += 1) {
                if (!self.consumed.isSet(bid)) {
                    try self.consumed.set(self.allocator, bid);
                }
            }
        }

        if (loop_header) |header_id| {
            if (else_start) |start| {
                var needs_break = false;
                var bid = start;
                while (bid < else_end and bid < self.cfg.blocks.len) : (bid += 1) {
                    const exit = self.analyzer.detectLoopExit(bid, &[_]u32{header_id});
                    if (exit == .break_stmt or self.loopBlockLeadsToBreak(bid, header_id)) {
                        needs_break = true;
                        break;
                    }
                }
                if (needs_break) {
                    if (else_body.len == 0) {
                        const br = try self.makeBreak();
                        const body = try self.arena.allocator().alloc(*Stmt, 1);
                        body[0] = br;
                        else_body = body;
                    } else {
                        const last = else_body[else_body.len - 1];
                        const terminal = switch (last.*) {
                            .break_stmt, .return_stmt, .raise_stmt, .continue_stmt => true,
                            else => false,
                        };
                        if (!terminal) {
                            const br = try self.makeBreak();
                            const body = try self.arena.allocator().alloc(*Stmt, else_body.len + 1);
                            std.mem.copyForwards(*Stmt, body[0..else_body.len], else_body);
                            body[else_body.len] = br;
                            else_body = body;
                        }
                    }
                }
            }
        }
        if (!try_break and loop_header != null) {
            const header_id = loop_header.?;
            if (self.tryHasInlineBreak(pattern.try_block, handler_start, header_id)) {
                try_break = true;
            }
        }
        if (try_break) {
            var has_term = false;
            if (try_body.len > 0) {
                const last = try_body[try_body.len - 1];
                has_term = switch (last.*) {
                    .break_stmt, .continue_stmt, .return_stmt, .raise_stmt => true,
                    else => false,
                };
            }
            if (!has_term) {
                const br = try self.makeBreak();
                const body = try a.alloc(*Stmt, try_body.len + 1);
                if (try_body.len > 0) {
                    std.mem.copyForwards(*Stmt, body[0..try_body.len], try_body);
                }
                body[try_body.len] = br;
                try_body = body;
            }
            else_body = &[_]*Stmt{};
        } else if (loop_header != null and else_body.len == 1 and
            (else_body[0].* == .break_stmt or else_body[0].* == .continue_stmt))
        {
            const body = try a.alloc(*Stmt, try_body.len + 1);
            if (try_body.len > 0) {
                std.mem.copyForwards(*Stmt, body[0..try_body.len], try_body);
            }
            body[try_body.len] = else_body[0];
            try_body = body;
            else_body = &[_]*Stmt{};
        }

        var final_end: u32 = @as(u32, @intCast(self.cfg.blocks.len));
        if (exit_for_range) |exit| {
            if (finally_start) |start| {
                if (exit > start) final_end = exit;
            } else {
                final_end = exit;
            }
        }
        if (finally_start) |final_start| {
            if (handler_start > final_start and handler_start < final_end) {
                var include_handler = false;
                if (has_finally and handler_blocks.items.len > 0 and handler_blocks.items[0] == handler_start and handler_final.items.len > 0 and handler_final.items[0]) {
                    include_handler = try self.reachableNoExceptionAllowHandlers(
                        final_start,
                        handler_start,
                        &scratch.normal_reach,
                        &scratch.queue,
                        allow_loop_back,
                    );
                }
                if (!include_handler) {
                    final_end = handler_start;
                }
            }
        }

        var final_body = if (finally_start) |start| blk: {
            if (start >= final_end) break :blk &[_]*Stmt{};
            var init_stack: []const StackValue = &.{};
            if (start < self.stack_in.len) {
                if (self.stack_in[start]) |entry| {
                    init_stack = entry;
                }
            }
            if (init_stack.len > 0) {
                break :blk try self.decompileStructuredRangeWithStackAllowHandlers(start, final_end, init_stack);
            }
            var exc_stack: [3]StackValue = undefined;
            for (&exc_stack) |*slot| {
                const placeholder = try a.create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                slot.* = .{ .expr = placeholder };
            }
            break :blk try self.decompileStructuredRangeWithStackAllowHandlers(start, final_end, &exc_stack);
        } else &[_]*Stmt{};
        if (self.trace_decisions and self.trace_file != null) {
            const ev = .{
                .kind = "try_final",
                .block = pattern.try_block,
                .finally_start = finally_start,
                .final_len = final_body.len,
            };
            try self.writeTrace(ev);
        }

        if (final_body.len > 0 and final_body[final_body.len - 1].* == .return_stmt) {
            var try_term = false;
            if (try_body.len > 0) {
                try_term = self.stmtIsTerminal(try_body[try_body.len - 1]);
            }
            if (!try_term) {
                var finally_has_return = false;
                for (handler_blocks.items, 0..) |hid, idx| {
                    if (!handler_final.items[idx]) continue;
                    if (try self.finallyHandlerHasReturn(hid, handler_set, scratch)) {
                        finally_has_return = true;
                        break;
                    }
                }
                if (!finally_has_return) {
                    const ret_stmt = final_body[final_body.len - 1];
                    if (ret_stmt.return_stmt.value) |val| {
                        if (self.isPlaceholderExpr(val)) {
                            const expr = self.recoverTryRetExpr(pattern.try_block) catch |err| switch (err) {
                                error.PatternNoMatch => null,
                                else => return err,
                            };
                            if (expr) |e| {
                                ret_stmt.return_stmt.value = e;
                            }
                        }
                    } else {
                        const expr = self.recoverTryRetExpr(pattern.try_block) catch |err| switch (err) {
                            error.PatternNoMatch => null,
                            else => return err,
                        };
                        if (expr) |e| {
                            ret_stmt.return_stmt.value = e;
                        }
                    }
                    const new_body = try a.alloc(*Stmt, try_body.len + 1);
                    if (try_body.len > 0) {
                        std.mem.copyForwards(*Stmt, new_body[0..try_body.len], try_body);
                    }
                    new_body[try_body.len] = ret_stmt;
                    try_body = new_body;
                    final_body = final_body[0 .. final_body.len - 1];
                }
            }
        }

        var next_block: u32 = final_end;
        if (next_block < try_end) next_block = try_end;
        if (else_start) |start| {
            if (start > next_block) next_block = start;
        }
        if (exit_for_range) |exit| {
            if (exit > next_block) next_block = exit;
        }
        const last_handler = handler_blocks.items[handler_blocks.items.len - 1];
        if (next_block <= last_handler) {
            next_block = last_handler + 1;
        }
        if (handler_tail) |tail| {
            if (next_block <= tail) {
                if (handler_tail_start == null or handler_tail_start.? > tail) {
                    next_block = tail + 1;
                }
            }
        }
        if (else_start != null and else_end > next_block) {
            next_block = else_end;
        }
        if (tail_start) |start| {
            if (next_block > start) next_block = start;
        }
        if (handler_tail_start) |start| {
            if (next_block > start) next_block = start;
        }
        if (self.trace_decisions and self.trace_file != null) {
            const ev = .{
                .kind = "try_next",
                .block = pattern.try_block,
                .next_block = next_block,
                .try_end = try_end,
                .handler_start = handler_start,
            };
            try self.writeTrace(ev);
        }
        if (self.br_limit) |lim| {
            if (next_block > lim) next_block = lim;
        }
        const loop_has_tail = if (loop_header) |header_id|
            next_block < self.cfg.blocks.len and next_block != header_id and self.analyzer.inLoop(next_block, header_id)
        else
            false;

        if (else_body.len > 0 and next_block >= self.cfg.blocks.len) {
            if (Decompiler.isReturnNone(else_body[else_body.len - 1])) {
                else_body = try self.trimTrailingReturnNone(else_body);
            }
        }

        var handler_nodes: std.ArrayListUnmanaged(ast.ExceptHandler) = .{};
        errdefer {
            for (handler_nodes.items) |*h| {
                if (h.type) |t| {
                    t.deinit(a);
                    a.destroy(t);
                }
                if (h.body.len > 0) a.free(h.body);
            }
            handler_nodes.deinit(a);
        }
        if (except_count > 0) {
            try handler_nodes.ensureTotalCapacity(a, except_count);
        }

        var seen_bare = false;
        for (handler_blocks.items, 0..) |hid, idx| {
            if (handler_final.items[idx]) continue;
            const has_next_handler = idx + 1 < handler_blocks.items.len;
            const next_handler = if (has_next_handler) handler_blocks.items[idx + 1] else null;
            var handler_end = blk: {
                const next_id = next_handler orelse (exit_block orelse @as(u32, @intCast(self.cfg.blocks.len)));
                if (finally_start) |start| {
                    if (start > hid and start < next_id) break :blk start;
                }
                break :blk next_id;
            };

            const info = try self.extractHandlerHeader(hid);
            if (handler_end <= info.body_block) {
                handler_end = @intCast(self.cfg.blocks.len);
            }
            if (!has_next_handler and handler_end < self.cfg.blocks.len and handler_reach.isSet(handler_end)) {
                if (finally_start == null or handler_end < finally_start.?) {
                    if (handler_tail_start) |start| {
                        if (start > handler_end) {
                            handler_end = start;
                        }
                    } else if (join_block) |join| {
                        if (join > handler_end) {
                            handler_end = join;
                        }
                    } else {
                        var scan: u32 = handler_end;
                        while (scan < self.cfg.blocks.len and handler_reach.isSet(scan)) : (scan += 1) {}
                        handler_end = scan;
                    }
                }
            }
            var body_end = handler_end;
            var scan_block = info.body_block;
            while (scan_block < body_end and scan_block < self.cfg.blocks.len) {
                const scan_blk = &self.cfg.blocks[scan_block];
                var found_pop_except = false;
                for (scan_blk.instructions) |inst| {
                    if (inst.opcode == .POP_EXCEPT) {
                        found_pop_except = true;
                        break;
                    }
                }
                if (found_pop_except) {
                    if (scan_blk.terminator()) |term| {
                        if (term.isUnconditionalJump()) {
                            if (term.jumpTarget(self.cfg.version)) |toff| {
                                if (self.cfg.blockAtOffset(toff)) |tid| {
                                    const resolved = self.resolveJumpOnlyBlock(tid);
                                    if (resolved < info.body_block or resolved >= handler_end) {
                                        body_end = scan_block + 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (scan_blk.predecessors.len == 0 or scan_blk.is_exception_handler or
                        try self.postDominates(scan_block, info.body_block))
                    {
                        body_end = scan_block + 1;
                    }
                    break;
                }
                scan_block += 1;
            }
            if (join_block) |join| {
                if (join > info.body_block and join < body_end) {
                    body_end = join;
                }
            } else if (post_try_entry) |entry| {
                scratch.normal_reach.reset();
                try self.collectReachableNoExceptionInto(
                    entry,
                    handler_set,
                    &scratch.normal_reach,
                    &scratch.queue,
                    false,
                    allow_loop_back,
                );
                var scan_norm = info.body_block + 1;
                while (scan_norm < body_end and scan_norm < self.cfg.blocks.len) : (scan_norm += 1) {
                    if (scratch.normal_reach.isSet(scan_norm)) {
                        body_end = scan_norm;
                        break;
                    }
                }
            }
            if (loop_header != null and body_end > info.body_block + 1) {
                const limit = @min(body_end, @as(u32, @intCast(self.cfg.blocks.len)));
                var reach = try self.reachableNoLoopBack(info.body_block, limit, null);
                defer reach.deinit();
                var max_block: u32 = info.body_block;
                var it = reach.iterator(.{});
                while (it.next()) |bit| {
                    const bid: u32 = @intCast(bit);
                    if (bid > max_block) max_block = bid;
                }
                const reach_end = max_block + 1;
                if (reach_end < body_end) body_end = reach_end;
            }
            if (self.trace_decisions and self.trace_file != null) {
                const ev = .{
                    .kind = "try_handler",
                    .try_block = pattern.try_block,
                    .handler = hid,
                    .body_block = info.body_block,
                    .body_end = body_end,
                    .skip = info.skip,
                };
                try self.writeTrace(ev);
            }
            var body = try self.decompileHandlerBody(info.body_block, body_end, info.skip_first_store, info.skip);
            if (body.len == 0 and (info.skip_first_store or info.skip > 0)) {
                body = try self.decompileHandlerBody(info.body_block, body_end, false, 0);
            }
            if (body.len == 0) {
                body = try self.decompileHandlerBodyLinear(info.body_block, body_end, info.skip);
            }
            body = try self.trimExceptionCleanup(body, info.name);
            body = try self.stripDuplicateCleanupPairs(body);
            body = try self.rewriteAwaitReturn(body);
            body = try self.rewriteHandlerReturnExpr(body, info.body_block, body_end);
            body = try self.stripNestedExceptionCleanup(body, info.name);
            body = try self.moveReturnNoneIntoElse(body);
            if (info.name) |handler_name| {
                if (body.len > 0) {
                    const first = body[0];
                    if (first.* == .assign and first.assign.targets.len == 1) {
                        const target = first.assign.targets[0];
                        if (target.* == .name and std.mem.eql(u8, target.name.id, handler_name) and
                            self.isPlaceholderExpr(first.assign.value))
                        {
                            body = body[1..];
                        }
                    }
                }
            }
            if (body.len == 1 and body[0].* == .try_stmt) {
                const inner = body[0].try_stmt;
                const final_is_empty = inner.finalbody.len == 0 or (inner.finalbody.len == 1 and inner.finalbody[0].* == .pass);
                if (inner.handlers.len == 0 and inner.else_body.len == 0 and final_is_empty) {
                    body = inner.body;
                }
            }
            var handler_name = info.name;
            if (handler_name == null and body.len > 0) {
                const first = body[0];
                if (first.* == .assign and first.assign.targets.len == 1) {
                    const target = first.assign.targets[0];
                    if (target.* == .name and self.isPlaceholderExpr(first.assign.value)) {
                        handler_name = target.name.id;
                        body = body[1..];
                    }
                }
            }
            const header_id_opt = loop_header orelse self.innermostLoopHeader(info.body_block);
            if (header_id_opt) |header_id| {
                if (handler_name) |hn| {
                    if (self.handlerIsContinue(info.body_block, body_end, header_id)) {
                        body = try self.rewriteHandlerContinueCleanup(body, hn);
                    }
                }
                var explicit_continue = self.handlerHasExplicitContinue(info.body_block, handler_end, header_id);
                if (!explicit_continue and loop_has_tail and self.handlerHasContinueJump(info.body_block, handler_end, header_id)) {
                    explicit_continue = true;
                }
                if (try self.rewriteHandlerExplicitContinue(body)) |new_body| {
                    body = new_body;
                } else if (explicit_continue) {
                    var needs_continue = true;
                    if (body.len > 0) {
                        const last = body[body.len - 1];
                        switch (last.*) {
                            .break_stmt, .continue_stmt => needs_continue = false,
                            else => {
                                if (self.stmtIsTerminal(last)) needs_continue = false;
                            },
                        }
                    }
                    if (needs_continue) {
                        const cont = try self.makeContinue();
                        const body_next = try a.alloc(*Stmt, body.len + 1);
                        if (body.len > 0) {
                            std.mem.copyForwards(*Stmt, body_next[0..body.len], body);
                        }
                        body_next[body.len] = cont;
                        body = body_next;
                    }
                }
                if (!explicit_continue and self.handlerHasBreakJump(info.body_block, handler_end, header_id)) {
                    var needs_break = true;
                    if (body.len > 0) {
                        const last = body[body.len - 1];
                        switch (last.*) {
                            .break_stmt, .continue_stmt, .return_stmt, .raise_stmt => needs_break = false,
                            else => {
                                if (self.stmtIsTerminal(last)) needs_break = false;
                            },
                        }
                    }
                    if (needs_break) {
                        const br = try self.makeBreak();
                        const body_next = try a.alloc(*Stmt, body.len + 1);
                        if (body.len > 0) {
                            std.mem.copyForwards(*Stmt, body_next[0..body.len], body);
                        }
                        body_next[body.len] = br;
                        body = body_next;
                    }
                }
                if (!explicit_continue and body.len > 0 and body[body.len - 1].* == .continue_stmt) {
                    body = body[0 .. body.len - 1];
                }
                if (loop_has_tail and body.len == 0 and self.handlerIsContinue(info.body_block, body_end, header_id)) {
                    const cont = try self.makeContinue();
                    const body_one = try a.alloc(*Stmt, 1);
                    body_one[0] = cont;
                    body = body_one;
                }
            }
            const is_bare = info.exc_type == null;
            if (is_bare and seen_bare and isEmptyHandlerBody(body)) {
                continue;
            }
            if (is_bare) seen_bare = true;

            try handler_nodes.append(a, .{
                .type = info.exc_type,
                .name = handler_name,
                .body = body,
            });
        }

        if (try_body.len == 1 and try_body[0].* == .return_stmt) {
            const ret_val = try_body[0].return_stmt.value;
            if (ret_val) |rv| {
                if (rv.* == .call) {
                    for (handler_nodes.items) |*h| {
                        if (h.body.len == 0) continue;
                        const first = h.body[0];
                        if (first.* != .expr_stmt) continue;
                        const first_val = first.expr_stmt.value;
                        if (first_val.* == .call and ast.exprEqual(first_val, rv)) {
                            h.body = h.body[1..];
                        }
                    }
                }
            }
        }
        for (handler_nodes.items) |*h| {
            if (h.body.len < 2) continue;
            const last = h.body[h.body.len - 1];
            if (!Decompiler.isReturnNone(last)) continue;
            const prev = h.body[h.body.len - 2];
            if (self.stmtIsTerminal(prev)) {
                h.body = h.body[0 .. h.body.len - 1];
            }
        }
        for (handler_nodes.items) |*h| {
            var body = h.body;
            var i: usize = 0;
            while (i + 1 < body.len) : (i += 1) {
                const cur = body[i];
                if (cur.* != .if_stmt) continue;
                var ifs = &cur.if_stmt;
                if (ifs.else_body.len != 0) continue;
                if (ifs.body.len == 0) continue;
                const last_then = ifs.body[ifs.body.len - 1];
                if (!self.stmtIsTerminal(last_then)) continue;
                const next = body[i + 1];
                if (!self.stmtIsTerminal(next)) continue;
                if (next.* == .raise_stmt and next.raise_stmt.exc == null and next.raise_stmt.cause == null) {
                    continue;
                }
                const else_stmts = try a.alloc(*Stmt, 1);
                else_stmts[0] = next;
                ifs.else_body = else_stmts;
                const new_body = try a.alloc(*Stmt, body.len - 1);
                std.mem.copyForwards(*Stmt, new_body[0 .. i + 1], body[0 .. i + 1]);
                if (i + 2 < body.len) {
                    std.mem.copyForwards(*Stmt, new_body[i + 1 ..], body[i + 2 ..]);
                }
                body = new_body;
                h.body = body;
            }
        }
        for (handler_nodes.items) |*h| {
            if (try self.rewriteHandlerContinueTail(h.body)) |new_body| {
                h.body = new_body;
            }
        }

        for (handler_reach.list.items) |hid| {
            if (effective_exit) |exit_id| {
                if (hid == exit_id) continue;
            }
            if (post_try_entry) |entry_id| {
                if (hid == entry_id) continue;
                if (scratch.normal_reach.isSet(hid)) continue;
            }
            if (join_block) |join_id| {
                if (hid == join_id) continue;
            }
            if (handler_tail_start) |start| {
                if (hid >= start) continue;
            }
            if (loop_header) |header_id| {
                if (hid >= next_block and self.analyzer.inLoop(hid, header_id)) continue;
            }
            if (!self.consumed.isSet(hid)) {
                try self.consumed.set(self.allocator, hid);
            }
        }

        const handlers_slice = handler_nodes.items;
        const stmt = try a.create(Stmt);
        stmt.* = .{
            .try_stmt = .{
                .body = try_body,
                .handlers = handlers_slice,
                .else_body = else_body,
                .finalbody = final_body,
            },
        };
        try self.normalizeTryFinalbody(stmt);
        return .{ .stmt = stmt, .next_block = next_block };
    }

    fn findWithPopNext(self: *Decompiler, body_block: u32, cleanup_block: u32) ?u32 {
        var cur = body_block;
        var steps: usize = 0;
        while (cur < self.cfg.blocks.len and steps < 32) : (steps += 1) {
            const blk = &self.cfg.blocks[cur];
            if (!blk.is_exception_handler) {
                var has_pop = false;
                for (blk.instructions) |inst| {
                    if (inst.opcode == .POP_BLOCK) {
                        has_pop = true;
                        break;
                    }
                }
                if (has_pop) {
                    var next: ?u32 = null;
                    for (blk.successors) |edge| {
                        if (edge.edge_type == .normal) {
                            next = edge.target;
                            break;
                        }
                    }
                    if (next) |next_id| {
                        if (next_id < self.cfg.blocks.len) {
                            const next_blk = &self.cfg.blocks[next_id];
                            for (next_blk.instructions) |inst| {
                                if (inst.opcode == .RETURN_VALUE or inst.opcode == .RETURN_CONST) {
                                    return null;
                                }
                            }
                        }
                    }
                    return next;
                }
            }
            var next_norm: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == .normal) {
                    next_norm = edge.target;
                    break;
                }
            }
            if (next_norm) |next_id| {
                if (next_id == cleanup_block) break;
                cur = next_id;
                continue;
            }
            break;
        }
        return null;
    }

    fn findWithNormalExit(self: *Decompiler, body_block: u32, cleanup_block: u32) ?u32 {
        if (self.findWithPopNext(body_block, cleanup_block)) |nb| {
            const next_blk = &self.cfg.blocks[nb];
            var after: ?u32 = null;
            for (next_blk.successors) |edge| {
                if (edge.edge_type == .normal) {
                    after = edge.target;
                    break;
                }
            }
            return after orelse nb;
        }
        return null;
    }

    fn decompileWith(self: *Decompiler, pattern: ctrl.WithPattern) DecompileError!PatternResult {
        const a = self.arena.allocator();
        const setup = &self.cfg.blocks[pattern.setup_block];
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();

        var is_async = false;
        var optional_vars: ?*Expr = null;
        var context_expr: ?*Expr = null;

        // Python 3.14+ uses LOAD_SPECIAL; legacy uses SETUP_WITH
        // Capture the context expression before COPY/LOAD_SPECIAL/SETUP_WITH
        for (setup.instructions) |inst| {
            switch (inst.opcode) {
                .BEFORE_ASYNC_WITH => is_async = true,
                .SETUP_ASYNC_WITH => is_async = true,
                else => {},
            }

            // Capture context expression right before COPY/LOAD_SPECIAL/SETUP_WITH (clone, don't pop)
            if ((inst.opcode == .COPY or inst.opcode == .LOAD_SPECIAL or inst.opcode == .SETUP_WITH or inst.opcode == .SETUP_ASYNC_WITH) and context_expr == null) {
                if (sim.stack.peekExpr()) |top_expr| {
                    context_expr = try ast.cloneExpr(a, top_expr);
                }
            }

            // Stop at LOAD_SPECIAL/SETUP_WITH - rest is just method binding or with body
            if (inst.opcode == .LOAD_SPECIAL or inst.opcode == .SETUP_WITH or inst.opcode == .SETUP_ASYNC_WITH or inst.opcode == .BEFORE_WITH or inst.opcode == .BEFORE_ASYNC_WITH) {
                break;
            }

            try sim.simulate(inst);
        }

        if (context_expr == null) {
            context_expr = try self.tryExtractWithContextFromPred(pattern.setup_block);
        }
        if (try self.tryRecoverTernaryAtMerge(pattern.setup_block)) |rec| {
            context_expr = rec.expr;
        }

        // In Python 3.14+, the variable binding (STORE_NAME) is in the body block
        // Check first instruction of body block for the binding
        if (pattern.body_block < self.cfg.blocks.len) {
            const body = &self.cfg.blocks[pattern.body_block];
            if (body.instructions.len > 0) {
                const first = body.instructions[0];
                switch (first.opcode) {
                    .STORE_FAST => {
                        if (sim.getLocal(first.arg)) |name| {
                            optional_vars = try self.makeName(name, .store);
                        }
                    },
                    .STORE_NAME, .STORE_GLOBAL => {
                        if (sim.getName(first.arg)) |name| {
                            optional_vars = try self.makeName(name, .store);
                        }
                    },
                    else => {},
                }
            }
        }

        const ctx_expr = context_expr orelse try sim.stack.popExpr();

        const item = try a.alloc(ast.WithItem, 1);
        item[0] = .{
            .context_expr = ctx_expr,
            .optional_vars = optional_vars,
        };

        var body_end: u32 = pattern.body_block + 1;

        // Decompile body without try-pattern detection; with cleanup adds exception edges.
        var body: []const *Stmt = &.{};
        if (pattern.body_block < self.cfg.blocks.len) {
            var init_stack: []const StackValue = &.{};
            if (pattern.body_block < self.stack_in.len) {
                if (self.stack_in[pattern.body_block]) |entry| {
                    init_stack = entry;
                }
            }
            if (init_stack.len == 0) {
                const exit_expr = try self.makeName("__with_exit__", .load);
                const seed = try a.alloc(StackValue, 2);
                seed[0] = .{ .expr = exit_expr };
                seed[1] = .unknown;
                init_stack = seed;
            }

            body_end = pattern.cleanup_block;
            if (body_end <= pattern.body_block) body_end = pattern.exit_block;
            if (body_end <= pattern.body_block) body_end = pattern.body_block + 1;
            if (self.findWithPopNext(pattern.body_block, pattern.cleanup_block)) |nb| {
                if (nb > pattern.body_block and nb < body_end) {
                    body_end = nb;
                }
            }

            var body_slice = try self.decompileStructuredRangeWithStackAllowHandlers(pattern.body_block, body_end, init_stack);
            if (optional_vars) |opt| {
                if (body_slice.len > 0 and body_slice[0].* == .assign) {
                    const assign = body_slice[0].assign;
                    if (assign.targets.len == 1 and ast.exprEqual(assign.targets[0], opt)) {
                        body_slice = body_slice[1..];
                    }
                }
            }
            body = body_slice;
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{
            .with_stmt = .{
                .items = item,
                .body = body,
                .type_comment = null,
                .is_async = is_async,
            },
        };

        // Calculate exit block - skip past all with-related blocks
        // For a with statement, we need to skip: setup, body, normal cleanup, and exception handlers
        var exit = pattern.exit_block;
        // Make sure we skip past body and cleanup blocks
        if (pattern.body_block >= exit) exit = pattern.body_block + 1;
        if (pattern.cleanup_block >= exit) exit = pattern.cleanup_block + 1;
        // Find the highest exception handler block and skip past it
        if (pattern.cleanup_block < self.cfg.blocks.len) {
            const cleanup_blk = &self.cfg.blocks[pattern.cleanup_block];
            for (cleanup_blk.successors) |edge| {
                if (edge.target >= exit) exit = edge.target + 1;
            }
        }

        if (self.findWithNormalExit(pattern.body_block, pattern.cleanup_block)) |normal_exit| {
            if (normal_exit >= body_end) {
                exit = normal_exit;
            }
        }

        return .{ .stmt = stmt, .next_block = exit };
    }

    fn tryExtractWithContextFromPred(self: *Decompiler, setup_block: u32) DecompileError!?*Expr {
        const a = self.arena.allocator();
        if (setup_block >= self.cfg.blocks.len) return null;
        const setup = &self.cfg.blocks[setup_block];

        for (setup.predecessors) |pred_id| {
            const pred = &self.cfg.blocks[pred_id];
            var has_normal = false;
            for (pred.successors) |edge| {
                if (edge.edge_type == .normal and edge.target == setup_block) {
                    has_normal = true;
                    break;
                }
            }
            if (!has_normal) continue;

            var pred_sim = self.initSim(a, a, self.code, self.version);
            defer pred_sim.deinit();
            pred_sim.lenient = true;
            pred_sim.stack.allow_underflow = true;

            var ok = true;
            for (pred.instructions) |inst| {
                if (inst.opcode == .NOT_TAKEN) continue;
                // If the block ends in a jump, don't simulate past it.
                if (inst.isUnconditionalJump()) {
                    break;
                }
                pred_sim.simulate(inst) catch |err| {
                    if (self.isSoftSimErr(err)) {
                        ok = false;
                        break;
                    }
                    return err;
                };
                if (inst.isConditionalJump()) break;
            }

            if (!ok) continue;
            if (pred_sim.stack.len() == 0) continue;
            const top = pred_sim.stack.items.items[pred_sim.stack.items.items.len - 1];
            if (top == .expr) {
                return try ast.cloneExpr(a, top.expr);
            }
        }

        return null;
    }

    fn decompileMatch(self: *Decompiler, pattern: ctrl.MatchPattern) DecompileError!PatternResult {
        defer pattern.deinit(self.allocator);
        // Get subject from subject block - simulate only until MATCH_* or COPY
        const subj_block = &self.cfg.blocks[pattern.subject_block];
        const a = self.arena.allocator();
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();

        // Check if this is a class pattern (has MATCH_CLASS)
        var has_match_class = false;
        for (subj_block.instructions) |inst| {
            if (inst.opcode == .MATCH_CLASS) {
                has_match_class = true;
                break;
            }
        }

        var prev_was_load = false;
        for (subj_block.instructions) |inst| {
            // Stop before MATCH_* opcodes or COPY
            if (inst.opcode == .MATCH_SEQUENCE or inst.opcode == .MATCH_MAPPING or
                inst.opcode == .MATCH_CLASS or inst.opcode == .COPY)
            {
                break;
            }
            // Stop before STORE if previous was LOAD (pattern binding, not assignment)
            if ((inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST) and prev_was_load) {
                break;
            }
            // Stop before STORE_FAST_LOAD_FAST (pattern binding in Python 3.14+)
            if (inst.opcode == .STORE_FAST_LOAD_FAST) {
                break;
            }
            // For class patterns, stop after first load (the subject)
            // because subsequent loads are for class and attrs
            if (has_match_class and prev_was_load and
                (inst.opcode == .LOAD_GLOBAL or inst.opcode == .LOAD_NAME or inst.opcode == .LOAD_CONST))
            {
                break;
            }
            prev_was_load = inst.opcode == .LOAD_NAME or inst.opcode == .LOAD_FAST or
                inst.opcode == .LOAD_FAST_BORROW;
            try sim.simulate(inst);
        }

        const subject = try sim.stack.popExpr();

        // Decompile each case
        var cases: std.ArrayListUnmanaged(ast.MatchCase) = .{};
        errdefer cases.deinit(a);
        var extra_blocks: std.ArrayListUnmanaged(u32) = .{};
        defer extra_blocks.deinit(self.allocator);

        var idx: usize = 0;
        while (idx < pattern.case_blocks.len) {
            const case_block_id = pattern.case_blocks[idx];
            if (try self.tryMatchOrChain(pattern.case_blocks, idx)) |chain| {
                const res = try self.decompileMatchCase(chain.guard_block, false);
                var case = res.case;
                const or_pat = try a.create(ast.Pattern);
                or_pat.* = .{ .match_or = chain.patterns };
                case.pattern = or_pat;
                try cases.append(a, case);
                const tail_res = try self.decompileMatchCase(chain.last_block, false);
                try extra_blocks.append(self.allocator, chain.guard_block);
                if (res.fallback_block) |fb| {
                    try extra_blocks.append(self.allocator, fb);
                }
                var fb_body_opt = res.fallback_body;
                var fb_block_opt = res.fallback_block;
                if (fb_body_opt == null) {
                    fb_body_opt = tail_res.fallback_body;
                    fb_block_opt = tail_res.fallback_block;
                }
                if (fb_body_opt == null) {
                    if (chain.fail_block) |fb| {
                        var resolved = fb;
                        if (self.jumpTargetIfJumpOnly(fb, true)) |target| {
                            resolved = target;
                        }
                        if (indexOfBlock(pattern.case_blocks, resolved) == null) {
                            var fb_end: u32 = resolved + 1;
                            const fblk = &self.cfg.blocks[resolved];
                            if (fblk.successors.len > 0) {
                                fb_end = fblk.successors[0].target;
                            }
                            if (resolved < fb_end) {
                                const pop_need = self.maxLeadPop(resolved, fb_end);
                                if (pop_need > 0) {
                                    if (pop_need == 1) {
                                        var init_stack = [_]StackValue{.unknown};
                                        fb_body_opt = try self.decompileStructuredRangeWithStack(resolved, fb_end, init_stack[0..]);
                                    } else {
                                        const init_stack = try self.allocator.alloc(StackValue, pop_need);
                                        defer self.allocator.free(init_stack);
                                        for (init_stack) |*sv| sv.* = .unknown;
                                        fb_body_opt = try self.decompileStructuredRangeWithStack(resolved, fb_end, init_stack);
                                    }
                                } else {
                                    fb_body_opt = try self.decompileStructuredRange(resolved, fb_end);
                                }
                                fb_block_opt = resolved;
                            }
                        }
                    }
                }
                if (fb_body_opt) |fb_body| {
                    if (fb_block_opt != null and pattern.exit_block != null and
                        fb_block_opt.? == pattern.exit_block.? and
                        fb_body.len == 1 and Decompiler.isReturnNone(fb_body[0]))
                    {
                        idx = chain.next_idx;
                        continue;
                    }
                    if (fb_block_opt) |fb| {
                        const is_case = indexOfBlock(pattern.case_blocks, fb) != null and fb != chain.last_block;
                        if (!is_case) {
                            const p = try a.create(ast.Pattern);
                            p.* = .{ .match_as = .{ .pattern = null, .name = null } };
                            try cases.append(a, .{
                                .pattern = p,
                                .guard = null,
                                .body = fb_body,
                            });
                        }
                    } else {
                        var has_wc = false;
                        for (cases.items) |c| {
                            if (isWildcardPattern(c.pattern)) {
                                has_wc = true;
                                break;
                            }
                        }
                        if (!has_wc) {
                            const p = try a.create(ast.Pattern);
                            p.* = .{ .match_as = .{ .pattern = null, .name = null } };
                            try cases.append(a, .{
                                .pattern = p,
                                .guard = null,
                                .body = fb_body,
                            });
                        }
                    }
                }
                idx = chain.next_idx;
                continue;
            }

            // First case has COPY, subsequent cases reuse subject on stack
            const has_copy = idx == 0;
            const res = try self.decompileMatchCase(case_block_id, has_copy);
            try cases.append(a, res.case);
            if (res.fallback_block) |fb| {
                try extra_blocks.append(self.allocator, fb);
            }
            if (res.fallback_body) |fb_body| {
                if (res.fallback_block != null and pattern.exit_block != null and
                    res.fallback_block.? == pattern.exit_block.? and
                    fb_body.len == 1 and Decompiler.isReturnNone(fb_body[0]))
                {
                    idx += 1;
                    continue;
                }
                if (res.fallback_block) |fb| {
                    if (indexOfBlock(pattern.case_blocks, fb) == null) {
                        const p = try a.create(ast.Pattern);
                        p.* = .{ .match_as = .{ .pattern = null, .name = null } };
                        try cases.append(a, .{
                            .pattern = p,
                            .guard = null,
                            .body = fb_body,
                        });
                    }
                } else {
                    var has_wc = false;
                    for (cases.items) |c| {
                        if (isWildcardPattern(c.pattern)) {
                            has_wc = true;
                            break;
                        }
                    }
                    if (!has_wc) {
                        const p = try a.create(ast.Pattern);
                        p.* = .{ .match_as = .{ .pattern = null, .name = null } };
                        try cases.append(a, .{
                            .pattern = p,
                            .guard = null,
                            .body = fb_body,
                        });
                    }
                }
            }
            idx += 1;
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{
            .match_stmt = .{
                .subject = subject,
                .cases = try cases.toOwnedSlice(self.arena.allocator()),
            },
        };

        // Find the highest block ID used - must account for all blocks touched:
        // - pattern blocks (multi-block patterns)
        // - body blocks
        // - fail blocks (conditional_false targets)
        // Use exit_block if available, otherwise find max from all successors
        if (pattern.exit_block) |exit| {
            return .{ .stmt = stmt, .next_block = exit };
        }

        // No explicit exit - find max block by examining all case block successors
        var max_block = pattern.subject_block;
        for (pattern.case_blocks) |cb| {
            if (cb > max_block) max_block = cb;
            const blk = &self.cfg.blocks[cb];
            for (blk.successors) |edge| {
                if (edge.target > max_block) max_block = edge.target;
            }
        }
        for (extra_blocks.items) |cb| {
            if (cb > max_block) max_block = cb;
            const blk = &self.cfg.blocks[cb];
            for (blk.successors) |edge| {
                if (edge.target > max_block) max_block = edge.target;
            }
        }
        return .{ .stmt = stmt, .next_block = max_block + 1 };
    }

    fn matchPreludeEnd(self: *Decompiler, block: *const cfg_mod.BasicBlock) usize {
        _ = self;
        var prev_was_load = false;
        for (block.instructions, 0..) |inst, i| {
            if (inst.opcode == .MATCH_SEQUENCE or inst.opcode == .MATCH_MAPPING or
                inst.opcode == .MATCH_CLASS or inst.opcode == .MATCH_KEYS or inst.opcode == .COPY)
            {
                return i;
            }
            if ((inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST) and prev_was_load) {
                return i;
            }
            if (inst.opcode == .STORE_FAST_LOAD_FAST) {
                return i;
            }
            prev_was_load = inst.opcode == .LOAD_NAME or inst.opcode == .LOAD_FAST or
                inst.opcode == .LOAD_GLOBAL or inst.opcode == .LOAD_DEREF or
                inst.opcode == .LOAD_FAST_BORROW;
        }
        return block.instructions.len;
    }

    fn emitMatchPrelude(
        self: *Decompiler,
        block_id: u32,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!void {
        if (block_id >= self.cfg.blocks.len) return;
        const block = &self.cfg.blocks[block_id];
        var first_idx: ?usize = null;
        for (block.instructions, 0..) |inst, i| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            first_idx = i;
            break;
        }
        if (first_idx == null) return;
        const first_op = block.instructions[first_idx.?].opcode;
        if (first_op == .POP_TOP or first_op == .JUMP_FORWARD or first_op == .JUMP_BACKWARD or
            first_op == .JUMP_BACKWARD_NO_INTERRUPT or first_op == .JUMP_ABSOLUTE)
        {
            return;
        }
        const end_idx = self.matchPreludeEnd(block);
        if (end_idx == 0 or end_idx <= first_idx.?) return;
        var tmp = block.*;
        tmp.instructions = block.instructions[0..end_idx];
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        try self.processBlockWithSimAndSkip(&tmp, &sim, stmts, stmts_allocator, 0);
    }

    fn guardExprFromBlock(self: *Decompiler, block: *const cfg_mod.BasicBlock) DecompileError!?*Expr {
        var guard: ?*Expr = null;
        var guard_start: ?usize = null;

        // Store-based guard patterns
        for (block.instructions, 0..) |inst, i| {
            if (inst.opcode == .STORE_FAST_STORE_FAST) {
                for (block.instructions[i + 1 ..], i + 1..) |next, j| {
                    if (next.opcode == .LOAD_GLOBAL or next.opcode == .LOAD_NAME or
                        next.opcode == .LOAD_FAST_BORROW or next.opcode == .LOAD_FAST or
                        next.opcode == .LOAD_FAST_BORROW_LOAD_FAST_BORROW or next.opcode == .LOAD_FAST_LOAD_FAST)
                    {
                        guard_start = j;
                        break;
                    }
                }
                break;
            } else if (inst.opcode == .STORE_FAST_LOAD_FAST) {
                const a = self.arena.allocator();
                var sim = self.initSim(a, a, self.code, self.version);
                defer sim.deinit();

                const load_idx = inst.arg & 0xF;
                if (load_idx < self.code.varnames.len) {
                    const name = self.code.varnames[load_idx];
                    const expr = try self.makeName(name, .load);
                    try sim.stack.push(.{ .expr = expr });

                    for (block.instructions[i + 1 ..]) |g_inst| {
                        if (g_inst.opcode == .POP_JUMP_IF_FALSE or g_inst.opcode == .POP_JUMP_FORWARD_IF_FALSE) break;
                        try sim.simulate(g_inst);
                    }
                    guard = try sim.stack.popExpr();
                }
                return guard;
            } else if (inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST) {
                var found_guard = false;
                for (block.instructions[i + 1 ..], i + 1..) |next_inst, j| {
                    if (next_inst.opcode == .LOAD_NAME or next_inst.opcode == .LOAD_FAST or
                        next_inst.opcode == .LOAD_FAST_BORROW or next_inst.opcode == .LOAD_FAST_BORROW_LOAD_FAST_BORROW or
                        next_inst.opcode == .LOAD_FAST_LOAD_FAST)
                    {
                        const same_var = if (inst.opcode == .STORE_NAME and next_inst.opcode == .LOAD_NAME)
                            inst.arg == next_inst.arg
                        else if (inst.opcode == .STORE_FAST and (next_inst.opcode == .LOAD_FAST or next_inst.opcode == .LOAD_FAST_BORROW))
                            inst.arg == next_inst.arg
                        else
                            false;

                        if (same_var) {
                            const a = self.arena.allocator();
                            var sim = self.initSim(a, a, self.code, self.version);
                            defer sim.deinit();
                            for (block.instructions[j..]) |g_inst| {
                                if (g_inst.opcode == .POP_JUMP_IF_FALSE or g_inst.opcode == .POP_JUMP_FORWARD_IF_FALSE) break;
                                try sim.simulate(g_inst);
                            }
                            guard = try sim.stack.popExpr();
                            found_guard = true;
                            break;
                        }
                    }
                }
                if (found_guard) return guard;
            }
        }

        if (guard_start) |start| {
            const a = self.arena.allocator();
            var sim = self.initSim(a, a, self.code, self.version);
            defer sim.deinit();
            for (block.instructions[start..]) |g_inst| {
                if (g_inst.opcode == .POP_JUMP_IF_FALSE or g_inst.opcode == .POP_JUMP_FORWARD_IF_FALSE) break;
                try sim.simulate(g_inst);
            }
            guard = try sim.stack.popExpr();
            if (guard != null) return guard;
        }

        // Guard-only block: no pattern ops, no GET_LEN, but has conditional jump
        var has_get_len = false;
        var has_pat_op = false;
        var has_cond = false;
        if (block.terminator()) |term| {
            has_cond = ctrl.Analyzer.isConditionalJump(undefined, term.opcode);
        }
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .GET_LEN => has_get_len = true,
                .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS, .UNPACK_SEQUENCE, .STORE_FAST_STORE_FAST, .STORE_FAST_LOAD_FAST, .STORE_FAST, .STORE_NAME => has_pat_op = true,
                else => {},
            }
        }

        if (!has_cond or has_pat_op or has_get_len) return null;

        var start_idx: ?usize = null;
        for (block.instructions, 0..) |inst, i| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            start_idx = i;
            break;
        }
        if (start_idx == null) return null;

        const a = self.arena.allocator();
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();
        for (block.instructions[start_idx.?..]) |g_inst| {
            if (g_inst.opcode == .POP_JUMP_IF_FALSE or g_inst.opcode == .POP_JUMP_FORWARD_IF_FALSE) break;
            try sim.simulate(g_inst);
        }
        return try sim.stack.popExpr();
    }

    fn guardStartInBlock(self: *Decompiler, block: *const cfg_mod.BasicBlock) DecompileError!?GuardStart {
        var has_cond = false;
        if (block.terminator()) |term| {
            has_cond = ctrl.Analyzer.isConditionalJump(undefined, term.opcode);
        }

        var seen_match = false;
        for (block.instructions, 0..) |inst, i| {
            switch (inst.opcode) {
                .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS, .UNPACK_SEQUENCE, .COPY, .GET_LEN, .STORE_FAST_LOAD_FAST, .STORE_FAST_STORE_FAST => seen_match = true,
                .COMPARE_OP => seen_match = true,
                else => {},
            }
            if (inst.opcode == .STORE_FAST_LOAD_FAST) {
                if (!seen_match) continue;
                const load_idx = inst.arg & 0xF;
                if (load_idx >= self.code.varnames.len) return null;
                const name = self.code.varnames[load_idx];
                const expr = try self.makeName(name, .load);
                return .{ .idx = i + 1, .preload = expr };
            }
            if (inst.opcode == .STORE_FAST_STORE_FAST) {
                if (!seen_match) continue;
                var preload: ?*Expr = null;
                var j = i + 1;
                var seen_literal = false;
                while (j < block.instructions.len) : (j += 1) {
                    const op = block.instructions[j].opcode;
                    if (op == .NOT_TAKEN or op == .CACHE) continue;
                    if (op == .STORE_FAST_LOAD_FAST) {
                        const load_idx = block.instructions[j].arg & 0xF;
                        if (load_idx < self.code.varnames.len) {
                            const name = self.code.varnames[load_idx];
                            preload = try self.makeName(name, .load);
                        }
                        continue;
                    }
                    // LOAD_CONST before LOAD_FAST suggests f-string body, not guard
                    if (op == .LOAD_CONST or op == .LOAD_SMALL_INT) {
                        seen_literal = true;
                        continue;
                    }
                    // Body ops - this isn't a guard, it's case body code
                    if (op == .FORMAT_SIMPLE or op == .BUILD_STRING or
                        op == .BINARY_SUBSCR or op == .RETURN_VALUE or op == .RETURN_CONST)
                    {
                        break;
                    }
                    if (op == .LOAD_GLOBAL or op == .LOAD_NAME or op == .LOAD_FAST or
                        op == .LOAD_FAST_BORROW or op == .LOAD_FAST_LOAD_FAST or
                        op == .LOAD_FAST_BORROW_LOAD_FAST_BORROW)
                    {
                        // If we saw a literal before the load, it's likely f-string body
                        if (seen_literal) break;
                        return .{ .idx = j, .preload = preload };
                    }
                    if (ctrl.Analyzer.isConditionalJump(undefined, op)) break;
                }
                return null;
            }
            if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME) {
                if (!seen_match) continue;
                const store_idx = inst.arg;
                var j = i + 1;
                while (j < block.instructions.len) : (j += 1) {
                    const op = block.instructions[j].opcode;
                    if (op == .NOT_TAKEN or op == .CACHE) continue;
                    // Body ops - this isn't a guard, it's case body code
                    if (op == .FORMAT_SIMPLE or op == .BUILD_STRING or
                        op == .BINARY_OP or op == .BINARY_SUBSCR or
                        op == .RETURN_VALUE or op == .RETURN_CONST)
                    {
                        break;
                    }
                    // Guard starts at first load - could be LOAD_GLOBAL for function call
                    // e.g., `case str() as s if len(s) > 5` starts guard at LOAD_GLOBAL len
                    if (op == .LOAD_GLOBAL or op == .LOAD_NAME) {
                        return .{ .idx = j, .preload = null };
                    }
                    if (inst.opcode == .STORE_FAST and (op == .LOAD_FAST or op == .LOAD_FAST_BORROW) and block.instructions[j].arg == store_idx) {
                        return .{ .idx = j, .preload = null };
                    }
                    if (inst.opcode == .STORE_NAME and op == .LOAD_NAME and block.instructions[j].arg == store_idx) {
                        return .{ .idx = j, .preload = null };
                    }
                    if (ctrl.Analyzer.isConditionalJump(undefined, op)) break;
                }
            }
        }

        // Guard-only block: no pattern ops, no GET_LEN, but has conditional jump
        var has_pat_op = false;
        var has_match_op = false;
        var has_get_len = false;
        var has_lit_cmp = false;
        var has_copy = false;
        var has_subject_load = false;
        var prev_get_len = false;
        for (block.instructions, 0..) |inst, idx| {
            switch (inst.opcode) {
                .GET_LEN => {
                    has_get_len = true;
                    prev_get_len = true;
                },
                .COPY => has_copy = true,
                .LOAD_FAST, .LOAD_FAST_BORROW, .LOAD_FAST_LOAD_FAST, .LOAD_FAST_BORROW_LOAD_FAST_BORROW, .LOAD_NAME, .LOAD_GLOBAL, .LOAD_DEREF => has_subject_load = true,
                .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS => {
                    has_match_op = true;
                    has_pat_op = true;
                },
                .UNPACK_SEQUENCE, .STORE_FAST_STORE_FAST, .STORE_FAST_LOAD_FAST, .STORE_FAST, .STORE_NAME => has_pat_op = true,
                .LOAD_CONST, .LOAD_SMALL_INT => {
                    if (!prev_get_len) {
                        var j = idx + 1;
                        while (j < block.instructions.len) : (j += 1) {
                            const op = block.instructions[j].opcode;
                            if (op == .NOT_TAKEN or op == .CACHE) continue;
                            if (op == .COMPARE_OP) has_lit_cmp = true;
                            break;
                        }
                    }
                    prev_get_len = false;
                },
                else => prev_get_len = false,
            }
        }
        if (has_lit_cmp and (has_copy or !has_subject_load)) {
            has_pat_op = true;
        }
        if (has_cond and has_lit_cmp and !has_match_op and !has_get_len) {
            var seen_match2 = false;
            var first_jump: ?usize = null;
            for (block.instructions, 0..) |inst, i| {
                if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                switch (inst.opcode) {
                    .COMPARE_OP, .COPY, .LOAD_CONST, .LOAD_SMALL_INT => seen_match2 = true,
                    else => {},
                }
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode) and seen_match2) {
                    first_jump = i;
                    break;
                }
            }
            if (first_jump) |fj| {
                var has_second = false;
                var k = fj + 1;
                while (k < block.instructions.len) : (k += 1) {
                    const op = block.instructions[k].opcode;
                    if (op == .NOT_TAKEN or op == .CACHE) continue;
                    if (ctrl.Analyzer.isConditionalJump(undefined, op)) {
                        has_second = true;
                        break;
                    }
                }
                if (has_second) {
                    var j = fj + 1;
                    while (j < block.instructions.len) : (j += 1) {
                        const op = block.instructions[j].opcode;
                        if (op == .NOT_TAKEN or op == .CACHE) continue;
                        return .{ .idx = j, .preload = null };
                    }
                }
            }
        }
        if (!has_cond or has_pat_op or has_get_len) return null;

        for (block.instructions, 0..) |inst, i| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            return .{ .idx = i, .preload = null };
        }
        return null;
    }

    fn guardCondFromJump(self: *Decompiler, cond: *Expr, op: Opcode) DecompileError!*Expr {
        return switch (op) {
            .POP_JUMP_IF_TRUE,
            .POP_JUMP_FORWARD_IF_TRUE,
            .POP_JUMP_BACKWARD_IF_TRUE,
            => try self.invertConditionExpr(cond),
            .POP_JUMP_IF_NONE,
            .POP_JUMP_FORWARD_IF_NONE,
            .POP_JUMP_BACKWARD_IF_NONE,
            => try self.makeIsNoneCompare(cond, true),
            .POP_JUMP_IF_NOT_NONE,
            .POP_JUMP_FORWARD_IF_NOT_NONE,
            .POP_JUMP_BACKWARD_IF_NOT_NONE,
            => try self.makeIsNoneCompare(cond, false),
            else => cond,
        };
    }

    fn guardCondForBranch(self: *Decompiler, cond: *Expr, op: Opcode, taken: bool) DecompileError!*Expr {
        return switch (op) {
            .POP_JUMP_IF_FALSE,
            .POP_JUMP_FORWARD_IF_FALSE,
            .POP_JUMP_BACKWARD_IF_FALSE,
            .JUMP_IF_FALSE,
            => if (taken) try self.invertConditionExpr(cond) else cond,
            .POP_JUMP_IF_TRUE,
            .POP_JUMP_FORWARD_IF_TRUE,
            .POP_JUMP_BACKWARD_IF_TRUE,
            .JUMP_IF_TRUE,
            => if (taken) cond else try self.invertConditionExpr(cond),
            .POP_JUMP_IF_NONE,
            .POP_JUMP_FORWARD_IF_NONE,
            .POP_JUMP_BACKWARD_IF_NONE,
            => if (taken) try self.makeIsNoneCompare(cond, true) else try self.makeIsNoneCompare(cond, false),
            .POP_JUMP_IF_NOT_NONE,
            .POP_JUMP_FORWARD_IF_NOT_NONE,
            .POP_JUMP_BACKWARD_IF_NOT_NONE,
            => if (taken) try self.makeIsNoneCompare(cond, false) else try self.makeIsNoneCompare(cond, true),
            else => if (taken) cond else try self.invertConditionExpr(cond),
        };
    }

    fn isTrueJump(self: *Decompiler, op: Opcode) bool {
        _ = self;
        return switch (op) {
            .POP_JUMP_IF_TRUE,
            .POP_JUMP_FORWARD_IF_TRUE,
            .POP_JUMP_BACKWARD_IF_TRUE,
            .JUMP_IF_TRUE,
            => true,
            else => false,
        };
    }

    fn elseIsJumpTarget(self: *Decompiler, op: Opcode) bool {
        _ = self;
        return switch (op) {
            .POP_JUMP_IF_FALSE,
            .POP_JUMP_FORWARD_IF_FALSE,
            .POP_JUMP_BACKWARD_IF_FALSE,
            .JUMP_IF_FALSE,
            .POP_JUMP_IF_NONE,
            .POP_JUMP_FORWARD_IF_NONE,
            .POP_JUMP_BACKWARD_IF_NONE,
            .POP_JUMP_IF_NOT_NONE,
            .POP_JUMP_FORWARD_IF_NOT_NONE,
            .POP_JUMP_BACKWARD_IF_NOT_NONE,
            .JUMP_IF_FALSE_OR_POP,
            => true,
            else => false,
        };
    }

    fn isContGuard(self: *Decompiler, stmt: *const Stmt, cond: *const Expr) bool {
        _ = self;
        if (stmt.* != .if_stmt) return false;
        const ifs = stmt.if_stmt;
        if (ifs.else_body.len != 0) return false;
        if (ifs.body.len != 1 or ifs.body[0].* != .continue_stmt) return false;
        return ast.exprEqual(ifs.condition, cond);
    }

    fn bodyAllContinue(self: *Decompiler, body: []const *Stmt) bool {
        _ = self;
        if (body.len == 0) return false;
        for (body) |stmt| {
            if (stmt.* != .continue_stmt) return false;
        }
        return true;
    }

    fn isFalseJump(self: *Decompiler, op: Opcode) bool {
        _ = self;
        return switch (op) {
            .POP_JUMP_IF_FALSE,
            .POP_JUMP_FORWARD_IF_FALSE,
            .POP_JUMP_BACKWARD_IF_FALSE,
            .JUMP_IF_FALSE,
            => true,
            else => false,
        };
    }

    fn invertJumpOpcode(self: *Decompiler, op: Opcode) Opcode {
        _ = self;
        return switch (op) {
            .POP_JUMP_IF_TRUE => .POP_JUMP_IF_FALSE,
            .POP_JUMP_FORWARD_IF_TRUE => .POP_JUMP_FORWARD_IF_FALSE,
            .POP_JUMP_BACKWARD_IF_TRUE => .POP_JUMP_BACKWARD_IF_FALSE,
            .JUMP_IF_TRUE => .JUMP_IF_FALSE,
            .POP_JUMP_IF_FALSE => .POP_JUMP_IF_TRUE,
            .POP_JUMP_FORWARD_IF_FALSE => .POP_JUMP_FORWARD_IF_TRUE,
            .POP_JUMP_BACKWARD_IF_FALSE => .POP_JUMP_BACKWARD_IF_TRUE,
            .JUMP_IF_FALSE => .JUMP_IF_TRUE,
            else => op,
        };
    }

    fn guardExprsFromBlocks(self: *Decompiler, blocks: []const u32) DecompileError![]const *Expr {
        var guard_exprs: std.ArrayListUnmanaged(*Expr) = .{};
        errdefer guard_exprs.deinit(self.allocator);

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();

        for (blocks) |bid| {
            const blk = &self.cfg.blocks[bid];
            const start = (try self.guardStartInBlock(blk)) orelse continue;
            if (start.preload) |e| {
                try sim.stack.push(.{ .expr = e });
            }

            var i = start.idx;
            while (i < blk.instructions.len) : (i += 1) {
                const inst = blk.instructions[i];
                switch (inst.opcode) {
                    .NOT_TAKEN, .CACHE => continue,
                    .STORE_FAST_LOAD_FAST => {
                        const load_idx = inst.arg & 0xF;
                        if (load_idx < self.code.varnames.len) {
                            const name = self.code.varnames[load_idx];
                            const expr = try self.makeName(name, .load);
                            try sim.stack.push(.{ .expr = expr });
                        } else {
                            try sim.stack.push(.unknown);
                        }
                        continue;
                    },
                    .STORE_FAST_STORE_FAST, .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS, .UNPACK_SEQUENCE, .UNPACK_EX, .GET_LEN, .STORE_FAST, .STORE_NAME => continue,
                    .POP_TOP => {
                        if (sim.stack.len() > 0) {
                            _ = sim.stack.pop();
                        }
                        continue;
                    },
                    .POP_JUMP_IF_TRUE,
                    .POP_JUMP_IF_FALSE,
                    .POP_JUMP_IF_NONE,
                    .POP_JUMP_IF_NOT_NONE,
                    .POP_JUMP_FORWARD_IF_TRUE,
                    .POP_JUMP_FORWARD_IF_FALSE,
                    .POP_JUMP_FORWARD_IF_NONE,
                    .POP_JUMP_FORWARD_IF_NOT_NONE,
                    .POP_JUMP_BACKWARD_IF_TRUE,
                    .POP_JUMP_BACKWARD_IF_FALSE,
                    .POP_JUMP_BACKWARD_IF_NONE,
                    .POP_JUMP_BACKWARD_IF_NOT_NONE,
                    => {
                        const cond = try sim.stack.popExpr();
                        const final_cond = try self.guardCondFromJump(cond, inst.opcode);
                        try guard_exprs.append(self.allocator, final_cond);
                        continue;
                    },
                    .JUMP_FORWARD, .JUMP_BACKWARD, .JUMP_ABSOLUTE => continue,
                    else => {
                        try sim.simulate(inst);
                    },
                }
            }
        }

        const out = try self.arena.allocator().dupe(*Expr, guard_exprs.items);
        guard_exprs.deinit(self.allocator);
        return out;
    }

    fn isSimpleReturnBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        var has_return = false;
        for (blk.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) return false;
            switch (inst.opcode) {
                .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS, .COPY, .STORE_FAST_LOAD_FAST, .STORE_FAST_STORE_FAST => return false,
                .RETURN_VALUE, .RETURN_CONST => has_return = true,
                else => {},
            }
        }
        return has_return;
    }

    fn succEdgeForJump(op: Opcode) cfg_mod.EdgeType {
        return switch (op) {
            .POP_JUMP_IF_TRUE,
            .POP_JUMP_FORWARD_IF_TRUE,
            .POP_JUMP_BACKWARD_IF_TRUE,
            .POP_JUMP_IF_NOT_NONE,
            .POP_JUMP_FORWARD_IF_NOT_NONE,
            .POP_JUMP_BACKWARD_IF_NOT_NONE,
            .JUMP_IF_TRUE_OR_POP,
            .JUMP_IF_TRUE,
            => .conditional_false,
            else => .conditional_true,
        };
    }

    fn failEdgeForJump(op: Opcode) cfg_mod.EdgeType {
        return if (succEdgeForJump(op) == .conditional_true) .conditional_false else .conditional_true;
    }

    fn maxLeadPop(self: *Decompiler, start: u32, end: u32) usize {
        var max: usize = 0;
        var b = start;
        const limit = @min(end, @as(u32, @intCast(self.cfg.blocks.len)));
        while (b < limit) : (b += 1) {
            const blk = &self.cfg.blocks[b];
            var cnt: usize = 0;
            for (blk.instructions) |inst| {
                if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                if (inst.opcode == .POP_TOP) {
                    cnt += 1;
                    continue;
                }
                break;
            }
            if (cnt > max) max = cnt;
        }
        return max;
    }

    const GuardStart = struct {
        idx: usize,
        preload: ?*Expr,
    };

    fn makeIsNoneCompare(self: *Decompiler, value: *Expr, is_not: bool) DecompileError!*Expr {
        const a = self.arena.allocator();
        const none_expr = try ast.makeConstant(a, .{ .none = {} });
        const comparators = try a.alloc(*Expr, 1);
        comparators[0] = none_expr;
        const ops = try a.alloc(ast.CmpOp, 1);
        ops[0] = if (is_not) .is_not else .is;
        const expr = try a.create(Expr);
        expr.* = .{ .compare = .{ .left = value, .ops = ops, .comparators = comparators } };
        return expr;
    }

    fn invertCompareOp(op: ast.CmpOp) ?ast.CmpOp {
        return switch (op) {
            .eq => .not_eq,
            .not_eq => .eq,
            .lt => .gte,
            .lte => .gt,
            .gt => .lte,
            .gte => .lt,
            .is => .is_not,
            .is_not => .is,
            .in_ => .not_in,
            .not_in => .in_,
        };
    }

    fn invertConditionExpr(self: *Decompiler, expr: *Expr) DecompileError!*Expr {
        if (expr.* == .unary_op and expr.unary_op.op == .not_) {
            return expr.unary_op.operand;
        }
        if (expr.* == .compare) {
            const cmp = expr.compare;
            if (cmp.ops.len == 1 and cmp.comparators.len == 1) {
                if (invertCompareOp(cmp.ops[0])) |inv| {
                    const a = self.arena.allocator();
                    const ops = try a.alloc(ast.CmpOp, 1);
                    ops[0] = inv;
                    const comps = try a.alloc(*Expr, 1);
                    comps[0] = cmp.comparators[0];
                    const out = try a.create(Expr);
                    out.* = .{ .compare = .{ .left = cmp.left, .ops = ops, .comparators = comps } };
                    return out;
                }
            }
        }
        return ast.makeUnaryOp(self.arena.allocator(), .not_, expr);
    }

    fn sameExpr(self: *Decompiler, left: *const Expr, right: *const Expr) bool {
        _ = self;
        return ast.exprEqual(left, right);
    }

    fn sameAugAssignTarget(self: *Decompiler, target: *const Expr, left: *const Expr) bool {
        _ = self;
        return switch (target.*) {
            .name => left.* == .name and std.mem.eql(u8, target.name.id, left.name.id),
            .attribute => left.* == .attribute and std.mem.eql(u8, target.attribute.attr, left.attribute.attr) and
                ast.exprEqual(target.attribute.value, left.attribute.value),
            .subscript => left.* == .subscript and ast.exprEqual(target.subscript.value, left.subscript.value) and
                ast.exprEqual(target.subscript.slice, left.subscript.slice),
            else => ast.exprEqual(target, left),
        };
    }

    fn tryMakeAugAssign(
        self: *Decompiler,
        sim: *SimContext,
        target: *Expr,
        value: *Expr,
        force: bool,
    ) DecompileError!?*Stmt {
        if (value.* != .bin_op) return null;
        if (!force and !sim.isInplaceExpr(value)) return null;
        const binop = value.bin_op;
        if (!self.sameAugAssignTarget(target, binop.left)) return null;

        const a = self.arena.allocator();
        binop.left.deinit(a);
        a.destroy(binop.left);

        const stmt = try a.create(Stmt);
        stmt.* = .{ .aug_assign = .{
            .target = target,
            .op = binop.op,
            .value = binop.right,
        } };
        a.destroy(value);
        return stmt;
    }

    fn mergeCompareChain(self: *Decompiler, left: *Expr, right: *Expr) DecompileError!?*Expr {
        if (left.* != .compare or right.* != .compare) return null;
        const l = left.compare;
        const r = right.compare;
        if (l.comparators.len == 0 or r.comparators.len == 0) return null;
        const last = l.comparators[l.comparators.len - 1];
        if (!self.sameExpr(last, r.left)) return null;

        const a = self.arena.allocator();
        const ops = try a.alloc(ast.CmpOp, l.ops.len + r.ops.len);
        const comps = try a.alloc(*Expr, l.comparators.len + r.comparators.len);
        std.mem.copyForwards(ast.CmpOp, ops[0..l.ops.len], l.ops);
        std.mem.copyForwards(ast.CmpOp, ops[l.ops.len..], r.ops);
        std.mem.copyForwards(*Expr, comps[0..l.comparators.len], l.comparators);
        std.mem.copyForwards(*Expr, comps[l.comparators.len..], r.comparators);

        const expr = try a.create(Expr);
        expr.* = .{ .compare = .{ .left = l.left, .ops = ops, .comparators = comps } };
        return expr;
    }

    const ClassInfo = struct {
        cls: *Expr,
        attrs: []const []const u8,
    };

    const MatchCaseResult = struct {
        case: ast.MatchCase,
        fallback_body: ?[]const *Stmt,
        fallback_block: ?u32,
    };

    const SeqBuild = struct {
        expected: usize,
        items: std.ArrayListUnmanaged(*ast.Pattern) = .{},
        swap: bool = false,
    };

    fn constExprFromObj(self: *Decompiler, obj: pyc.Object) DecompileError!*Expr {
        const a = self.arena.allocator();
        return switch (obj) {
            .none => ast.makeConstant(a, .{ .none = {} }),
            .true_val => ast.makeConstant(a, .{ .true_ = {} }),
            .false_val => ast.makeConstant(a, .{ .false_ = {} }),
            .ellipsis => ast.makeConstant(a, .{ .ellipsis = {} }),
            .string => |s| ast.makeConstant(a, .{ .string = s }),
            .bytes => |b| ast.makeConstant(a, .{ .bytes = b }),
            .int => |i| switch (i) {
                .small => |v| ast.makeConstant(a, .{ .int = v }),
                .big => |b| ast.makeConstant(a, .{ .big_int = try b.clone(a) }),
            },
            .float => |f| ast.makeConstant(a, .{ .float = f }),
            .complex => |c| ast.makeConstant(a, .{ .complex = .{ .real = c.real, .imag = c.imag } }),
            else => error.InvalidBlock,
        };
    }

    fn keyExprsFromObj(self: *Decompiler, obj: pyc.Object) DecompileError!?[]const *Expr {
        const a = self.arena.allocator();
        switch (obj) {
            .tuple => |items| {
                const exprs = try a.alloc(*Expr, items.len);
                for (items, 0..) |item, i| {
                    exprs[i] = try self.constExprFromObj(item);
                }
                return exprs;
            },
            else => return null,
        }
    }

    fn attrNamesFromObj(self: *Decompiler, obj: pyc.Object) DecompileError!?[]const []const u8 {
        const a = self.arena.allocator();
        switch (obj) {
            .tuple => |items| {
                const names = try a.alloc([]const u8, items.len);
                for (items, 0..) |item, i| {
                    switch (item) {
                        .string => |s| names[i] = try self.unmangleClassName(s),
                        else => return null,
                    }
                }
                return names;
            },
            else => return null,
        }
    }

    fn findAsName(self: *Decompiler, insts: []const cfg_mod.Instruction, start_idx: usize) ?[]const u8 {
        var i = start_idx + 1;
        while (i < insts.len) : (i += 1) {
            const op = insts[i].opcode;
            if (op == .NOT_TAKEN or op == .CACHE) continue;
            switch (op) {
                .POP_JUMP_IF_FALSE,
                .POP_JUMP_FORWARD_IF_FALSE,
                .POP_JUMP_IF_TRUE,
                .POP_JUMP_FORWARD_IF_TRUE,
                .POP_JUMP_IF_NONE,
                .POP_JUMP_FORWARD_IF_NONE,
                => break,
                .LOAD_FAST_BORROW,
                .LOAD_FAST_BORROW_LOAD_FAST_BORROW,
                .LOAD_FAST_LOAD_FAST,
                .LOAD_FAST,
                .LOAD_GLOBAL,
                .LOAD_NAME,
                => break,
                .STORE_FAST => return self.code.varnames[insts[i].arg],
                .STORE_NAME => return self.code.names[insts[i].arg],
                else => {},
            }
        }
        return null;
    }

    fn nextOp(insts: []const cfg_mod.Instruction, idx: usize) ?Opcode {
        var j = idx + 1;
        while (j < insts.len) : (j += 1) {
            const op = insts[j].opcode;
            if (op == .CACHE or op == .NOT_TAKEN) continue;
            return op;
        }
        return null;
    }

    fn indexOfBlock(blocks: []const u32, id: u32) ?usize {
        for (blocks, 0..) |b, i| {
            if (b == id) return i;
        }
        return null;
    }

    fn jumpTargetIfJumpOnly(self: *Decompiler, block_id: u32, allow_pop: bool) ?u32 {
        return self.jumpTargetIfJumpOnlyEdge(block_id, allow_pop, false);
    }

    fn jumpTargetIfJumpOnlyInst(self: *Decompiler, block_id: u32, allow_pop: bool) ?u32 {
        if (block_id >= self.cfg.blocks.len) return null;
        const blk = &self.cfg.blocks[block_id];
        if (blk.instructions.len == 0) return null;
        var jump_inst: ?decoder.Instruction = null;
        for (blk.instructions) |inst| {
            switch (inst.opcode) {
                .NOT_TAKEN, .CACHE, .POP_BLOCK, .POP_EXCEPT, .END_FINALLY, .END_FOR, .NOP => continue,
                .POP_TOP => if (allow_pop) continue else return null,
                .JUMP_FORWARD, .JUMP_BACKWARD, .JUMP_BACKWARD_NO_INTERRUPT, .JUMP_ABSOLUTE => {
                    if (jump_inst != null) return null;
                    jump_inst = inst;
                },
                else => return null,
            }
        }
        const inst = jump_inst orelse return null;
        const target_off = inst.jumpTarget(self.cfg.version) orelse return null;
        return self.cfg.blockAtOffset(target_off);
    }

    fn jumpTargetIfJumpOnlyEdge(
        self: *Decompiler,
        block_id: u32,
        allow_pop: bool,
        allow_loop: bool,
    ) ?u32 {
        if (block_id >= self.cfg.blocks.len) return null;
        const blk = &self.cfg.blocks[block_id];
        if (blk.instructions.len == 0) {
            for (blk.successors) |edge| {
                if (edge.edge_type == .normal or (allow_loop and edge.edge_type == .loop_back)) {
                    return edge.target;
                }
            }
            return null;
        }
        var saw_jump = false;
        for (blk.instructions) |inst| {
            switch (inst.opcode) {
                .NOT_TAKEN, .CACHE => continue,
                .POP_TOP => {
                    if (allow_pop) continue;
                    return null;
                },
                .JUMP_FORWARD, .JUMP_BACKWARD, .JUMP_ABSOLUTE => {
                    if (saw_jump) return null;
                    saw_jump = true;
                    continue;
                },
                else => return null,
            }
        }
        if (!saw_jump) return null;
        for (blk.successors) |edge| {
            if (edge.edge_type == .normal or (allow_loop and edge.edge_type == .loop_back)) {
                return edge.target;
            }
        }
        return null;
    }

    fn literalPatternFromBlock(self: *Decompiler, blk: *const cfg_mod.BasicBlock) DecompileError!?*ast.Pattern {
        const a = self.arena.allocator();
        var lit_expr: ?*Expr = null;
        for (blk.instructions) |inst| {
            switch (inst.opcode) {
                .MATCH_SEQUENCE, .MATCH_MAPPING, .MATCH_CLASS, .MATCH_KEYS, .GET_LEN => return null,
                .LOAD_SMALL_INT => {
                    lit_expr = try ast.makeConstant(a, .{ .int = @intCast(inst.arg) });
                },
                .LOAD_CONST => {
                    const obj = self.code.consts[inst.arg];
                    if (self.constExprFromObj(obj)) |expr| {
                        lit_expr = expr;
                    } else |err| switch (err) {
                        error.InvalidBlock => return null,
                        else => return err,
                    }
                },
                .COMPARE_OP => {
                    if (lit_expr) |v| {
                        const pat = try a.create(ast.Pattern);
                        pat.* = .{ .match_value = v };
                        return pat;
                    }
                },
                else => {},
            }
        }
        return null;
    }

    fn blocksEq(self: *Decompiler, a_id: u32, b_id: u32) bool {
        if (a_id >= self.cfg.blocks.len or b_id >= self.cfg.blocks.len) return false;
        const a_blk = &self.cfg.blocks[a_id];
        const b_blk = &self.cfg.blocks[b_id];
        var ai: usize = 0;
        var bi: usize = 0;
        while (true) {
            while (ai < a_blk.instructions.len) : (ai += 1) {
                const op = a_blk.instructions[ai].opcode;
                if (op == .NOT_TAKEN or op == .CACHE) continue;
                break;
            }
            while (bi < b_blk.instructions.len) : (bi += 1) {
                const op = b_blk.instructions[bi].opcode;
                if (op == .NOT_TAKEN or op == .CACHE) continue;
                break;
            }
            const a_end = ai >= a_blk.instructions.len;
            const b_end = bi >= b_blk.instructions.len;
            if (a_end or b_end) return a_end and b_end;
            const a_inst = a_blk.instructions[ai];
            const b_inst = b_blk.instructions[bi];
            if (a_inst.opcode != b_inst.opcode or a_inst.arg != b_inst.arg) return false;
            ai += 1;
            bi += 1;
        }
    }

    const OrChain = struct {
        guard_block: u32,
        next_idx: usize,
        patterns: []const *ast.Pattern,
        last_block: u32,
        fail_block: ?u32,
    };

    fn tryMatchOrChain(self: *Decompiler, case_blocks: []const u32, start_idx: usize) DecompileError!?OrChain {
        const a = self.arena.allocator();
        var patterns: std.ArrayListUnmanaged(*ast.Pattern) = .{};
        defer patterns.deinit(a);

        var success_target: ?u32 = null;
        var next_case_id: ?u32 = null;
        var last_fail: ?u32 = null;
        var idx = start_idx;
        while (idx < case_blocks.len) {
            const bid = case_blocks[idx];
            const blk = &self.cfg.blocks[bid];
            const pat = try self.literalPatternFromBlock(blk) orelse break;
            const term = blk.terminator() orelse break;
            if (!ctrl.Analyzer.isConditionalJump(undefined, term.opcode)) break;

            const succ_edge = succEdgeForJump(term.opcode);
            const fail_edge = failEdgeForJump(term.opcode);
            var true_block: ?u32 = null;
            var false_block: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == succ_edge) true_block = edge.target;
                if (edge.edge_type == fail_edge) false_block = edge.target;
            }
            if (true_block == null or false_block == null) break;
            last_fail = false_block.?;

            var true_target: u32 = true_block.?;
            if (self.jumpTargetIfJumpOnly(true_block.?, false)) |target| {
                true_target = target;
            }
            if (success_target == null) {
                success_target = true_target;
            } else if (!self.blocksEq(success_target.?, true_target)) {
                break;
            }

            try patterns.append(a, pat);

            const next_idx = indexOfBlock(case_blocks, false_block.?) orelse {
                if (self.jumpTargetIfJumpOnly(false_block.?, true)) |target| {
                    next_case_id = target;
                }
                break;
            };
            if (next_idx <= idx) break;
            idx = next_idx;
        }

        if (patterns.items.len < 2 or success_target == null) return null;
        var next_idx: usize = case_blocks.len;
        if (next_case_id) |next_id| {
            next_idx = indexOfBlock(case_blocks, next_id) orelse case_blocks.len;
        } else if (idx + 1 <= case_blocks.len) {
            next_idx = idx + 1;
        }
        const pats = try patterns.toOwnedSlice(a);
        return OrChain{
            .guard_block = success_target.?,
            .next_idx = next_idx,
            .patterns = pats,
            .last_block = case_blocks[idx],
            .fail_block = last_fail,
        };
    }

    fn isWildcardPattern(pat: *const ast.Pattern) bool {
        return switch (pat.*) {
            .match_as => |a| a.pattern == null and a.name == null,
            else => false,
        };
    }

    /// Returns how many instructions at the start of `block` are pattern-related
    /// (UNPACK_SEQUENCE + stores + POP_TOPs) for map/class pattern bindings.
    fn patternSkipCount(self: *Decompiler, block: *const cfg_mod.BasicBlock) usize {
        _ = self;
        var skip: usize = 0;
        var found_unpack = false;
        var unpack_count: usize = 0;
        var stores_done: usize = 0;

        for (block.instructions) |inst| {
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) {
                skip += 1;
                continue;
            }
            if (!found_unpack) {
                if (inst.opcode == .UNPACK_SEQUENCE) {
                    found_unpack = true;
                    unpack_count = @intCast(inst.arg);
                    skip += 1;
                    continue;
                }
                // No unpack at start - no pattern ops to skip
                return 0;
            }
            // After UNPACK_SEQUENCE, expect stores
            if (stores_done < unpack_count) {
                if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or inst.opcode == .STORE_DEREF) {
                    stores_done += 1;
                    skip += 1;
                    continue;
                }
                if (inst.opcode == .STORE_FAST_STORE_FAST) {
                    stores_done += 2;
                    skip += 1;
                    continue;
                }
                // Unexpected op - stop
                break;
            }
            // After stores, expect POP_TOPs (cleanup)
            if (inst.opcode == .POP_TOP) {
                skip += 1;
                continue;
            }
            // Reached actual body
            break;
        }
        return skip;
    }

    fn mapPatternFromBlocks(self: *Decompiler, blocks: []const u32) DecompileError!?*ast.Pattern {
        const a = self.arena.allocator();
        var keys: ?[]const *Expr = null;
        var val_block: ?u32 = null;

        for (blocks) |bid| {
            const blk = &self.cfg.blocks[bid];
            for (blk.instructions, 0..) |inst, i| {
                if (inst.opcode != .MATCH_KEYS) continue;
                var j = i;
                while (j > 0) {
                    j -= 1;
                    const op = blk.instructions[j].opcode;
                    if (op == .NOT_TAKEN or op == .CACHE) continue;
                    if (op == .LOAD_CONST) {
                        const obj = self.code.consts[blk.instructions[j].arg];
                        keys = try self.keyExprsFromObj(obj);
                        break;
                    }
                    if (op == .MATCH_MAPPING) break;
                }
                if (blk.terminator()) |term| {
                    const succ_edge = succEdgeForJump(term.opcode);
                    for (blk.successors) |edge| {
                        if (edge.edge_type == succ_edge) {
                            val_block = edge.target;
                            break;
                        }
                    }
                }
                break;
            }
            if (keys != null and val_block != null) break;
        }

        if (keys == null or val_block == null) return null;
        const k = keys.?;
        if (k.len == 0) return null;

        const vblk = &self.cfg.blocks[val_block.?];
        var unpack_idx: ?usize = null;
        var count: usize = 0;
        for (vblk.instructions, 0..) |inst, i| {
            if (inst.opcode == .UNPACK_SEQUENCE) {
                unpack_idx = i;
                count = @intCast(inst.arg);
                break;
            }
        }
        if (unpack_idx == null or count != k.len) return null;

        const pats = try a.alloc(*ast.Pattern, k.len);
        var filled: usize = 0;
        var i = unpack_idx.? + 1;
        while (i < vblk.instructions.len and filled < k.len) : (i += 1) {
            const op = vblk.instructions[i].opcode;
            if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
            if (op == .STORE_FAST or op == .STORE_NAME) {
                const name = if (op == .STORE_NAME)
                    self.code.names[vblk.instructions[i].arg]
                else
                    self.code.varnames[vblk.instructions[i].arg];
                const unmangled = try self.unmangleClassName(name);
                const p = try a.create(ast.Pattern);
                p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                pats[filled] = p;
                filled += 1;
                continue;
            }
            if (op == .STORE_FAST_STORE_FAST) {
                const idx1 = (vblk.instructions[i].arg >> 4) & 0xF;
                const idx2 = vblk.instructions[i].arg & 0xF;
                if (filled < k.len) {
                    const name1 = self.code.varnames[idx1];
                    const unmangled1 = try self.unmangleClassName(name1);
                    const p1 = try a.create(ast.Pattern);
                    p1.* = .{ .match_as = .{ .pattern = null, .name = unmangled1 } };
                    pats[filled] = p1;
                    filled += 1;
                }
                if (filled < k.len) {
                    const name2 = self.code.varnames[idx2];
                    const unmangled2 = try self.unmangleClassName(name2);
                    const p2 = try a.create(ast.Pattern);
                    p2.* = .{ .match_as = .{ .pattern = null, .name = unmangled2 } };
                    pats[filled] = p2;
                    filled += 1;
                }
                continue;
            }
            if (op == .LOAD_SMALL_INT or op == .LOAD_CONST) {
                const next_op = nextOp(vblk.instructions, i);
                if (next_op == .COMPARE_OP) {
                    const val_expr = if (op == .LOAD_SMALL_INT)
                        try ast.makeConstant(a, .{ .int = @intCast(vblk.instructions[i].arg) })
                    else
                        try self.constExprFromObj(self.code.consts[vblk.instructions[i].arg]);
                    const p = try a.create(ast.Pattern);
                    p.* = .{ .match_value = val_expr };
                    pats[filled] = p;
                    filled += 1;
                    continue;
                }
            }
            break;
        }

        if (filled != k.len) return null;
        const pat = try a.create(ast.Pattern);
        pat.* = .{ .match_mapping = .{ .keys = k, .patterns = pats, .rest = null } };
        return pat;
    }

    fn classPatternFromBlocks(self: *Decompiler, blocks: []const u32) DecompileError!?*ast.Pattern {
        const a = self.arena.allocator();
        var cls_expr: ?*Expr = null;
        var attrs: ?[]const []const u8 = null;
        var val_block: ?u32 = null;

        for (blocks) |bid| {
            const blk = &self.cfg.blocks[bid];
            var last_cls: ?*Expr = null;
            var last_attrs: ?[]const []const u8 = null;
            for (blk.instructions, 0..) |inst, i| {
                switch (inst.opcode) {
                    .LOAD_GLOBAL => {
                        // Python 3.11+ encodes name_idx in upper bits
                        const name_idx: usize = if (self.version.gte(3, 11)) inst.arg >> 1 else inst.arg;
                        if (name_idx < self.code.names.len) {
                            const name = self.code.names[name_idx];
                            last_cls = try self.makeName(name, .load);
                        }
                    },
                    .LOAD_NAME => {
                        if (inst.arg < self.code.names.len) {
                            const name = self.code.names[inst.arg];
                            last_cls = try self.makeName(name, .load);
                        }
                    },
                    .LOAD_FAST, .LOAD_FAST_BORROW => {
                        if (inst.arg < self.code.varnames.len) {
                            const name = self.code.varnames[inst.arg];
                            last_cls = try self.makeName(name, .load);
                        }
                    },
                    .LOAD_CONST => {
                        const obj = self.code.consts[inst.arg];
                        last_attrs = try self.attrNamesFromObj(obj);
                    },
                    .MATCH_CLASS => {
                        if (last_cls != null and last_attrs != null) {
                            cls_expr = last_cls;
                            attrs = last_attrs;
                            if (blk.terminator()) |term| {
                                const succ_edge = succEdgeForJump(term.opcode);
                                for (blk.successors) |edge| {
                                    if (edge.edge_type == succ_edge) {
                                        val_block = edge.target;
                                        break;
                                    }
                                }
                            }
                        }
                        _ = i;
                        break;
                    },
                    else => {},
                }
            }
            if (cls_expr != null and attrs != null and val_block != null) break;
        }

        if (cls_expr == null or attrs == null) return null;
        const attr_list = attrs.?;

        // For empty keyword attrs, check for positional captures via UNPACK_SEQUENCE
        if (attr_list.len == 0) {
            if (val_block) |vb| {
                const vblk = &self.cfg.blocks[vb];
                var unpack_count: usize = 0;
                var unpack_idx: ?usize = null;
                for (vblk.instructions, 0..) |inst, idx| {
                    if (inst.opcode == .UNPACK_SEQUENCE) {
                        unpack_count = @intCast(inst.arg);
                        unpack_idx = idx;
                        break;
                    }
                }
                if (unpack_count > 0 and unpack_idx != null) {
                    // Positional capture pattern like case int(x):
                    const pats = try a.alloc(*ast.Pattern, unpack_count);
                    var filled: usize = 0;
                    var i = unpack_idx.? + 1;
                    while (i < vblk.instructions.len and filled < unpack_count) : (i += 1) {
                        const op = vblk.instructions[i].opcode;
                        if (op == .NOT_TAKEN or op == .CACHE) continue;
                        if (op == .STORE_FAST or op == .STORE_NAME) {
                            const name = if (op == .STORE_NAME)
                                self.code.names[vblk.instructions[i].arg]
                            else
                                self.code.varnames[vblk.instructions[i].arg];
                            const unmangled = try self.unmangleClassName(name);
                            const p = try a.create(ast.Pattern);
                            p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                            pats[filled] = p;
                            filled += 1;
                            continue;
                        }
                        // STORE_FAST_LOAD_FAST used with guards - store index is in high nibble
                        if (op == .STORE_FAST_LOAD_FAST) {
                            const store_idx = (vblk.instructions[i].arg >> 4) & 0xF;
                            if (store_idx < self.code.varnames.len) {
                                const name = self.code.varnames[store_idx];
                                const unmangled = try self.unmangleClassName(name);
                                const p = try a.create(ast.Pattern);
                                p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                                pats[filled] = p;
                                filled += 1;
                                continue;
                            }
                        }
                        break;
                    }
                    if (filled == unpack_count) {
                        const pat = try a.create(ast.Pattern);
                        pat.* = .{ .match_class = .{
                            .cls = cls_expr.?,
                            .patterns = pats,
                            .kwd_attrs = &.{},
                            .kwd_patterns = &.{},
                        } };
                        return pat;
                    }
                } else if (unpack_count == 0 and unpack_idx != null) {
                    // Check for as binding: case int() as n
                    // UNPACK_SEQUENCE 0 followed by STORE_FAST is the as binding
                    var i = unpack_idx.? + 1;
                    while (i < vblk.instructions.len) : (i += 1) {
                        const op = vblk.instructions[i].opcode;
                        if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
                        if (op == .STORE_FAST or op == .STORE_NAME) {
                            const name = if (op == .STORE_NAME)
                                self.code.names[vblk.instructions[i].arg]
                            else
                                self.code.varnames[vblk.instructions[i].arg];
                            const unmangled = try self.unmangleClassName(name);
                            // Create inner class pattern
                            const cls_pat = try a.create(ast.Pattern);
                            cls_pat.* = .{ .match_class = .{
                                .cls = cls_expr.?,
                                .patterns = &.{},
                                .kwd_attrs = &.{},
                                .kwd_patterns = &.{},
                            } };
                            // Wrap in match_as
                            const as_pat = try a.create(ast.Pattern);
                            as_pat.* = .{ .match_as = .{ .pattern = cls_pat, .name = unmangled } };
                            return as_pat;
                        }
                        break;
                    }
                }
            }
            // Empty pattern (case int():)
            const pat = try a.create(ast.Pattern);
            pat.* = .{ .match_class = .{
                .cls = cls_expr.?,
                .patterns = &.{},
                .kwd_attrs = &.{},
                .kwd_patterns = &.{},
            } };
            return pat;
        }
        if (val_block == null) return null;

        const vblk = &self.cfg.blocks[val_block.?];
        var unpack_idx: ?usize = null;
        var count: usize = 0;
        for (vblk.instructions, 0..) |inst, i| {
            if (inst.opcode == .UNPACK_SEQUENCE) {
                unpack_idx = i;
                count = @intCast(inst.arg);
                break;
            }
        }
        if (unpack_idx == null or count != attr_list.len) return null;

        const pats = try a.alloc(*ast.Pattern, attr_list.len);
        var filled: usize = 0;
        var i = unpack_idx.? + 1;
        while (i < vblk.instructions.len and filled < attr_list.len) : (i += 1) {
            const op = vblk.instructions[i].opcode;
            if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
            if (op == .STORE_FAST or op == .STORE_NAME) {
                const name = if (op == .STORE_NAME)
                    self.code.names[vblk.instructions[i].arg]
                else
                    self.code.varnames[vblk.instructions[i].arg];
                const unmangled = try self.unmangleClassName(name);
                const p = try a.create(ast.Pattern);
                p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                pats[filled] = p;
                filled += 1;
                continue;
            }
            if (op == .STORE_FAST_STORE_FAST and attr_list.len == 2) {
                const idx1 = (vblk.instructions[i].arg >> 4) & 0xF;
                const idx2 = vblk.instructions[i].arg & 0xF;
                const name1 = self.code.varnames[idx1];
                const name2 = self.code.varnames[idx2];
                const unmangled1 = try self.unmangleClassName(name1);
                const unmangled2 = try self.unmangleClassName(name2);
                const p1 = try a.create(ast.Pattern);
                p1.* = .{ .match_as = .{ .pattern = null, .name = unmangled1 } };
                const p2 = try a.create(ast.Pattern);
                p2.* = .{ .match_as = .{ .pattern = null, .name = unmangled2 } };
                pats[filled] = p1;
                pats[filled + 1] = p2;
                filled += 2;
                continue;
            }
            // STORE_FAST_LOAD_FAST used with guards - store index in high nibble
            if (op == .STORE_FAST_LOAD_FAST) {
                const store_idx = (vblk.instructions[i].arg >> 4) & 0xF;
                if (store_idx < self.code.varnames.len) {
                    const name = self.code.varnames[store_idx];
                    const unmangled = try self.unmangleClassName(name);
                    const p = try a.create(ast.Pattern);
                    p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                    pats[filled] = p;
                    filled += 1;
                    continue;
                }
            }
            if (op == .LOAD_SMALL_INT or op == .LOAD_CONST) {
                const next_op = nextOp(vblk.instructions, i);
                if (next_op == .COMPARE_OP) {
                    const val_expr = if (op == .LOAD_SMALL_INT)
                        try ast.makeConstant(a, .{ .int = @intCast(vblk.instructions[i].arg) })
                    else
                        try self.constExprFromObj(self.code.consts[vblk.instructions[i].arg]);
                    const p = try a.create(ast.Pattern);
                    p.* = .{ .match_value = val_expr };
                    pats[filled] = p;
                    filled += 1;
                    continue;
                }
            }
            break;
        }

        if (filled != attr_list.len) {
            var all_insts: std.ArrayListUnmanaged(cfg_mod.Instruction) = .{};
            defer all_insts.deinit(self.allocator);
            for (blocks) |bid| {
                const blk = &self.cfg.blocks[bid];
                try all_insts.appendSlice(self.allocator, blk.instructions);
            }

            var u_idx: ?usize = null;
            var u_count: usize = 0;
            for (all_insts.items, 0..) |inst, j| {
                if (inst.opcode == .UNPACK_SEQUENCE) {
                    u_idx = j;
                    u_count = @intCast(inst.arg);
                    break;
                }
            }
            if (u_idx == null or u_count != attr_list.len) return null;

            const pats2 = try a.alloc(*ast.Pattern, attr_list.len);
            var filled2: usize = 0;
            var k: usize = u_idx.? + 1;
            while (k < all_insts.items.len and filled2 < attr_list.len) : (k += 1) {
                const op = all_insts.items[k].opcode;
                if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
                if (op == .COMPARE_OP or ctrl.Analyzer.isConditionalJump(undefined, op)) continue;
                if (op == .STORE_FAST or op == .STORE_NAME) {
                    const name = if (op == .STORE_NAME)
                        self.code.names[all_insts.items[k].arg]
                    else
                        self.code.varnames[all_insts.items[k].arg];
                    const unmangled = try self.unmangleClassName(name);
                    const p = try a.create(ast.Pattern);
                    p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                    pats2[filled2] = p;
                    filled2 += 1;
                    continue;
                }
                if (op == .STORE_FAST_STORE_FAST and attr_list.len >= 2) {
                    const idx1 = (all_insts.items[k].arg >> 4) & 0xF;
                    const idx2 = all_insts.items[k].arg & 0xF;
                    const name1 = self.code.varnames[idx1];
                    const name2 = self.code.varnames[idx2];
                    const unmangled1 = try self.unmangleClassName(name1);
                    const unmangled2 = try self.unmangleClassName(name2);
                    const p1 = try a.create(ast.Pattern);
                    p1.* = .{ .match_as = .{ .pattern = null, .name = unmangled1 } };
                    const p2 = try a.create(ast.Pattern);
                    p2.* = .{ .match_as = .{ .pattern = null, .name = unmangled2 } };
                    if (filled2 < attr_list.len) {
                        pats2[filled2] = p1;
                        filled2 += 1;
                    }
                    if (filled2 < attr_list.len) {
                        pats2[filled2] = p2;
                        filled2 += 1;
                    }
                    continue;
                }
                if (op == .LOAD_SMALL_INT or op == .LOAD_CONST) {
                    const next_op = nextOp(all_insts.items, k);
                    if (next_op == .COMPARE_OP) {
                        const val_expr = if (op == .LOAD_SMALL_INT)
                            try ast.makeConstant(a, .{ .int = @intCast(all_insts.items[k].arg) })
                        else
                            try self.constExprFromObj(self.code.consts[all_insts.items[k].arg]);
                        const p = try a.create(ast.Pattern);
                        p.* = .{ .match_value = val_expr };
                        pats2[filled2] = p;
                        filled2 += 1;
                        continue;
                    }
                }
                break;
            }
            if (filled2 != attr_list.len) return null;

            const pat = try a.create(ast.Pattern);
            pat.* = .{ .match_class = .{
                .cls = cls_expr.?,
                .patterns = &.{},
                .kwd_attrs = attr_list,
                .kwd_patterns = pats2,
            } };
            return pat;
        }
        const pat = try a.create(ast.Pattern);
        pat.* = .{ .match_class = .{
            .cls = cls_expr.?,
            .patterns = &.{},
            .kwd_attrs = attr_list,
            .kwd_patterns = pats,
        } };
        return pat;
    }

    fn finishSeq(self: *Decompiler, seq_stack: *std.ArrayListUnmanaged(SeqBuild)) DecompileError!?*ast.Pattern {
        const a = self.arena.allocator();
        var out: ?*ast.Pattern = null;
        while (seq_stack.items.len > 0) {
            const last_idx = seq_stack.items.len - 1;
            const sb = &seq_stack.items[last_idx];
            if (sb.items.items.len != sb.expected) break;

            const seq_items = try a.alloc(*ast.Pattern, sb.items.items.len);
            std.mem.copyForwards(*ast.Pattern, seq_items, sb.items.items);
            if (sb.swap and seq_items.len == 2) {
                const tmp = seq_items[0];
                seq_items[0] = seq_items[1];
                seq_items[1] = tmp;
            }

            const seq_pat = try a.create(ast.Pattern);
            seq_pat.* = .{ .match_sequence = seq_items };

            sb.items.deinit(self.allocator);
            seq_stack.items.len -= 1;

            if (seq_stack.items.len == 0) {
                out = seq_pat;
                break;
            } else {
                try seq_stack.items[seq_stack.items.len - 1].items.append(self.allocator, seq_pat);
            }
        }
        return out;
    }

    fn decompileMatchCase(self: *Decompiler, block_id: u32, has_copy: bool) DecompileError!MatchCaseResult {
        // Pattern matching with guards spans multiple blocks:
        // Block N: MATCH_SEQUENCE, POP_JUMP -> pattern fail
        // Block N+1: GET_LEN, COMPARE_OP, POP_JUMP -> pattern fail
        // Block N+2: UNPACK, STORE_FAST_STORE_FAST, guard, POP_JUMP -> guard fail
        // Block N+3: body
        //
        // Need to collect all pattern+guard blocks by following conditional_true edges
        // until we reach the body block.

        var pattern_blocks: std.ArrayListUnmanaged(u32) = .{};
        defer pattern_blocks.deinit(self.allocator);

        var current_block_id = block_id;
        var last_test: u32 = block_id;
        var test_blocks: std.ArrayListUnmanaged(u32) = .{};
        defer test_blocks.deinit(self.allocator);

        // Follow conditional edges while blocks contain pattern/guard logic
        while (current_block_id < self.cfg.blocks.len) {
            const blk = &self.cfg.blocks[current_block_id];

            // Stop if this looks like body (subject cleanup)
            var starts_body = false;
            var has_cond = false;
            var first_op: ?Opcode = null;
            for (blk.instructions) |inst| {
                if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                if (first_op == null) first_op = inst.opcode;
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                    has_cond = true;
                }
            }
            if (first_op) |op| {
                if (op == .POP_TOP or op == .RETURN_VALUE) {
                    starts_body = !has_cond;
                }
            }
            if (starts_body) break;

            // Check if this block has pattern opcodes or guard-ish ops
            var has_pattern = false;
            var has_guard_ops = false;
            var has_literal_load = false;
            var has_body_ops = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .LOAD_SMALL_INT or inst.opcode == .LOAD_CONST) {
                    has_literal_load = true;
                }
                if (inst.opcode == .MATCH_SEQUENCE or inst.opcode == .MATCH_MAPPING or
                    inst.opcode == .MATCH_CLASS or inst.opcode == .MATCH_KEYS or
                    inst.opcode == .UNPACK_SEQUENCE or inst.opcode == .UNPACK_EX or
                    inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST or
                    inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or
                    inst.opcode == .POP_JUMP_IF_NONE or inst.opcode == .POP_JUMP_FORWARD_IF_NONE or
                    inst.opcode == .GET_LEN)
                {
                    has_pattern = true;
                }
                if (inst.opcode == .COMPARE_OP and has_literal_load) {
                    has_pattern = true;
                }
                if (inst.opcode == .LOAD_FAST_BORROW or inst.opcode == .LOAD_FAST_BORROW_LOAD_FAST_BORROW or
                    inst.opcode == .LOAD_FAST_LOAD_FAST or inst.opcode == .LOAD_FAST or
                    inst.opcode == .STORE_FAST_LOAD_FAST)
                {
                    has_guard_ops = true;
                }
                // Body ops: f-string formatting, string building, calls
                if (inst.opcode == .FORMAT_SIMPLE or inst.opcode == .FORMAT_WITH_SPEC or
                    inst.opcode == .BUILD_STRING or inst.opcode == .CALL or
                    inst.opcode == .CALL_FUNCTION or inst.opcode == .CALL_KW)
                {
                    has_body_ops = true;
                }
            }

            var has_cond_term = false;
            var has_return = false;
            if (blk.terminator()) |term| {
                has_cond_term = ctrl.Analyzer.isConditionalJump(undefined, term.opcode);
                if (term.opcode == .RETURN_VALUE or term.opcode == .RETURN_CONST) {
                    has_return = true;
                }
            }
            has_cond = has_cond or has_cond_term;

            // Body block: has guard-like ops (LOAD_FAST) but ends with return, no conditional
            if (has_guard_ops and has_return and !has_cond_term and !has_pattern) break;

            // Body block: has f-string/call ops (even if also has pattern cleanup like UNPACK)
            // Still add to pattern_blocks for binding extraction, but not test_blocks
            if (has_body_ops and !has_cond_term) {
                if (has_pattern) {
                    try pattern_blocks.append(self.allocator, current_block_id);
                }
                break;
            }

            if (!has_pattern and !has_guard_ops and !has_cond) break;

            if (has_pattern) {
                try pattern_blocks.append(self.allocator, current_block_id);
            }
            try test_blocks.append(self.allocator, current_block_id);
            last_test = current_block_id;

            if (blk.terminator()) |term| {
                const next_edge = succEdgeForJump(term.opcode);
                var found_next = false;
                for (blk.successors) |edge| {
                    if (edge.edge_type == next_edge) {
                        current_block_id = edge.target;
                        found_next = true;
                        break;
                    }
                }
                if (!found_next) break;
            } else {
                break;
            }
        }

        // Collect all instructions from pattern blocks for extraction
        var all_insts: std.ArrayListUnmanaged(cfg_mod.Instruction) = .{};
        defer all_insts.deinit(self.allocator);
        for (pattern_blocks.items) |pid| {
            const pb = &self.cfg.blocks[pid];
            try all_insts.appendSlice(self.allocator, pb.instructions);
        }

        // Extract pattern from combined instruction stream
        var pat = if (try self.classPatternFromBlocks(pattern_blocks.items)) |cpat|
            cpat
        else if (try self.mapPatternFromBlocks(pattern_blocks.items)) |mpat|
            mpat
        else
            try self.extractMatchPatternFromInsts(all_insts.items, !has_copy);
        if (isWildcardPattern(pat)) {
            if (try self.literalPatternFromBlock(&self.cfg.blocks[block_id])) |lit_pat| {
                pat = lit_pat;
            }
        }

        var guard: ?*Expr = null;
        const guard_exprs = try self.guardExprsFromBlocks(test_blocks.items);
        if (guard_exprs.len > 0) {
            guard = guard_exprs[0];
            for (guard_exprs[1..]) |g| {
                if (guard) |cur| {
                    if (try self.mergeCompareChain(cur, g)) |merged| {
                        guard = merged;
                        continue;
                    }
                }
                guard = try self.makeBoolPair(guard.?, g, .and_);
            }
        }

        var fallback_body: ?[]const *Stmt = null;
        var fallback_block: ?u32 = null;

        // Find body: if guard exists and body is inline (no separate block), extract from current block
        var body: []const *Stmt = &.{};

        // Use last test block for body/guard edge lookup
        const final_block = &self.cfg.blocks[last_test];

        if (guard != null) {
            var fail_block: ?u32 = null;
            if (final_block.terminator()) |term| {
                const fail_edge = failEdgeForJump(term.opcode);
                for (final_block.successors) |edge| {
                    if (edge.edge_type == fail_edge) {
                        fail_block = edge.target;
                        break;
                    }
                }
            }

            // Guard case: body might be inline after POP_TOP, or in a separate block
            var inline_body = false;
            var seen_jump = false;
            for (final_block.instructions) |inst| {
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                    seen_jump = true;
                    continue;
                }
                if (!seen_jump) continue;
                if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or inst.opcode == .STORE_DEREF or
                    inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST)
                {
                    continue;
                }
                if (inst.opcode == .POP_TOP or inst.opcode == .RETURN_VALUE) {
                    inline_body = true;
                    break;
                }
                break;
            }

            // Check if there's a conditional_true edge (separate body block)
            var body_block: ?u32 = null;
            if (!inline_body) {
                for (final_block.successors) |edge| {
                    if (edge.edge_type == .conditional_true) {
                        body_block = edge.target;
                        break;
                    }
                }
                if (body_block == null) {
                    for (final_block.successors) |edge| {
                        if (edge.edge_type == .normal) {
                            body_block = edge.target;
                            break;
                        }
                    }
                }
            }

            if (body_block) |bid| {
                var resolved = bid;
                if (self.jumpTargetIfJumpOnly(bid, true)) |target| {
                    resolved = target;
                }
                if (self.cfg.blocks[resolved].instructions.len == 0) {
                    body_block = null;
                } else {
                    body_block = resolved;
                }
            }

            if (body_block) |bid| {
                // Body in separate block
                var body_end: ?u32 = null;
                const body_blk = &self.cfg.blocks[bid];
                if (self.isSimpleReturnBlock(bid)) {
                    body_end = bid + 1;
                } else if (body_blk.successors.len == 0) {
                    body_end = bid + 1;
                } else {
                    if (final_block.terminator()) |term| {
                        const fail_edge = failEdgeForJump(term.opcode);
                        for (final_block.successors) |edge| {
                            if (edge.edge_type == fail_edge) {
                                body_end = edge.target;
                                break;
                            }
                        }
                    }
                    if (body_end == null) {
                        for (body_blk.successors) |edge| {
                            body_end = edge.target;
                            break;
                        }
                    }
                }

                if (body_end) |end| {
                    if (bid < end) {
                        const pop_need = self.maxLeadPop(bid, end);
                        if (pop_need > 0) {
                            if (pop_need == 1) {
                                var init_stack = [_]StackValue{.unknown};
                                body = try self.decompileStructuredRangeWithStack(bid, end, init_stack[0..]);
                            } else {
                                const init_stack = try self.allocator.alloc(StackValue, pop_need);
                                defer self.allocator.free(init_stack);
                                for (init_stack) |*sv| sv.* = .unknown;
                                body = try self.decompileStructuredRangeWithStack(bid, end, init_stack);
                            }
                        } else {
                            body = try self.decompileStructuredRange(bid, end);
                        }
                    }
                }
            } else {
                // Body inline: find POP_TOP after guard check, decompile rest of block
                var body_start_idx: ?usize = null;
                var fallback_start_idx: ?usize = null;
                var pop_jump_idx: ?usize = null;
                for (final_block.instructions, 0..) |inst, idx| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                        pop_jump_idx = idx;
                        break;
                    }
                }

                if (pop_jump_idx) |pj| {
                    const pop_inst = final_block.instructions[pj];
                    if (pop_inst.jumpTarget(self.version)) |fail_off| {
                        var best: ?usize = null;
                        for (final_block.instructions, 0..) |inst, idx| {
                            if (inst.offset >= fail_off) {
                                if (best == null or inst.offset < final_block.instructions[best.?].offset) {
                                    best = idx;
                                }
                            }
                        }
                        fallback_start_idx = best;
                    }

                    var j = pj + 1;
                    while (j < final_block.instructions.len) : (j += 1) {
                        const inst = final_block.instructions[j];
                        if (inst.opcode == .JUMP_FORWARD or inst.opcode == .JUMP_ABSOLUTE) {
                            if (inst.jumpTarget(self.version)) |succ_off| {
                                var best: ?usize = null;
                                for (final_block.instructions, 0..) |iinst, idx| {
                                    if (iinst.offset >= succ_off) {
                                        if (best == null or iinst.offset < final_block.instructions[best.?].offset) {
                                            best = idx;
                                        }
                                    }
                                }
                                body_start_idx = best;
                            }
                            break;
                        }
                        if (fallback_start_idx) |fb| {
                            if (j >= fb) break;
                        }
                    }
                }

                if (body_start_idx == null) {
                    var found_jump = false;
                    for (final_block.instructions, 0..) |inst, idx| {
                        if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                            found_jump = true;
                            continue;
                        }
                        if (!found_jump) continue;
                        if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                        if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or inst.opcode == .STORE_DEREF or
                            inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST)
                        {
                            continue;
                        }
                        if (inst.opcode == .POP_TOP) {
                            body_start_idx = idx + 1; // Start after POP_TOP
                            break;
                        }
                        body_start_idx = idx; // Start at first non-POP_TOP after jump
                        break;
                    }
                }
                if (body_start_idx == null) {
                    if (fallback_start_idx) |fb| {
                        var k = fb;
                        while (k < final_block.instructions.len) : (k += 1) {
                            if (final_block.instructions[k].opcode == .RETURN_VALUE) {
                                k += 1;
                                while (k < final_block.instructions.len) : (k += 1) {
                                    const op = final_block.instructions[k].opcode;
                                    if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
                                    body_start_idx = k;
                                    break;
                                }
                                break;
                            }
                        }
                    }
                }

                if (body_start_idx) |start_idx| {
                    // Create a temporary block with just the body instructions
                    var body_insts: std.ArrayListUnmanaged(cfg_mod.Instruction) = .{};
                    defer body_insts.deinit(self.allocator);
                    try body_insts.appendSlice(self.allocator, final_block.instructions[start_idx..]);

                    const a = self.arena.allocator();
                    var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                    defer stmts.deinit(a);

                    var sim = self.initSim(a, a, self.code, self.version);
                    defer sim.deinit();

                    for (body_insts.items) |inst| {
                        if (inst.opcode == .RETURN_VALUE) {
                            const val = if (sim.stack.popExpr()) |expr| expr else |err| switch (err) {
                                error.StackUnderflow => blk: {
                                    const none_expr = try a.create(Expr);
                                    none_expr.* = .{ .constant = .{ .none = {} } };
                                    break :blk none_expr;
                                },
                                else => return err,
                            };
                            const stmt = try a.create(Stmt);
                            stmt.* = .{ .return_stmt = .{ .value = val } };
                            try stmts.append(a, stmt);
                            break;
                        } else {
                            try sim.simulate(inst);
                        }
                    }

                    body = try stmts.toOwnedSlice(a);
                }

                if (fallback_body == null) {
                    if (fallback_start_idx) |fb_start| {
                        var fb_insts: std.ArrayListUnmanaged(cfg_mod.Instruction) = .{};
                        defer fb_insts.deinit(self.allocator);
                        try fb_insts.appendSlice(self.allocator, final_block.instructions[fb_start..]);

                        const a = self.arena.allocator();
                        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                        defer stmts.deinit(a);

                        var sim = self.initSim(a, a, self.code, self.version);
                        defer sim.deinit();

                        for (fb_insts.items) |inst| {
                            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE or inst.opcode == .POP_TOP) continue;
                            if (inst.opcode == .RETURN_VALUE) {
                                const val = if (sim.stack.popExpr()) |expr| expr else |err| switch (err) {
                                    error.StackUnderflow => blk: {
                                        const none_expr = try a.create(Expr);
                                        none_expr.* = .{ .constant = .{ .none = {} } };
                                        break :blk none_expr;
                                    },
                                    else => return err,
                                };
                                const stmt = try a.create(Stmt);
                                stmt.* = .{ .return_stmt = .{ .value = val } };
                                try stmts.append(a, stmt);
                                break;
                            } else {
                                try sim.simulate(inst);
                            }
                        }

                        if (stmts.items.len > 0) {
                            fallback_body = try stmts.toOwnedSlice(a);
                        }
                    }
                }
            }

            if (fallback_block == null) {
                fallback_block = fail_block;
            }
            if (fallback_body == null) {
                if (fallback_block) |fb| {
                    if (self.isSimpleReturnBlock(fb)) {
                        var fb_end: u32 = fb + 1;
                        const fblk = &self.cfg.blocks[fb];
                        if (fblk.successors.len > 0) {
                            fb_end = fblk.successors[0].target;
                        }
                        if (fb < fb_end) {
                            const pop_need = self.maxLeadPop(fb, fb_end);
                            if (pop_need > 0) {
                                if (pop_need == 1) {
                                    var init_stack = [_]StackValue{.unknown};
                                    fallback_body = try self.decompileStructuredRangeWithStack(fb, fb_end, init_stack[0..]);
                                } else {
                                    const init_stack = try self.allocator.alloc(StackValue, pop_need);
                                    defer self.allocator.free(init_stack);
                                    for (init_stack) |*sv| sv.* = .unknown;
                                    fallback_body = try self.decompileStructuredRangeWithStack(fb, fb_end, init_stack);
                                }
                            } else {
                                fallback_body = try self.decompileStructuredRange(fb, fb_end);
                            }
                        }
                    }
                }
            }
        } else {
            // No guard: body in true branch or inline
            var inline_body = false;
            var seen_jump = false;
            var has_cond_jump = false;
            for (final_block.instructions) |inst| {
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                    seen_jump = true;
                    has_cond_jump = true;
                    continue;
                }
                if (!seen_jump) continue;
                if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or inst.opcode == .STORE_DEREF or
                    inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST)
                {
                    continue;
                }
                if (inst.opcode == .POP_TOP or inst.opcode == .RETURN_VALUE) {
                    inline_body = true;
                    break;
                }
                break;
            }
            // If no conditional jump in block, the entire block is the body (success path)
            if (!has_cond_jump) {
                inline_body = true;
            }

            var body_block: ?u32 = null;
            if (!inline_body) {
                for (final_block.successors) |edge| {
                    if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                        body_block = edge.target;
                        break;
                    }
                }
            }

            if (body_block) |bid| {
                if (self.cfg.blocks[bid].instructions.len == 0) {
                    body_block = null;
                }
            }
            if (body_block) |bid| {
                var body_end: u32 = last_test + 1;
                const body_blk = &self.cfg.blocks[bid];
                if (body_blk.successors.len == 0) {
                    body_end = bid + 1;
                } else if (final_block.terminator()) |term| {
                    const fail_edge = failEdgeForJump(term.opcode);
                    for (final_block.successors) |edge| {
                        if (edge.edge_type == fail_edge) {
                            body_end = edge.target;
                            break;
                        }
                    }
                }
                if (bid < body_end) {
                    // Check if body block starts with pattern ops that need skipping
                    const skip = self.patternSkipCount(body_blk);
                    if (skip > 0 and skip < body_blk.instructions.len) {
                        // Decompile body inline, skipping pattern instructions
                        const a = self.arena.allocator();
                        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                        defer stmts.deinit(a);

                        var sim = self.initSim(a, a, self.code, self.version);
                        defer sim.deinit();

                        for (body_blk.instructions[skip..]) |inst| {
                            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE or inst.opcode == .POP_TOP) continue;
                            if (inst.opcode == .RETURN_VALUE or inst.opcode == .RETURN_CONST) {
                                const val = if (inst.opcode == .RETURN_CONST)
                                    try self.constExprFromObj(self.code.consts[inst.arg])
                                else if (sim.stack.popExpr()) |expr|
                                    expr
                                else |err| switch (err) {
                                    error.StackUnderflow => blk: {
                                        const none_expr = try a.create(Expr);
                                        none_expr.* = .{ .constant = .{ .none = {} } };
                                        break :blk none_expr;
                                    },
                                    else => return err,
                                };
                                const stmt = try a.create(Stmt);
                                stmt.* = .{ .return_stmt = .{ .value = val } };
                                try stmts.append(a, stmt);
                                break;
                            } else {
                                try sim.simulate(inst);
                            }
                        }
                        body = try stmts.toOwnedSlice(a);
                    } else {
                        const pop_need = self.maxLeadPop(bid, body_end);
                        if (pop_need > 0) {
                            if (pop_need == 1) {
                                var init_stack = [_]StackValue{.unknown};
                                body = try self.decompileStructuredRangeWithStack(bid, body_end, init_stack[0..]);
                            } else {
                                const init_stack = try self.allocator.alloc(StackValue, pop_need);
                                defer self.allocator.free(init_stack);
                                for (init_stack) |*sv| sv.* = .unknown;
                                body = try self.decompileStructuredRangeWithStack(bid, body_end, init_stack);
                            }
                        } else {
                            body = try self.decompileStructuredRange(bid, body_end);
                        }
                    }
                }
            } else {
                // Body inline: find POP_TOP after guard check or NOP (fallback)
                var start_idx: ?usize = null;
                var fallback_start_idx: ?usize = null;
                var jump_idx: ?usize = null;
                var found_jump = false;
                for (final_block.instructions, 0..) |inst, idx| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                        if (jump_idx == null) jump_idx = idx;
                        found_jump = true;
                        continue;
                    }
                    if (!found_jump) continue;
                    if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                    if (inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or inst.opcode == .STORE_DEREF or
                        inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST or
                        inst.opcode == .UNPACK_SEQUENCE or inst.opcode == .UNPACK_EX)
                    {
                        continue;
                    }
                    if (inst.opcode == .POP_TOP or inst.opcode == .NOP) {
                        // Skip POP_TOP/NOP and start body after
                        start_idx = idx + 1;
                        break;
                    }
                    // First non-pattern instruction is body start
                    start_idx = idx;
                    break;
                }
                if (jump_idx) |pj| {
                    const jinst = final_block.instructions[pj];
                    if (jinst.jumpTarget(self.version)) |fail_off| {
                        var best: ?usize = null;
                        for (final_block.instructions, 0..) |inst, idx| {
                            if (inst.offset >= fail_off) {
                                if (best == null or inst.offset < final_block.instructions[best.?].offset) {
                                    best = idx;
                                }
                            }
                        }
                        fallback_start_idx = best;
                    }
                }
                if (start_idx == null and !found_jump) {
                    // No conditional jump - skip pattern opcodes to find actual body
                    for (final_block.instructions, 0..) |inst, idx| {
                        if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
                        // Skip pattern matching opcodes (UNPACK_SEQUENCE, STORE_FAST, etc.)
                        if (inst.opcode == .UNPACK_SEQUENCE or inst.opcode == .UNPACK_EX or
                            inst.opcode == .STORE_FAST or inst.opcode == .STORE_NAME or
                            inst.opcode == .STORE_FAST_STORE_FAST or inst.opcode == .STORE_FAST_LOAD_FAST or
                            inst.opcode == .STORE_DEREF)
                        {
                            continue;
                        }
                        if (inst.opcode == .NOP or inst.opcode == .POP_TOP) {
                            start_idx = idx + 1;
                            break;
                        }
                        start_idx = idx;
                        break;
                    }
                }

                if (start_idx) |start| {
                    const aa = self.arena.allocator();
                    var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                    defer stmts.deinit(aa);
                    var sim = self.initSim(aa, aa, self.code, self.version);
                    defer sim.deinit();

                    for (final_block.instructions[start..]) |inst| {
                        if (inst.opcode == .RETURN_VALUE) {
                            const val = if (sim.stack.popExpr()) |expr| expr else |err| switch (err) {
                                error.StackUnderflow => blk: {
                                    const none_expr = try aa.create(Expr);
                                    none_expr.* = .{ .constant = .{ .none = {} } };
                                    break :blk none_expr;
                                },
                                else => return err,
                            };
                            const stmt = try aa.create(Stmt);
                            stmt.* = .{ .return_stmt = .{ .value = val } };
                            try stmts.append(aa, stmt);
                            break;
                        } else {
                            try sim.simulate(inst);
                        }
                    }

                    body = try stmts.toOwnedSlice(aa);
                }
                if (fallback_body == null) {
                    if (fallback_start_idx) |fb_start| {
                        var fb_insts: std.ArrayListUnmanaged(cfg_mod.Instruction) = .{};
                        defer fb_insts.deinit(self.allocator);
                        try fb_insts.appendSlice(self.allocator, final_block.instructions[fb_start..]);

                        const aa = self.arena.allocator();
                        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                        defer stmts.deinit(aa);
                        var sim = self.initSim(aa, aa, self.code, self.version);
                        defer sim.deinit();

                        for (fb_insts.items) |inst| {
                            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE or inst.opcode == .POP_TOP) continue;
                            if (inst.opcode == .RETURN_VALUE) {
                                const val = if (sim.stack.popExpr()) |expr| expr else |err| switch (err) {
                                    error.StackUnderflow => blk: {
                                        const none_expr = try aa.create(Expr);
                                        none_expr.* = .{ .constant = .{ .none = {} } };
                                        break :blk none_expr;
                                    },
                                    else => return err,
                                };
                                const stmt = try aa.create(Stmt);
                                stmt.* = .{ .return_stmt = .{ .value = val } };
                                try stmts.append(aa, stmt);
                                break;
                            } else {
                                try sim.simulate(inst);
                            }
                        }

                        if (stmts.items.len > 0) {
                            fallback_body = try stmts.toOwnedSlice(aa);
                        }
                    }
                }
            }
            if (fallback_block == null) {
                if (final_block.terminator()) |term| {
                    const fail_edge = failEdgeForJump(term.opcode);
                    for (final_block.successors) |edge| {
                        if (edge.edge_type == fail_edge) {
                            fallback_block = edge.target;
                            break;
                        }
                    }
                }
            }
            if (fallback_body == null) {
                if (fallback_block) |fb| {
                    if (self.isSimpleReturnBlock(fb)) {
                        var fb_end: u32 = fb + 1;
                        const fblk = &self.cfg.blocks[fb];
                        if (fblk.successors.len > 0) {
                            fb_end = fblk.successors[0].target;
                        }
                        if (fb < fb_end) {
                            const pop_need = self.maxLeadPop(fb, fb_end);
                            if (pop_need > 0) {
                                if (pop_need == 1) {
                                    var init_stack = [_]StackValue{.unknown};
                                    fallback_body = try self.decompileStructuredRangeWithStack(fb, fb_end, init_stack[0..]);
                                } else {
                                    const init_stack = try self.allocator.alloc(StackValue, pop_need);
                                    defer self.allocator.free(init_stack);
                                    for (init_stack) |*sv| sv.* = .unknown;
                                    fallback_body = try self.decompileStructuredRangeWithStack(fb, fb_end, init_stack);
                                }
                            } else {
                                fallback_body = try self.decompileStructuredRange(fb, fb_end);
                            }
                        }
                    }
                }
            }
        }

        return MatchCaseResult{
            .case = .{
                .pattern = pat,
                .guard = guard,
                .body = body,
            },
            .fallback_body = fallback_body,
            .fallback_block = fallback_block,
        };
    }

    pub fn extractMatchPatternFromInsts(self: *Decompiler, insts: []const cfg_mod.Instruction, subject_on_stack: bool) DecompileError!*ast.Pattern {
        const a = self.arena.allocator();
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();

        var subject_expr: ?*Expr = null;
        if (subject_on_stack) {
            const placeholder = try a.create(Expr);
            placeholder.* = .{ .name = .{ .id = "<subject>", .ctx = .load } };
            try sim.stack.push(.{ .expr = placeholder });
            subject_expr = placeholder;
        }

        var has_match_seq = false;
        var has_match_map = false;
        var literal_val: ?*Expr = null;
        var map_keys: ?[]const *Expr = null;
        var class_info: ?ClassInfo = null;
        var last_cls: ?*Expr = null;
        var last_attrs: ?[]const []const u8 = null;
        var seq_stack: std.ArrayListUnmanaged(SeqBuild) = .{};
        defer {
            for (seq_stack.items) |*sb| {
                sb.items.deinit(self.allocator);
            }
            seq_stack.deinit(self.allocator);
        }

        // Pre-scan for mapping keys so UNPACK_SEQUENCE can use them
        var scan_idx: usize = 0;
        while (scan_idx < insts.len) : (scan_idx += 1) {
            if (insts[scan_idx].opcode != .MATCH_KEYS) continue;
            var j = scan_idx;
            while (j > 0) {
                j -= 1;
                const op = insts[j].opcode;
                if (op == .NOT_TAKEN or op == .CACHE) continue;
                if (op == .LOAD_CONST) {
                    const obj = self.code.consts[insts[j].arg];
                    map_keys = try self.keyExprsFromObj(obj);
                    break;
                }
                if (op == .MATCH_MAPPING) break;
            }
            break;
        }

        var prev_was_load = false;
        var unpack_count: ?u32 = null;
        var first_unpack: ?usize = null;
        var prev_was_get_len = false;
        var unpack_ex_before: usize = 0;
        var unpack_ex_after: usize = 0;
        var unpack_ex_seen: usize = 0;
        var unpack_ex_active = false;
        for (insts, 0..) |inst, idx| {
            switch (inst.opcode) {
                .MATCH_SEQUENCE => has_match_seq = true,
                .MATCH_MAPPING => has_match_map = true,
                .COPY => {
                    if (sim.stack.len() == 0) {
                        const placeholder = try a.create(Expr);
                        placeholder.* = .{ .name = .{ .id = "<subject>", .ctx = .load } };
                        try sim.stack.push(.{ .expr = placeholder });
                        if (subject_expr == null) subject_expr = placeholder;
                    } else if (subject_expr == null) {
                        const items = sim.stack.items.items;
                        switch (items[items.len - 1]) {
                            .expr => |e| subject_expr = e,
                            else => {},
                        }
                    }
                },
                .MATCH_KEYS => {
                    if (map_keys == null) {
                        var j = idx;
                        while (j > 0) {
                            j -= 1;
                            const op = insts[j].opcode;
                            if (op == .NOT_TAKEN or op == .CACHE) continue;
                            if (op == .LOAD_CONST) {
                                const obj = self.code.consts[insts[j].arg];
                                map_keys = try self.keyExprsFromObj(obj);
                                break;
                            }
                            if (op == .MATCH_MAPPING) break;
                        }
                    }
                    try sim.simulate(inst);
                },
                .MATCH_CLASS => {
                    if (last_cls != null and last_attrs != null) {
                        class_info = .{ .cls = last_cls.?, .attrs = last_attrs.? };
                    }
                    last_attrs = null;
                    try sim.simulate(inst);
                },
                .GET_LEN => {
                    prev_was_get_len = true;
                    try sim.simulate(inst);
                },
                .LOAD_NAME => {
                    prev_was_load = true;
                    prev_was_get_len = false;
                    const name = self.code.names[inst.arg];
                    last_cls = try self.makeName(name, .load);
                    try sim.simulate(inst);
                    if (subject_expr == null) {
                        const items = sim.stack.items.items;
                        if (items.len > 0) {
                            switch (items[items.len - 1]) {
                                .expr => |e| subject_expr = e,
                                else => {},
                            }
                        }
                    }
                },
                .LOAD_FAST => {
                    prev_was_load = true;
                    prev_was_get_len = false;
                    try sim.simulate(inst);
                    if (subject_expr == null) {
                        const items = sim.stack.items.items;
                        if (items.len > 0) {
                            switch (items[items.len - 1]) {
                                .expr => |e| subject_expr = e,
                                else => {},
                            }
                        }
                    }
                },
                .LOAD_GLOBAL => {
                    prev_was_load = false;
                    prev_was_get_len = false;
                    const name = self.code.names[inst.arg];
                    last_cls = try self.makeName(name, .load);
                    try sim.simulate(inst);
                    if (subject_expr == null) {
                        const items = sim.stack.items.items;
                        if (items.len > 0) {
                            switch (items[items.len - 1]) {
                                .expr => |e| subject_expr = e,
                                else => {},
                            }
                        }
                    }
                },
                .LOAD_CONST, .LOAD_SMALL_INT => {
                    prev_was_load = false;
                    // Look ahead: only treat as literal when directly compared
                    const next_op = nextOp(insts, idx);
                    if (inst.opcode == .LOAD_CONST and next_op == .MATCH_KEYS) {
                        const obj = self.code.consts[inst.arg];
                        map_keys = try self.keyExprsFromObj(obj);
                        try sim.simulate(inst);
                        break;
                    }
                    if (inst.opcode == .LOAD_CONST and next_op == .MATCH_CLASS) {
                        const obj = self.code.consts[inst.arg];
                        last_attrs = try self.attrNamesFromObj(obj);
                        try sim.simulate(inst);
                        break;
                    }
                    if (!prev_was_get_len and next_op == .COMPARE_OP) {
                        try sim.simulate(inst);
                        const lit = try sim.stack.popExpr();
                        if (seq_stack.items.len > 0) {
                            literal_val = lit;
                        } else {
                            var is_subject = false;
                            const items = sim.stack.items.items;
                            if (items.len >= 2) {
                                switch (items[items.len - 2]) {
                                    .expr => |e| {
                                        if (subject_expr == null or e == subject_expr.?) is_subject = true;
                                    },
                                    else => {},
                                }
                            }
                            if (is_subject) {
                                literal_val = lit;
                            } else {
                                literal_val = null;
                            }
                        }
                    } else {
                        try sim.simulate(inst);
                    }
                },
                .COMPARE_OP => {
                    prev_was_load = false;
                    // Literal match - use the constant (only if we have one and not in length check)
                    if (!prev_was_get_len and literal_val != null) {
                        if (seq_stack.items.len > 0) {
                            const pat = try self.arena.allocator().create(ast.Pattern);
                            pat.* = .{ .match_value = literal_val.? };
                            var top = &seq_stack.items[seq_stack.items.len - 1];
                            try top.items.append(self.allocator, pat);
                            literal_val = null;
                            if (try self.finishSeq(&seq_stack)) |seq_pat| return seq_pat;
                        } else {
                            const pat = try self.arena.allocator().create(ast.Pattern);
                            pat.* = .{ .match_value = literal_val.? };
                            return pat;
                        }
                    }
                    prev_was_get_len = false;
                    // Skip simulation of comparison - it produces bool which breaks subsequent pattern logic
                },
                .UNPACK_SEQUENCE => {
                    unpack_count = inst.arg;
                    if (first_unpack == null) first_unpack = idx;
                    if (map_keys) |keys| {
                        if (keys.len == @as(usize, inst.arg)) {
                            const pats = try a.alloc(*ast.Pattern, keys.len);
                            var filled: usize = 0;
                            var j = idx + 1;
                            while (j < insts.len and filled < keys.len) : (j += 1) {
                                const op = insts[j].opcode;
                                if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
                                if (op == .STORE_FAST or op == .STORE_NAME) {
                                    const name = if (op == .STORE_NAME)
                                        self.code.names[insts[j].arg]
                                    else
                                        self.code.varnames[insts[j].arg];
                                    const unmangled = try self.unmangleClassName(name);
                                    const p = try a.create(ast.Pattern);
                                    p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                                    pats[filled] = p;
                                    filled += 1;
                                    continue;
                                }
                                if (op == .LOAD_SMALL_INT or op == .LOAD_CONST) {
                                    const next_op = nextOp(insts, j);
                                    if (next_op == .COMPARE_OP) {
                                        const val_expr = if (op == .LOAD_SMALL_INT)
                                            try ast.makeConstant(a, .{ .int = @intCast(insts[j].arg) })
                                        else
                                            try self.constExprFromObj(self.code.consts[insts[j].arg]);
                                        const p = try a.create(ast.Pattern);
                                        p.* = .{ .match_value = val_expr };
                                        pats[filled] = p;
                                        filled += 1;
                                        continue;
                                    }
                                }
                                break;
                            }
                            if (filled == keys.len) {
                                const pat = try a.create(ast.Pattern);
                                pat.* = .{ .match_mapping = .{ .keys = keys, .patterns = pats, .rest = null } };
                                return pat;
                            }
                        }
                    }
                    if (map_keys == null and class_info == null) {
                        try seq_stack.append(self.allocator, .{ .expected = @intCast(inst.arg) });
                    }
                    try sim.simulate(inst);
                },
                .UNPACK_EX => {
                    const before = @as(usize, inst.arg & 0xFF);
                    const after = @as(usize, inst.arg >> 8);
                    unpack_ex_before = before;
                    unpack_ex_after = after;
                    unpack_ex_seen = 0;
                    unpack_ex_active = true;
                    if (map_keys == null and class_info == null) {
                        try seq_stack.append(self.allocator, .{ .expected = before + after + 1 });
                    }
                },
                .SWAP => {
                    if (seq_stack.items.len > 0 and inst.arg == 2) {
                        var top = &seq_stack.items[seq_stack.items.len - 1];
                        if (top.expected == 2 and top.items.items.len == 0) {
                            top.swap = true;
                            continue;
                        }
                    }
                    try sim.simulate(inst);
                },
                .STORE_FAST_STORE_FAST => {
                    // Python 3.14+: UNPACK_SEQUENCE followed by STORE_FAST_STORE_FAST
                    // Build match_sequence pattern with bindings
                    if (seq_stack.items.len > 0) {
                        const idx1 = (inst.arg >> 4) & 0xF;
                        const idx2 = inst.arg & 0xF;
                        const name1 = self.code.varnames[idx1];
                        const name2 = self.code.varnames[idx2];
                        const unmangled1 = try self.unmangleClassName(name1);
                        const unmangled2 = try self.unmangleClassName(name2);
                        const pat1 = try a.create(ast.Pattern);
                        const pat2 = try a.create(ast.Pattern);
                        if (unpack_ex_active and unpack_ex_seen == unpack_ex_before) {
                            pat1.* = .{ .match_star = unmangled1 };
                        } else {
                            pat1.* = .{ .match_as = .{ .pattern = null, .name = unmangled1 } };
                        }
                        unpack_ex_seen += 1;
                        if (unpack_ex_active and unpack_ex_seen == unpack_ex_before) {
                            pat2.* = .{ .match_star = unmangled2 };
                        } else {
                            pat2.* = .{ .match_as = .{ .pattern = null, .name = unmangled2 } };
                        }
                        unpack_ex_seen += 1;
                        if (unpack_ex_active and unpack_ex_seen >= unpack_ex_before + unpack_ex_after + 1) {
                            unpack_ex_active = false;
                        }
                        var top = &seq_stack.items[seq_stack.items.len - 1];
                        try top.items.append(self.allocator, pat1);
                        try top.items.append(self.allocator, pat2);
                        if (try self.finishSeq(&seq_stack)) |seq_pat| {
                            if (self.findAsName(insts, idx)) |as_name| {
                                const as_pat = try a.create(ast.Pattern);
                                const unmangled_as = try self.unmangleClassName(as_name);
                                as_pat.* = .{ .match_as = .{ .pattern = seq_pat, .name = unmangled_as } };
                                return as_pat;
                            }
                            return seq_pat;
                        }
                        continue;
                    }
                    if (unpack_count) |count| {
                        if (count == 2) {
                            // arg packs indices: hi=first var, lo=second var
                            const idx1 = (inst.arg >> 4) & 0xF;
                            const idx2 = inst.arg & 0xF;
                            const name1 = self.code.varnames[idx1];
                            const name2 = self.code.varnames[idx2];
                            const unmangled1 = try self.unmangleClassName(name1);
                            const unmangled2 = try self.unmangleClassName(name2);

                            const pat1 = try a.create(ast.Pattern);
                            pat1.* = .{ .match_as = .{ .pattern = null, .name = unmangled1 } };
                            const pat2 = try a.create(ast.Pattern);
                            pat2.* = .{ .match_as = .{ .pattern = null, .name = unmangled2 } };

                            if (class_info) |ci| {
                                const pats = try a.alloc(*ast.Pattern, 2);
                                pats[0] = pat1;
                                pats[1] = pat2;
                                const pat = try a.create(ast.Pattern);
                                pat.* = .{ .match_class = .{
                                    .cls = ci.cls,
                                    .patterns = &.{},
                                    .kwd_attrs = ci.attrs,
                                    .kwd_patterns = pats,
                                } };
                                return pat;
                            }

                            if (seq_stack.items.len > 0) {
                                var top = &seq_stack.items[seq_stack.items.len - 1];
                                try top.items.append(self.allocator, pat1);
                                try top.items.append(self.allocator, pat2);
                                if (try self.finishSeq(&seq_stack)) |seq_pat| {
                                    if (self.findAsName(insts, idx)) |as_name| {
                                        const as_pat = try a.create(ast.Pattern);
                                        const unmangled_as = try self.unmangleClassName(as_name);
                                        as_pat.* = .{ .match_as = .{ .pattern = seq_pat, .name = unmangled_as } };
                                        return as_pat;
                                    }
                                    return seq_pat;
                                }
                            } else {
                                const pats = try a.alloc(*ast.Pattern, 2);
                                pats[0] = pat1;
                                pats[1] = pat2;
                                const pat = try a.create(ast.Pattern);
                                pat.* = .{ .match_sequence = pats };
                                if (self.findAsName(insts, idx)) |as_name| {
                                    const as_pat = try a.create(ast.Pattern);
                                    const unmangled_as = try self.unmangleClassName(as_name);
                                    as_pat.* = .{ .match_as = .{ .pattern = pat, .name = unmangled_as } };
                                    return as_pat;
                                }
                                return pat;
                            }
                        }
                    }
                    // Don't simulate - this would pop from empty stack
                },
                .STORE_FAST_LOAD_FAST => {
                    // Python 3.14+: combined store+load for pattern binding
                    if (seq_stack.items.len > 0) {
                        const load_idx = inst.arg & 0xF;
                        const name = self.code.varnames[load_idx];
                        const unmangled = try self.unmangleClassName(name);
                        const pat = try a.create(ast.Pattern);
                        pat.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                        var top = &seq_stack.items[seq_stack.items.len - 1];
                        try top.items.append(self.allocator, pat);
                        if (try self.finishSeq(&seq_stack)) |seq_pat| return seq_pat;
                        continue;
                    }
                    if (unpack_count) |count| {
                        if (count == 1) {
                            const load_idx = inst.arg & 0xF;
                            const name = self.code.varnames[load_idx];
                            const unmangled = try self.unmangleClassName(name);
                            const pat1 = try a.create(ast.Pattern);
                            pat1.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };

                            const pats = try a.alloc(*ast.Pattern, 1);
                            pats[0] = pat1;

                            const pat = try a.create(ast.Pattern);
                            pat.* = .{ .match_sequence = pats };
                            return pat;
                        }
                    } else {
                        const load_idx = inst.arg & 0xF;
                        const name = self.code.varnames[load_idx];
                        const unmangled = try self.unmangleClassName(name);
                        const pat = try a.create(ast.Pattern);
                        pat.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                        return pat;
                    }
                },
                .STORE_NAME, .STORE_FAST => {
                    if (seq_stack.items.len > 0) {
                        const name = if (inst.opcode == .STORE_NAME)
                            self.code.names[inst.arg]
                        else
                            self.code.varnames[inst.arg];
                        const unmangled = try self.unmangleClassName(name);
                        const pat = try a.create(ast.Pattern);
                        if (unpack_ex_active and unpack_ex_seen == unpack_ex_before) {
                            pat.* = .{ .match_star = unmangled };
                        } else {
                            pat.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                        }
                        var top = &seq_stack.items[seq_stack.items.len - 1];
                        try top.items.append(self.allocator, pat);
                        unpack_ex_seen += 1;
                        if (unpack_ex_active and unpack_ex_seen >= unpack_ex_before + unpack_ex_after + 1) {
                            unpack_ex_active = false;
                        }
                        if (try self.finishSeq(&seq_stack)) |seq_pat| return seq_pat;
                        continue;
                    }
                    // Capture pattern only if previous was LOAD (subject load  pattern binding)
                    if (prev_was_load) {
                        const name = if (inst.opcode == .STORE_NAME)
                            self.code.names[inst.arg]
                        else
                            self.code.varnames[inst.arg];
                        const unmangled = try self.unmangleClassName(name);

                        const pat = try self.arena.allocator().create(ast.Pattern);
                        pat.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                        return pat;
                    }
                    prev_was_load = false;
                    try sim.simulate(inst);
                },
                .NOP => {
                    prev_was_load = false;
                    // Wildcard pattern
                    const pat = try self.arena.allocator().create(ast.Pattern);
                    pat.* = .{ .match_as = .{ .pattern = null, .name = null } };
                    return pat;
                },
                .POP_JUMP_IF_FALSE, .POP_JUMP_FORWARD_IF_FALSE, .POP_JUMP_IF_TRUE, .TO_BOOL => {
                    // Skip - these are control flow, not pattern
                    prev_was_load = false;
                },
                else => {
                    prev_was_load = false;
                    try sim.simulate(inst);
                },
            }
        }

        if (map_keys) |keys| {
            if (first_unpack) |u_idx| {
                if (keys.len > 0) {
                    const pats = try a.alloc(*ast.Pattern, keys.len);
                    var filled: usize = 0;
                    var j = u_idx + 1;
                    while (j < insts.len and filled < keys.len) : (j += 1) {
                        const op = insts[j].opcode;
                        if (op == .NOT_TAKEN or op == .CACHE or op == .POP_TOP) continue;
                        if (op == .STORE_FAST or op == .STORE_NAME) {
                            const name = if (op == .STORE_NAME)
                                self.code.names[insts[j].arg]
                            else
                                self.code.varnames[insts[j].arg];
                            const unmangled = try self.unmangleClassName(name);
                            const p = try a.create(ast.Pattern);
                            p.* = .{ .match_as = .{ .pattern = null, .name = unmangled } };
                            pats[filled] = p;
                            filled += 1;
                            continue;
                        }
                        if (op == .LOAD_SMALL_INT or op == .LOAD_CONST) {
                            const next_op = nextOp(insts, j);
                            if (next_op == .COMPARE_OP) {
                                const val_expr = if (op == .LOAD_SMALL_INT)
                                    try ast.makeConstant(a, .{ .int = @intCast(insts[j].arg) })
                                else
                                    try self.constExprFromObj(self.code.consts[insts[j].arg]);
                                const p = try a.create(ast.Pattern);
                                p.* = .{ .match_value = val_expr };
                                pats[filled] = p;
                                filled += 1;
                                continue;
                            }
                        }
                        break;
                    }
                    if (filled == keys.len) {
                        const pat = try a.create(ast.Pattern);
                        pat.* = .{ .match_mapping = .{ .keys = keys, .patterns = pats, .rest = null } };
                        return pat;
                    }
                }
            }
        }

        if (seq_stack.items.len > 0) {
            if (try self.finishSeq(&seq_stack)) |seq_pat| return seq_pat;
        }

        // Default to wildcard if we can't determine pattern
        const pat = try self.arena.allocator().create(ast.Pattern);
        if (has_match_seq) {
            pat.* = .{ .match_sequence = &.{} };
        } else if (has_match_map) {
            pat.* = .{ .match_mapping = .{ .keys = &.{}, .patterns = &.{}, .rest = null } };
        } else {
            pat.* = .{ .match_as = .{ .pattern = null, .name = null } };
        }
        return pat;
    }

    fn decompileStructuredRange(self: *Decompiler, start: u32, end: u32) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, &.{}, false, false);
    }

    fn decompileStructuredRangeNoTry(self: *Decompiler, start: u32, end: u32) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, &.{}, true, false);
    }

    fn decompileStructuredRangeWithStack(self: *Decompiler, start: u32, end: u32, init_stack: []const StackValue) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, init_stack, false, false);
    }

    fn decompileStructuredRangeNoTryWithStack(self: *Decompiler, start: u32, end: u32, init_stack: []const StackValue) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, init_stack, true, false);
    }

    fn decompileStructuredRangeWithStackAllowHandlers(self: *Decompiler, start: u32, end: u32, init_stack: []const StackValue) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, init_stack, false, true);
    }

    fn decompileStructuredRangeNoTryWithStackAllowHandlers(self: *Decompiler, start: u32, end: u32, init_stack: []const StackValue) DecompileError![]const *Stmt {
        return self.decompileStructuredRangeWithStackInner(start, end, init_stack, true, true);
    }

    fn decompileStructuredRangeWithStackInner(
        self: *Decompiler,
        start: u32,
        end: u32,
        init_stack: []const StackValue,
        skip_try: bool,
        allow_handlers: bool,
    ) DecompileError![]const *Stmt {
        // Handle empty range (start == end)
        if (start >= end) return &[_]*Stmt{};
        const range_key: u64 = (@as(u64, start) << 32) | @as(u64, end);
        if (self.range_in_progress.contains(range_key)) return &[_]*Stmt{};
        try self.range_in_progress.put(range_key, {});
        defer _ = self.range_in_progress.remove(range_key);

        const prev_limit = self.br_limit;
        if (self.br_limit) |lim| {
            if (end < lim) self.br_limit = end;
        } else {
            self.br_limit = end;
        }
        defer self.br_limit = prev_limit;

        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        var block_idx = start;
        const limit = @min(end, @as(u32, @intCast(self.cfg.blocks.len)));

        while (block_idx < limit) {
            const prev_idx = block_idx;
            const stmts_len = stmts.items.len;
            if (self.trace_blocks and self.trace_file != null) {
                const ev = BlockTrace{
                    .kind = "block_visit",
                    .phase = "range",
                    .block = block_idx,
                    .start = start,
                    .end = limit,
                };
                try self.writeTrace(ev);
            }
            if (self.consumed.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            if (!allow_handlers and self.cfg.blocks[block_idx].is_exception_handler) {
                block_idx += 1;
                continue;
            }
            if (!hasTrySetup(&self.cfg.blocks[block_idx])) {
                if (try self.tryDecompileBoolOpInto(block_idx, limit, &stmts, a)) |next_block| {
                    block_idx = next_block;
                    if (block_idx <= prev_idx) {
                        if (self.last_error_ctx == null) {
                            self.last_error_ctx = .{
                                .code_name = self.code.name,
                                .block_id = prev_idx,
                                .offset = self.cfg.blocks[prev_idx].start_offset,
                                .opcode = "boolop_no_progress",
                            };
                        }
                        return error.InvalidBlock;
                    }
                    continue;
                }
            }
            if (!hasTrySetup(&self.cfg.blocks[block_idx])) {
                if (try self.tryDecompileTernaryInto(block_idx, limit, &stmts, a)) |next_block| {
                    block_idx = next_block;
                    if (block_idx <= prev_idx) {
                        if (self.last_error_ctx == null) {
                            self.last_error_ctx = .{
                                .code_name = self.code.name,
                                .block_id = prev_idx,
                                .offset = self.cfg.blocks[prev_idx].start_offset,
                                .opcode = "ternary_no_progress",
                            };
                        }
                        return error.InvalidBlock;
                    }
                    continue;
                }
            }
            const pattern = if (skip_try)
                try self.analyzer.detectPatternNoTry(block_idx)
            else
                try self.analyzer.detectPattern(block_idx);

            switch (pattern) {
                .if_stmt => |p| {
                    const cond_block = &self.cfg.blocks[p.condition_block];
                    var last_stmt_idx: ?usize = null;
                    for (cond_block.instructions, 0..) |inst, idx| {
                        if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                        if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
                        switch (inst.opcode) {
                            .STORE_FAST,
                            .STORE_NAME,
                            .STORE_GLOBAL,
                            .STORE_DEREF,
                            .STORE_ATTR,
                            .STORE_SUBSCR,
                            .POP_TOP,
                            .DELETE_NAME,
                            .DELETE_FAST,
                            .DELETE_GLOBAL,
                            .DELETE_DEREF,
                            .DELETE_ATTR,
                            .DELETE_SUBSCR,
                            .RETURN_VALUE,
                            .RETURN_CONST,
                            .RAISE_VARARGS,
                            => last_stmt_idx = idx + 1,
                            else => {},
                        }
                    }

                    const skip_cond = last_stmt_idx orelse 0;
                    if (skip_cond == 0) {
                        if (try self.shouldSkipIfForWithTernary(p)) |merge_id| {
                            block_idx = merge_id;
                            if (block_idx <= prev_idx) {
                                if (self.last_error_ctx == null) {
                                    self.last_error_ctx = .{
                                        .code_name = self.code.name,
                                        .block_id = prev_idx,
                                        .offset = self.cfg.blocks[prev_idx].start_offset,
                                        .opcode = "if_with_ternary_no_progress",
                                    };
                                }
                                return error.InvalidBlock;
                            }
                            continue;
                        }
                    }
                    if (skip_cond > 0) {
                        var skip_first_store = false;
                        try self.processPartialBlock(cond_block, &stmts, a, &skip_first_store, skip_cond);
                    }
                    if (try self.shouldSkipIfForTernaryStore(p)) |merge_id| {
                        block_idx = merge_id;
                        if (block_idx <= prev_idx) {
                            if (self.last_error_ctx == null) {
                                self.last_error_ctx = .{
                                    .code_name = self.code.name,
                                    .block_id = prev_idx,
                                    .offset = self.cfg.blocks[prev_idx].start_offset,
                                    .opcode = "if_ternary_store_no_progress",
                                };
                            }
                            return error.InvalidBlock;
                        }
                        continue;
                    }

                    const stmt = if (skip_cond > 0)
                        try self.decompileIfWithSkip(p, skip_cond)
                    else
                        try self.decompileIf(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                        try self.appendIfTail(&stmts, a);
                    }
                    var if_next = self.if_next;
                    if (if_next != null and if_next.? <= p.condition_block) {
                        self.if_next = null;
                        if_next = null;
                    }
                    if (if_next) |next| {
                        block_idx = next;
                        self.if_next = null;
                        self.chained_cmp_next_block = null;
                    } else if (self.chained_cmp_next_block) |chain_next| {
                        block_idx = chain_next;
                        self.chained_cmp_next_block = null;
                    } else {
                        block_idx = try self.findIfChainEnd(p);
                    }
                },
                .while_loop => |p| {
                    const stmt = try self.decompileWhile(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    if (self.analyzer.loopSet(p.header_block)) |body| {
                        var it = body.iterator(.{});
                        while (it.next()) |idx| {
                            const bid: u32 = @intCast(idx);
                            if (bid >= limit) continue;
                            try self.consumed.set(self.allocator, bid);
                        }
                    }
                    if (self.loop_next) |next| {
                        block_idx = next;
                        self.loop_next = null;
                    } else {
                        block_idx = p.exit_block;
                    }
                },
                .for_loop => |p| {
                    if (try self.tryDecompileInlineListComp(p)) |result| {
                        self.deinitStackValues(result.stack);
                        block_idx = result.exit_block;
                        continue;
                    }
                    try self.emitForPrelude(p, &stmts, a);
                    const stmt = try self.decompileFor(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    if (self.analyzer.loopSet(p.header_block)) |body| {
                        var it = body.iterator(.{});
                        while (it.next()) |idx| {
                            const bid: u32 = @intCast(idx);
                            if (bid >= limit) continue;
                            try self.consumed.set(self.allocator, bid);
                        }
                    }
                    block_idx = p.exit_block;
                },
                .try_stmt => |p| {
                    if (try self.tryDecompileAsyncFor(p)) |result| {
                        if (result.stmt) |s| {
                            try stmts.append(a, s);
                        }
                        block_idx = result.next_block;
                        continue;
                    }
                    const result = try self.decompileTry(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                },
                .with_stmt => |p| {
                    const result = try self.decompileWith(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                },
                .match_stmt => |p| {
                    try self.emitMatchPrelude(p.subject_block, &stmts, a);
                    const result = try self.decompileMatch(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                },
                else => {
                    const block = &self.cfg.blocks[block_idx];
                    if (block.is_loop_header) {
                        if (try self.decompileLoopHeader(block_idx)) |result| {
                            if (result.stmt) |s| {
                                try stmts.append(a, s);
                            }
                            block_idx = result.next_block;
                        }
                    }
                    if (try self.shouldDeferForPrelude(block_idx, limit)) {
                        block_idx += 1;
                        continue;
                    }
                    const seed = if (block_idx == start)
                        init_stack
                    else if (block_idx < self.stack_in.len)
                        (self.stack_in[block_idx] orelse &.{})
                    else
                        &.{};
                    try self.decompileBlockIntoWithStack(block_idx, &stmts, a, seed);
                    block_idx += 1;
                },
            }
            if (block_idx <= prev_idx) {
                stmts.items.len = stmts_len;
                const seed = if (block_idx == start)
                    init_stack
                else if (block_idx < self.stack_in.len)
                    (self.stack_in[block_idx] orelse &.{})
                else
                    &.{};
                try self.decompileBlockIntoWithStack(block_idx, &stmts, a, seed);
                block_idx = prev_idx + 1;
            }
            if (block_idx <= prev_idx) {
                if (self.last_error_ctx == null) {
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = prev_idx,
                        .offset = self.cfg.blocks[prev_idx].start_offset,
                        .opcode = "structured_no_progress",
                    };
                }
                return error.InvalidBlock;
            }
        }

        if (stmts.items.len >= 2) {
            var i: usize = 0;
            while (i + 1 < stmts.items.len) : (i += 1) {
                const cur = stmts.items[i];
                const next = stmts.items[i + 1];
                if (cur.* == .if_stmt and self.stmtIsTerminal(next)) {
                    self.pruneTrailingTerminalInStmt(cur, next);
                }
            }
        }

        if (stmts.items.len >= 2) {
            var i: usize = 0;
            while (i + 1 < stmts.items.len) : (i += 1) {
                const cur = stmts.items[i];
                const next = stmts.items[i + 1];
                if (cur.* == .try_stmt and next.* == .expr_stmt) {
                    const t = &cur.try_stmt;
                    if (t.body.len > 0) {
                        const last = t.body[t.body.len - 1];
                        if (last.* == .if_stmt) {
                            var ifs = &last.if_stmt;
                            if (ifs.else_body.len > 0) {
                                const else_last = ifs.else_body[ifs.else_body.len - 1];
                                if (else_last.* == .expr_stmt) {
                                    if (ast.exprEqual(else_last.expr_stmt.value, next.expr_stmt.value)) {
                                        ifs.else_body = ifs.else_body[0 .. ifs.else_body.len - 1];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        const merged = try self.mergeContGuards(stmts.items);
        return try self.rewriteContRaise(merged);
    }

    fn computeHandlerEnd311(self: *Decompiler, body_block: u32) DecompileError!u32 {
        if (body_block >= self.cfg.blocks.len) {
            if (self.last_error_ctx == null) {
                self.last_error_ctx = .{
                    .code_name = self.code.name,
                    .block_id = body_block,
                    .offset = 0,
                    .opcode = "handler_body_oob",
                };
            }
            return error.InvalidBlock;
        }

        if (self.try_scratch == null) {
            _ = try self.getTryScratch(self.cfg.blocks.len);
        }
        const scratch = &self.try_scratch.?;
        if (scratch.handler_end.get(body_block)) |cached| {
            return cached;
        }

        try self.cond_seen.ensureSize(self.allocator, self.cfg.blocks.len);
        self.cond_seen.reset();
        self.cond_stack.clearRetainingCapacity();
        try self.cond_stack.append(self.allocator, body_block);

        var best_pop: ?u32 = null;
        var best_off: u32 = 0;
        var best_any: ?u32 = null;
        var best_any_off: u32 = 0;

        while (self.cond_stack.items.len > 0) {
            const cur = self.cond_stack.items[self.cond_stack.items.len - 1];
            self.cond_stack.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (self.cond_seen.isSet(cur)) continue;
            try self.cond_seen.set(self.allocator, cur);

            const blk = &self.cfg.blocks[cur];
            var has_pop_except = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .POP_EXCEPT) {
                    has_pop_except = true;
                    break;
                }
            }
            if (has_pop_except) {
                const off = blk.start_offset;
                if (best_any == null or off > best_any_off or (off == best_any_off and cur > best_any.?)) {
                    best_any = cur;
                    best_any_off = off;
                }
                if (try self.postDominates(cur, body_block)) {
                    if (best_pop == null or off > best_off or (off == best_off and cur > best_pop.?)) {
                        best_pop = cur;
                        best_off = off;
                    }
                }
            }

            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (!self.cond_seen.isSet(next)) {
                    try self.cond_stack.append(self.allocator, next);
                }
            }
        }

        if (best_pop) |pop_id| {
            const end = pop_id + 1;
            try scratch.handler_end.put(self.allocator, body_block, end);
            return end;
        }
        if (best_any) |pop_id| {
            const end = pop_id + 1;
            try scratch.handler_end.put(self.allocator, body_block, end);
            return end;
        }

        if (self.last_error_ctx == null) {
            self.last_error_ctx = .{
                .code_name = self.code.name,
                .block_id = body_block,
                .offset = self.cfg.blocks[body_block].start_offset,
                .opcode = "handler_end_no_pop_except",
            };
        }
        return error.InvalidBlock;
    }

    /// Decompile try/except for Python 3.11+
    fn decompileTry311(
        self: *Decompiler,
        pattern: ctrl.TryPattern,
        handler_ids: []const u32,
    ) DecompileError!PatternResult {
        const a = self.arena.allocator();

        // Find first handler block
        if (handler_ids.len == 0) {
            return .{ .stmt = null, .next_block = pattern.try_block + 1 };
        }

        const first_handler = handler_ids[0];
        const max_handler = handler_ids[handler_ids.len - 1];

        // Decompile try body (blocks from try_block to first handler, or to else block)
        const try_end = pattern.else_block orelse first_handler;
        const try_body = try self.decompileBlockRangeWithStack(
            pattern.try_block,
            try_end,
            &.{},
        );

        // Decompile handlers - follow the chain of CHECK_EXC_MATCH blocks
        var handlers: std.ArrayListUnmanaged(ast.ExceptHandler) = .{};
        errdefer handlers.deinit(a);

        // Track actual end of all handler blocks for marking processed
        var actual_end: u32 = max_handler + 1;

        // Start with first handler block (has PUSH_EXC_INFO)
        var current_handler: ?u32 = first_handler;

        while (current_handler) |hid| {
            if (hid >= self.cfg.blocks.len) break;
            const handler_block = &self.cfg.blocks[hid];

            // Check if this is a valid handler block or finally block
            var has_push_exc = false;
            var has_check_match = false;
            var has_reraise = false;
            var has_pop_top = false;
            var has_pop_except = false;
            for (handler_block.instructions) |inst| {
                if (inst.opcode == .PUSH_EXC_INFO) has_push_exc = true;
                if (inst.opcode == .CHECK_EXC_MATCH) has_check_match = true;
                if (inst.opcode == .RERAISE) has_reraise = true;
                if (inst.opcode == .POP_TOP) has_pop_top = true;
                if (inst.opcode == .POP_EXCEPT) has_pop_except = true;
            }
            // Stop if we hit a RERAISE-only block (cleanup, not handler)
            if (!has_push_exc and !has_check_match and has_reraise) break;

            // Check for finally pattern: PUSH_EXC_INFO + RERAISE without POP_EXCEPT
            // Finally handlers re-raise after cleanup, except handlers use POP_EXCEPT
            if (has_push_exc and has_reraise and !has_pop_except and !has_check_match) {
                // This is a finally block - extract finally body from handler
                // The finally code is between PUSH_EXC_INFO and RERAISE
                var finally_start: usize = 0;
                var finally_end: usize = handler_block.instructions.len;
                for (handler_block.instructions, 0..) |inst, i| {
                    if (inst.opcode == .PUSH_EXC_INFO) {
                        finally_start = i + 1;
                    } else if (inst.opcode == .RERAISE) {
                        finally_end = i;
                        break;
                    }
                }
                // Decompile finally body from the handler block
                const finally_body = try self.decompileBlockRangeWithStackAndSkip(
                    hid,
                    hid + 1,
                    &.{},
                    finally_start,
                );
                // Build try/finally statement (no handlers)
                const try_stmt = try a.create(Stmt);
                try_stmt.* = .{
                    .try_stmt = .{
                        .body = try_body,
                        .handlers = &.{},
                        .else_body = &.{},
                        .finalbody = finally_body,
                    },
                };
                try self.normalizeTryFinalbody(try_stmt);
                self.analyzer.markProcessed(pattern.try_block, hid + 2);
                return .{ .stmt = try_stmt, .next_block = hid + 2 };
            }

            // Skip if block has neither handler pattern
            if (!has_push_exc and !has_check_match and !has_pop_top) break;

            // Extract exception type and name from handler header
            // Python 3.11+ handler patterns:
            // - Bare except: PUSH_EXC_INFO, POP_TOP, <body>, POP_EXCEPT
            // - except Type: PUSH_EXC_INFO, <load type>, CHECK_EXC_MATCH, POP_JUMP_IF_FALSE, POP_TOP, <body>
            // - except Type as e: PUSH_EXC_INFO, <load type>, CHECK_EXC_MATCH, POP_JUMP_IF_FALSE, STORE_*, <body>
            var exc_type: ?*Expr = null;
            var exc_name: ?[]const u8 = null;
            var body_skip: usize = 0;

            var sim = self.initSim(a, a, self.code, self.version);
            defer sim.deinit();

            var seen_push_exc = false;
            var seen_check_match = false;
            var seen_cond_jump = false;

            var is_star = false; // except* vs except

            for (handler_block.instructions, 0..) |inst, i| {
                switch (inst.opcode) {
                    .PUSH_EXC_INFO => {
                        seen_push_exc = true;
                        // Push placeholder for exception info (needed for COPY 2 in except*)
                        try sim.stack.push(.unknown);
                        body_skip = i + 1;
                    },
                    .NOT_TAKEN => {
                        // NOT_TAKEN is just a marker, skip and continue
                        body_skip = i + 1;
                    },
                    .BUILD_LIST => {
                        // except* uses BUILD_LIST 0 at start to collect exceptions
                        if (inst.arg == 0 and !seen_check_match) {
                            is_star = true;
                            try sim.simulate(inst);
                            body_skip = i + 1;
                        } else {
                            try sim.simulate(inst);
                        }
                    },
                    .COPY => {
                        // except* uses COPY to duplicate exception group
                        try sim.simulate(inst);
                        body_skip = i + 1;
                    },
                    .POP_TOP => {
                        if (seen_push_exc and !seen_check_match) {
                            // Bare except (first handler) - POP_TOP discards exception
                            body_skip = i + 1;
                            break;
                        } else if (!seen_push_exc and !seen_check_match and i == 0) {
                            // Bare except (chained) - POP_TOP at start of block
                            body_skip = i + 1;
                            break;
                        } else if (seen_cond_jump) {
                            // After conditional jump in typed except - pops exception value
                            body_skip = i + 1;
                            break;
                        }
                        body_skip = i + 1;
                    },
                    .CHECK_EXC_MATCH => {
                        // Exception type is on stack BEFORE this instruction consumes it
                        seen_check_match = true;
                        if (sim.stack.peek()) |val| {
                            switch (val) {
                                .expr => |e| exc_type = e,
                                else => {},
                            }
                        }
                        // Don't pop - let simulation handle it (it pushes bool)
                        body_skip = i + 1;
                    },
                    .CHECK_EG_MATCH => {
                        // except* exception group matching (PEP 654)
                        is_star = true;
                        seen_check_match = true;
                        if (sim.stack.peek()) |val| {
                            switch (val) {
                                .expr => |e| exc_type = e,
                                else => {},
                            }
                        }
                        try sim.simulate(inst);
                        body_skip = i + 1;
                    },
                    .POP_JUMP_IF_FALSE, .POP_JUMP_IF_TRUE, .POP_JUMP_IF_NONE, .POP_JUMP_IF_NOT_NONE => {
                        seen_cond_jump = true;
                        body_skip = i + 1;
                    },
                    .STORE_NAME, .STORE_FAST, .STORE_GLOBAL => {
                        if (seen_cond_jump) {
                            // This is "except Type as name:" - store the exception name
                            exc_name = switch (inst.opcode) {
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg),
                                .STORE_FAST => sim.getLocal(inst.arg),
                                else => null,
                            };
                            body_skip = i + 1;
                            break;
                        }
                        // Otherwise it's part of body
                        break;
                    },
                    else => {
                        try sim.simulate(inst);
                    },
                }
            }


            // For typed except, body is in fall-through successor after cond jump
            // Also track next handler (conditional_false = exception didn't match)
            var body_block = hid;
            var next_handler_block: ?u32 = null;
            if (seen_check_match and seen_cond_jump) {
                // Body is NOT_TAKEN path (conditional_true = exception matched)
                // Next handler is conditional_false path (exception didn't match)
                for (handler_block.successors) |edge| {
                    if (edge.edge_type == .conditional_true) {
                        body_block = edge.target;
                        body_skip = 0;
                    } else if (edge.edge_type == .conditional_false) {
                        next_handler_block = edge.target;
                    }
                }
                // Check body block for "as name:" binding (NOT_TAKEN, STORE_NAME pattern)
                // Note: NOT_TAKEN, POP_TOP, or STORE_NAME may be in next block if CFG split them
                var check_block = body_block;
                while (check_block < self.cfg.blocks.len and check_block < body_block + 2) {
                    const check_blk = &self.cfg.blocks[check_block];
                    for (check_blk.instructions, 0..) |inst, i| {
                        const is_first_block = (check_block == body_block);
                        if (inst.opcode == .NOT_TAKEN) {
                            if (is_first_block) body_skip = i + 1;
                        } else if (inst.opcode == .STORE_NAME or inst.opcode == .STORE_FAST or inst.opcode == .STORE_GLOBAL) {
                            // "except Type as name:" - extract name
                            exc_name = switch (inst.opcode) {
                                .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg),
                                .STORE_FAST => sim.getLocal(inst.arg),
                                else => null,
                            };
                            if (is_first_block) {
                                body_skip = i + 1;
                            } else {
                                // Binding is in next block, skip entire first block
                                body_skip = check_blk.instructions.len;
                                body_block = check_block;
                                body_skip = 1;
                            }
                            check_block = @intCast(self.cfg.blocks.len); // Break outer loop
                            break;
                        } else if (inst.opcode == .POP_TOP) {
                            // "except Type:" without name binding
                            if (is_first_block) {
                                body_skip = i + 1;
                            } else {
                                // POP_TOP is in next block, skip it
                                body_block = check_block;
                                body_skip = 1;
                            }
                            check_block = @intCast(self.cfg.blocks.len); // Break outer loop
                            break;
                        } else {
                            check_block = @intCast(self.cfg.blocks.len); // Break outer loop
                            break;
                        }
                    }
                    check_block += 1;
                }
            }

            const handler_end_block = try self.computeHandlerEnd311(body_block);

            // Decompile handler body (seed exception stack for handler context)
            const handler_seed = if (handler_block.is_exception_handler or self.cfg.blocks[body_block].is_exception_handler) blk: {
                const e1 = try a.create(Expr);
                e1.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                const e2 = try a.create(Expr);
                e2.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                const e3 = try a.create(Expr);
                e3.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                break :blk &[_]StackValue{ .{ .expr = e1 }, .{ .expr = e2 }, .{ .expr = e3 } };
            } else &.{};

            var handler_body = try self.decompileBlockRangeWithStackAndSkip(
                body_block,
                handler_end_block,
                handler_seed,
                body_skip,
            );
            handler_body = try self.trimExceptionCleanup(handler_body, exc_name);
            handler_body = try self.rewriteAwaitReturn(handler_body);
            handler_body = try self.rewriteHandlerReturnExpr(handler_body, body_block, handler_end_block);
            handler_body = try self.stripNestedExceptionCleanup(handler_body, exc_name);
            handler_body = try self.moveReturnNoneIntoElse(handler_body);

            try handlers.append(a, .{
                .type = exc_type,
                .name = exc_name,
                .body = handler_body,
                .is_star = is_star,
            });

            // Track the actual end of processed blocks
            if (handler_end_block > actual_end) actual_end = handler_end_block;
            if (body_block >= actual_end) actual_end = body_block + 1;

            // Follow chain to next handler (if any)
            // next_handler_block points to RERAISE or another handler block
            current_handler = null;
            if (next_handler_block) |next_blk| {
                if (next_blk < self.cfg.blocks.len) {
                    const next_block = &self.cfg.blocks[next_blk];
                    // Check if this is another handler (has CHECK_EXC_MATCH or starts with POP_TOP for bare except)
                    var is_handler = false;
                    for (next_block.instructions) |inst| {
                        if (inst.opcode == .CHECK_EXC_MATCH) {
                            is_handler = true;
                            break;
                        }
                        if (inst.opcode == .RERAISE) {
                            // This is the end of handlers
                            break;
                        }
                    }
                    // Also check for bare except (POP_TOP followed by handler body)
                    if (!is_handler and next_block.instructions.len > 0) {
                        const first_op = next_block.instructions[0].opcode;
                        if (first_op == .POP_TOP) {
                            // This is a bare except handler
                            is_handler = true;
                        }
                    }
                    if (is_handler) {
                        current_handler = next_blk;
                    }
                    if (next_blk >= actual_end) actual_end = next_blk + 1;
                }
            }
        }

        if (handlers.items.len == 0) {
            // No real handlers, skip
            return .{ .stmt = null, .next_block = max_handler + 1 };
        }

        // Decompile else block if present
        var else_body: []const *Stmt = &.{};
        var else_end_block = first_handler;
        if (pattern.else_block) |else_start| {
            // Determine where else block ends
            if (pattern.finally_block) |finally_start| {
                else_end_block = finally_start;
            }
            // Else block runs from else_start to finally or first handler
            else_body = try self.decompileBlockRangeWithStack(
                else_start,
                else_end_block,
                &.{},
            );
            if (else_end_block >= actual_end) actual_end = else_end_block;
        }

        // Decompile finally block if present
        var final_body: []const *Stmt = &.{};
        if (pattern.finally_block) |finally_start| {
            const finally_end = pattern.exit_block orelse @as(u32, @intCast(self.cfg.blocks.len));
            final_body = try self.decompileBlockRangeWithStack(
                finally_start,
                finally_end,
                &.{},
            );
            if (finally_end >= actual_end) actual_end = finally_end;
        }

        // Mark all processed blocks to prevent re-detection
        self.analyzer.markProcessed(pattern.try_block, actual_end);

        // Build try statement
        const try_stmt = try a.create(Stmt);
        try_stmt.* = .{
            .try_stmt = .{
                .body = try_body,
                .handlers = try handlers.toOwnedSlice(a),
                .else_body = else_body,
                .finalbody = final_body,
            },
        };
        try self.normalizeTryFinalbody(try_stmt);

        return .{ .stmt = try_stmt, .next_block = actual_end };
    }

    fn decompileTryBody(
        self: *Decompiler,
        start: u32,
        end: u32,
        loop_header: ?u32,
        visited: ?*std.DynamicBitSet,
    ) DecompileError![]const *Stmt {
        if (start >= end or start >= self.cfg.blocks.len) return &[_]*Stmt{};
        const start_block = &self.cfg.blocks[start];
        const prev_limit = self.br_limit;
        self.br_limit = end;
        defer self.br_limit = prev_limit;
        var has_cond = false;
        for (start_block.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                has_cond = true;
                break;
            }
        }

        if (has_cond) {
            {
                const a = self.arena.allocator();
                var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                errdefer stmts.deinit(a);
                if (try self.tryDecompileBoolOpInto(start, end, &stmts, a)) |next_block| {
                    if (next_block < end and next_block < self.cfg.blocks.len) {
                        const rest = if (loop_header != null)
                            try self.decompileTryBody(next_block, end, loop_header, visited)
                        else
                            try self.decompileStructuredRangeNoTry(next_block, end);
                        try stmts.appendSlice(a, rest);
                    }
                    return stmts.toOwnedSlice(a);
                }
            }

            var pattern = if (loop_header != null)
                try self.analyzer.detectPatternNoTryInLoop(start)
            else
                try self.analyzer.detectPatternNoTry(start);
            if (pattern == .while_loop and loop_header != null) {
                const header_id = loop_header.?;
                if (pattern.while_loop.header_block == header_id and start == header_id) {
                    if (try self.analyzer.detectIfOnly(start)) |if_pat| {
                        const then_in = self.analyzer.inLoop(if_pat.then_block, header_id);
                        const else_in = if_pat.else_block != null and
                            self.analyzer.inLoop(if_pat.else_block.?, header_id);
                        if (then_in and else_in) {
                            pattern = .{ .if_stmt = if_pat };
                        }
                    }
                }
            }
            if (pattern == .if_stmt) {
                var if_pat = pattern.if_stmt;
                if (if_pat.else_block == null) {
                    if (if_pat.condition_block < self.cfg.blocks.len) {
                        const cond_blk = &self.cfg.blocks[if_pat.condition_block];
                        if (cond_blk.terminator()) |t| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, t.opcode)) {
                                var false_id: ?u32 = null;
                                for (cond_blk.successors) |edge| {
                                    if (edge.edge_type == .conditional_false) {
                                        false_id = edge.target;
                                        break;
                                    }
                                }
                                if (false_id != null and false_id.? != if_pat.then_block) {
                                    if_pat.else_block = false_id;
                                }
                            }
                        }
                    }
                }
                var merge_in_range: ?u32 = null;
                if (if_pat.else_block) |else_id| {
                    var reach_then = try self.reachableInRange(if_pat.then_block, end, null);
                    defer reach_then.deinit();
                    var reach_else = try self.reachableInRange(else_id, end, null);
                    defer reach_else.deinit();
                    var skip_else_merge = false;
                    if (if_pat.then_block < self.cfg.blocks.len) {
                        const then_blk = &self.cfg.blocks[if_pat.then_block];
                        if (!condBlockHasPrelude(then_blk)) {
                            if (then_blk.terminator()) |then_term| {
                                if (ctrl.Analyzer.isConditionalJump(undefined, then_term.opcode)) {
                                    for (then_blk.successors) |edge| {
                                        if (edge.edge_type == .conditional_false and edge.target == else_id) {
                                            skip_else_merge = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    var bid = if_pat.condition_block + 1;
                    while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
                        if (skip_else_merge and bid == else_id) continue;
                        if (reach_then.isSet(bid) and reach_else.isSet(bid)) {
                            merge_in_range = bid;
                            break;
                        }
                    }
                    if (merge_in_range) |fb| {
                        if (if_pat.merge_block == null or if_pat.merge_block.? >= end or fb < if_pat.merge_block.?) {
                            if_pat.merge_block = fb;
                        }
                    } else if (if_pat.merge_block) |merge_id| {
                        if (merge_id >= end) {
                            if_pat.merge_block = null;
                        }
                    }
                } else if (if_pat.merge_block) |merge_id| {
                    if (merge_id >= end) {
                        if_pat.merge_block = null;
                    }
                }
                if (if_pat.merge_block) |merge_id| {
                    if (merge_id < end and merge_id < self.cfg.blocks.len) {
                        if (self.jumpTargetIfJumpOnly(merge_id, true) != null) {
                            const merge_blk = &self.cfg.blocks[merge_id];
                            if (merge_blk.predecessors.len == 1) {
                                const pred_id = merge_blk.predecessors[0];
                                if (pred_id < self.cfg.blocks.len and pred_id < end) {
                                    const pred_blk = &self.cfg.blocks[pred_id];
                                    if (pred_blk.instructions.len > 0 and
                                        pred_blk.instructions[pred_blk.instructions.len - 1].opcode == .POP_BLOCK)
                                    {
                                        if_pat.merge_block = pred_id;
                                    }
                                }
                            }
                        }
                    }
                }
                var last_stmt_idx: ?usize = null;
                for (start_block.instructions, 0..) |inst, idx| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                    if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
                    switch (inst.opcode) {
                        .STORE_FAST,
                        .STORE_NAME,
                        .STORE_GLOBAL,
                        .STORE_DEREF,
                        .STORE_ATTR,
                        .STORE_SUBSCR,
                        .POP_TOP,
                        .DELETE_NAME,
                        .DELETE_FAST,
                        .DELETE_GLOBAL,
                        .DELETE_DEREF,
                        .DELETE_ATTR,
                        .DELETE_SUBSCR,
                        .RETURN_VALUE,
                        .RETURN_CONST,
                        .RAISE_VARARGS,
                        => last_stmt_idx = idx + 1,
                        else => {},
                    }
                }

                const skip_cond = last_stmt_idx orelse 0;
                if (skip_cond == 0) {
                    if (try self.shouldSkipIfForWithTernary(if_pat)) |merge_id| {
                        if (merge_id >= end or merge_id >= self.cfg.blocks.len) {
                            return &[_]*Stmt{};
                        }
                        return if (loop_header != null)
                            try self.decompileTryBody(merge_id, end, loop_header, visited)
                        else
                            try self.decompileStructuredRangeNoTry(merge_id, end);
                    }
                }
                var local_vis: ?std.DynamicBitSet = null;
                var vis_ptr = visited;
                if (loop_header != null and vis_ptr == null) {
                    local_vis = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                    vis_ptr = &local_vis.?;
                }
                defer if (local_vis) |*v| v.deinit();

                const a = self.arena.allocator();
                var stmt: ?*Stmt = null;
                var guard_then: ?[]const *Stmt = null;
                if (loop_header) |header| {
                    var loop_exit = self.loopBlockLeadsToContinue(if_pat.then_block, header) or
                        self.loopBlockLeadsToBreak(if_pat.then_block, header) or
                        self.blockLeadsToHeader(if_pat.then_block, header);
                    if (!loop_exit) {
                        if (if_pat.else_block) |else_id| {
                            loop_exit = self.loopBlockLeadsToContinue(else_id, header) or
                                self.loopBlockLeadsToBreak(else_id, header) or
                                self.blockLeadsToHeader(else_id, header);
                        }
                    }
                    if (loop_exit) {
                        if (vis_ptr) |v| {
                            const stop_block = if (end < self.cfg.blocks.len) end else null;
                            if (try self.loopIfParts(if_pat, header, v, stop_block)) |parts| {
                                var use_else_cont = parts.else_is_continuation;
                                if (use_else_cont and parts.else_body.len > 0) {
                                    const only_cont = parts.else_body.len == 1 and parts.else_body[0].* == .continue_stmt;
                                    if (!only_cont) {
                                        use_else_cont = false;
                                    }
                                }
                                const else_cont = if (use_else_cont and parts.else_block != null) blk: {
                                    const else_id = parts.else_block.?;
                                    if (self.resolveJumpOnlyBlock(else_id) == header or self.loopBlockLeadsToContinue(else_id, header)) {
                                        break :blk true;
                                    }
                                    break :blk false;
                                } else false;
                                if (else_cont) {
                                    const else_is_jump_target = self.elseIsJumpTarget(parts.cond_op);
                                    if (else_is_jump_target) {
                                        const if_stmt = try a.create(Stmt);
                                        if_stmt.* = .{ .if_stmt = .{
                                            .condition = parts.condition,
                                            .body = parts.then_body,
                                            .else_body = parts.else_body,
                                        } };
                                        stmt = if_stmt;
                                    } else {
                                        const guard_cond = try self.guardCondForBranch(parts.condition, parts.cond_op, else_is_jump_target);
                                        var guard_body = parts.else_body;
                                        var needs_continue = true;
                                        if (guard_body.len > 0) {
                                            const last = guard_body[guard_body.len - 1];
                                            if (last.* == .continue_stmt or self.stmtIsTerminal(last)) {
                                                needs_continue = false;
                                            }
                                        }
                                        if (needs_continue) {
                                            const cont = try self.makeContinue();
                                            const next_body = try a.alloc(*Stmt, guard_body.len + 1);
                                            if (guard_body.len > 0) {
                                                std.mem.copyForwards(*Stmt, next_body[0..guard_body.len], guard_body);
                                            }
                                            next_body[guard_body.len] = cont;
                                            guard_body = next_body;
                                        }
                                        const guard_stmt = try a.create(Stmt);
                                        guard_stmt.* = .{ .if_stmt = .{
                                            .condition = guard_cond,
                                            .body = guard_body,
                                            .else_body = &.{},
                                        } };
                                        stmt = guard_stmt;
                                        guard_then = parts.then_body;
                                    }
                                } else if (use_else_cont) {
                                    const if_stmt = try a.create(Stmt);
                                    if_stmt.* = .{ .if_stmt = .{
                                        .condition = parts.condition,
                                        .body = parts.then_body,
                                        .else_body = &.{},
                                    } };
                                    stmt = if_stmt;
                                    guard_then = parts.else_body;
                                } else {
                                    const if_stmt = try a.create(Stmt);
                                    if_stmt.* = .{ .if_stmt = .{
                                        .condition = parts.condition,
                                        .body = parts.then_body,
                                        .else_body = parts.else_body,
                                    } };
                                    stmt = if_stmt;
                                }
                                if (!else_cont and use_else_cont) {
                                    if (parts.else_block) |else_id| {
                                        const needs_next = guard_then == null or guard_then.?.len == 0;
                                        if (needs_next and self.if_next == null) {
                                            self.if_next = else_id;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (stmt == null) {
                    stmt = if (skip_cond > 0)
                        try self.decompileIfWithSkip(if_pat, skip_cond)
                    else
                        try self.decompileIf(if_pat);
                }
                if (stmt) |s| {
                    var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
                    errdefer stmts.deinit(a);
                    if (skip_cond > 0) {
                        var skip_first_store = false;
                        try self.processPartialBlock(start_block, &stmts, a, &skip_first_store, skip_cond);
                    }
                    try stmts.append(a, s);
                    try self.appendIfTail(&stmts, a);
                    if (guard_then) |body| {
                        if (body.len > 0) {
                            try stmts.appendSlice(a, body);
                        }
                    }
                    var next = try self.findIfChainEnd(if_pat);
                    if (loop_header) |header| {
                        if (if_pat.merge_block) |merge_id| {
                            if (merge_id != header and self.analyzer.inLoop(merge_id, header)) {
                                var use_merge = true;
                                if (if_pat.else_block) |else_id| {
                                    if (else_id < self.cfg.blocks.len and merge_id < self.cfg.blocks.len) {
                                        if (!try self.reachesBlock(else_id, merge_id, if_pat.condition_block)) {
                                            use_merge = false;
                                        }
                                    }
                                }
                                if (use_merge) {
                                    next = merge_id;
                                }
                            }
                        }
                    }
                    var if_next = self.if_next;
                    if (if_next != null and if_next.? <= if_pat.condition_block) {
                        self.if_next = null;
                        if_next = null;
                    }
                    if (if_next != null and if_next.? >= end) {
                        self.if_next = null;
                        if_next = null;
                    }
                    if (if_next) |override| {
                        next = override;
                        self.if_next = null;
                        self.chained_cmp_next_block = null;
                    } else if (self.chained_cmp_next_block) |chain_next| {
                        if (chain_next >= end) {
                            self.chained_cmp_next_block = null;
                        } else {
                        next = chain_next;
                        self.chained_cmp_next_block = null;
                        }
                    }
                    if (merge_in_range) |merge_id| {
                        if (merge_id < end and merge_id < self.cfg.blocks.len) {
                            if (next >= end or merge_id < next) {
                                next = merge_id;
                            }
                        }
                    }
                    if (next >= end or next >= self.cfg.blocks.len) {
                        // Calculate the minimum end of both if branches to avoid reprocessing
                        const then_end = try self.branchEnd(if_pat.then_block, null);
                        var min_next = @min(then_end, end);
                        if (if_pat.else_block) |else_id| {
                            const else_end = try self.branchEnd(else_id, null);
                            min_next = @max(min_next, @min(else_end, end));
                        }
                        // Scan for unconsumed blocks starting from after the if branches
                        var scan = @max(min_next, start + 1);
                        while (scan < end and scan < self.cfg.blocks.len) : (scan += 1) {
                            if (!self.consumed.isSet(scan)) {
                                next = scan;
                                break;
                            }
                        }
                    }
                    if (loop_header != null and vis_ptr != null) {
                        const v = vis_ptr.?;
                        while (next < end and next < self.cfg.blocks.len and v.isSet(next)) : (next += 1) {}
                    }
                    if (next < end and next < self.cfg.blocks.len) {
                        const rest = if (loop_header != null)
                            try self.decompileTryBody(next, end, loop_header, vis_ptr)
                        else
                            try self.decompileStructuredRange(next, end);
                        if (s.* == .if_stmt and rest.len > 0) {
                            var ifs = &s.if_stmt;
                            if (ifs.else_body.len > 0) {
                                const last = ifs.else_body[ifs.else_body.len - 1];
                                const first = rest[0];
                                if (last.* == .expr_stmt and first.* == .expr_stmt) {
                                    if (ast.exprEqual(last.expr_stmt.value, first.expr_stmt.value)) {
                                        ifs.else_body = ifs.else_body[0 .. ifs.else_body.len - 1];
                                    }
                                }
                            }
                        }
                        try stmts.appendSlice(a, rest);
                    }
                    return stmts.toOwnedSlice(a);
                }
            }
        }

        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        var skip_store = false;
        var seed_pop = false;
        try self.processBlockStatements(
            start,
            start_block,
            &stmts,
            &skip_store,
            &seed_pop,
            true,
            loop_header,
            0,
        );

        const next = start + 1;
        if (next < end and next < self.cfg.blocks.len) {
            const rest = try self.decompileStructuredRange(next, end);
            try stmts.appendSlice(a, rest);
        }

        return stmts.toOwnedSlice(a);
    }

    const HandlerHeader = struct {
        exc_type: ?*Expr,
        name: ?[]const u8,
        skip_first_store: bool,
        body_block: u32,
        skip: usize,
    };

    fn extractHandlerHeader(self: *Decompiler, handler_block: u32) DecompileError!HandlerHeader {
        if (handler_block >= self.cfg.blocks.len) return error.InvalidBlock;
        const block = &self.cfg.blocks[handler_block];
        const a = self.arena.allocator();
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        for (0..3) |_| {
            const placeholder = try a.create(Expr);
            placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
            try sim.stack.push(.{ .expr = placeholder });
        }

        var exc_type: ?*Expr = null;
        var name: ?[]const u8 = null;
        var skip_first_store = false;
        var body_block: u32 = handler_block;
        var skip: usize = 0;

        var has_dup = false;
        var has_exc_cmp = false;
        var has_jump = false;
        for (block.instructions) |inst| {
            if (inst.opcode == .JUMP_IF_NOT_EXC_MATCH) {
                has_exc_cmp = true;
                has_jump = true;
                continue;
            }
            switch (inst.opcode) {
                .DUP_TOP => has_dup = true,
                .COMPARE_OP => {
                    if (inst.arg == 10) has_exc_cmp = true;
                },
                .JUMP_IF_FALSE, .POP_JUMP_IF_FALSE, .JUMP_IF_TRUE, .POP_JUMP_IF_TRUE => has_jump = true,
                else => {},
            }
        }
        const legacy = has_dup and has_exc_cmp and has_jump;

        if (legacy) {
            if (exc_type == null) {
                for (block.instructions, 0..) |inst, idx| {
                    if (inst.opcode != .LOAD_GLOBAL and inst.opcode != .LOAD_NAME and inst.opcode != .LOAD_DEREF) continue;
                    if (idx + 1 >= block.instructions.len) continue;
                    if (block.instructions[idx + 1].opcode != .JUMP_IF_NOT_EXC_MATCH) continue;
                    const exc_name = switch (inst.opcode) {
                        .LOAD_GLOBAL, .LOAD_NAME => sim.getName(inst.arg),
                        .LOAD_DEREF => sim.getDeref(inst.arg),
                        else => null,
                    };
                    if (exc_name) |n| {
                        exc_type = try self.makeName(n, .load);
                        break;
                    }
                }
            }
            var found_body = false;
            for (block.successors) |edge| {
                if (edge.edge_type == .conditional_true) {
                    body_block = edge.target;
                    found_body = true;
                    break;
                }
            }
            if (!found_body) {
                for (block.successors) |edge| {
                    if (edge.edge_type == .normal) {
                        body_block = edge.target;
                        break;
                    }
                }
            }

            if (name == null) {
                var saw_pop_top = false;
                for (block.instructions) |inst| {
                    switch (inst.opcode) {
                        .POP_TOP => {
                            saw_pop_top = true;
                            continue;
                        },
                        .STORE_FAST => if (saw_pop_top) {
                            name = sim.getLocal(inst.arg);
                            break;
                        },
                        .STORE_NAME, .STORE_GLOBAL => if (saw_pop_top) {
                            name = sim.getName(inst.arg);
                            break;
                        },
                        .STORE_DEREF => if (saw_pop_top) {
                            name = sim.getDeref(inst.arg);
                            break;
                        },
                        else => {},
                    }
                }
            }

            for (block.instructions) |inst| {
                if (inst.opcode == .COMPARE_OP and inst.arg == 10) {
                    // Pop the exception type - we're taking ownership
                    if (sim.stack.pop()) |val| {
                        switch (val) {
                            .expr => |e| exc_type = e,
                            else => {
                                var v = val;
                                v.deinit(sim.allocator, sim.stack_alloc);
                            },
                        }
                    }
                    break;
                }
                if (inst.opcode == .JUMP_IF_NOT_EXC_MATCH) {
                    if (sim.stack.pop()) |val| {
                        switch (val) {
                            .expr => |e| exc_type = e,
                            else => {
                                var v = val;
                                v.deinit(sim.allocator, sim.stack_alloc);
                            },
                        }
                    }
                    break;
                }
                if (inst.opcode == .DUP_TOP and sim.stack.len() == 0) {
                    const dummy = try a.create(Expr);
                    dummy.* = .{ .name = .{ .id = "<exc>", .ctx = .load } };
                    try sim.stack.push(.{ .expr = dummy });
                }
                try sim.simulate(inst);
            }

            if (body_block < self.cfg.blocks.len) {
                const body = &self.cfg.blocks[body_block];
                var idx: usize = 0;
                var prev_was_pop = false;
                while (idx < body.instructions.len) {
                    const inst = body.instructions[idx];
                    switch (inst.opcode) {
                        .POP_TOP => {
                            prev_was_pop = true;
                            idx += 1;
                            continue;
                        },
                        .STORE_FAST => if (prev_was_pop and name == null) {
                            name = sim.getLocal(inst.arg);
                            idx += 1;
                            continue;
                        },
                        .STORE_NAME, .STORE_GLOBAL => if (prev_was_pop and name == null) {
                            name = sim.getName(inst.arg);
                            idx += 1;
                            continue;
                        },
                        .STORE_DEREF => if (prev_was_pop and name == null) {
                            name = sim.getDeref(inst.arg);
                            idx += 1;
                            continue;
                        },
                        else => {},
                    }
                    prev_was_pop = false;
                    break;
                }
                skip = idx;
                if (skip >= body.instructions.len) {
                    var next_body: ?u32 = null;
                    for (body.successors) |edge| {
                        if (edge.edge_type == .normal) {
                            next_body = edge.target;
                            break;
                        }
                    }
                    if (next_body) |nb| {
                        body_block = nb;
                        skip = 0;
                    }
                }
            }
        } else {
            for (block.instructions) |inst| {
                if (inst.opcode == .CHECK_EXC_MATCH) {
                    exc_type = try sim.stack.popExpr();
                    break;
                }
                try sim.simulate(inst);
            }

            for (block.instructions) |inst| {
                switch (inst.opcode) {
                    .STORE_FAST => {
                        name = sim.getLocal(inst.arg);
                        break;
                    },
                    .STORE_NAME, .STORE_GLOBAL => {
                        name = sim.getName(inst.arg);
                        break;
                    },
                    .STORE_DEREF => {
                        name = sim.getDeref(inst.arg);
                        break;
                    },
                    else => {},
                }
            }
            skip_first_store = name != null;
        }

        return .{
            .exc_type = exc_type,
            .name = name,
            .skip_first_store = skip_first_store,
            .body_block = body_block,
            .skip = skip,
        };
    }

    fn decompileHandlerBody(
        self: *Decompiler,
        start: u32,
        end: u32,
        skip_first_store: bool,
        skip: usize,
    ) DecompileError![]const *Stmt {
        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        if (start >= end or start >= self.cfg.blocks.len) {
            return &[_]*Stmt{};
        }

        var skip_store = skip_first_store;
        const head_block = &self.cfg.blocks[start];
        var head_has_pop_except = false;
        for (head_block.instructions) |inst| {
            if (inst.opcode == .POP_EXCEPT) {
                head_has_pop_except = true;
                break;
            }
        }
        var head = head_block.*;
        if (skip > 0 and skip < head.instructions.len) {
            head.instructions = head.instructions[skip..];
        }

        if (!skip_first_store) {
            var has_exc_match = false;
            var has_cond_jump = false;
            for (head.instructions) |inst| {
                if (inst.opcode == .CHECK_EXC_MATCH or inst.opcode == .JUMP_IF_NOT_EXC_MATCH or
                    (inst.opcode == .COMPARE_OP and inst.arg == 10))
                {
                    has_exc_match = true;
                }
                if (inst.opcode == .POP_JUMP_IF_FALSE or inst.opcode == .POP_JUMP_IF_TRUE or
                    inst.opcode == .JUMP_IF_FALSE or inst.opcode == .JUMP_IF_TRUE)
                {
                    has_cond_jump = true;
                }
            }
            if ((skip == 0 or has_cond_jump) and !has_exc_match) {
                var exc_stack: [3]StackValue = undefined;
                for (&exc_stack) |*slot| {
                    const placeholder = try a.create(Expr);
                    placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                    slot.* = .{ .expr = placeholder };
                }
                if (self.stack_in.len == 0) {
                    return try self.decompileStructuredRangeNoTryWithStackAllowHandlers(start, end, &exc_stack);
                }
                const limit = @min(end, @as(u32, @intCast(self.stack_in.len)));
                const count = if (start < limit) limit - start else 0;
                var saved = try a.alloc(?[]StackValue, count);
                defer a.free(saved);
                var idx: u32 = 0;
                while (idx < count) : (idx += 1) {
                    const bid = start + idx;
                    saved[idx] = self.stack_in[bid];
                    self.stack_in[bid] = null;
                }
                defer {
                    var ridx: u32 = 0;
                    while (ridx < count) : (ridx += 1) {
                        const bid = start + ridx;
                        self.stack_in[bid] = saved[ridx];
                    }
                }
                return try self.decompileStructuredRangeNoTryWithStackAllowHandlers(start, end, &exc_stack);
            }
        }

        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        var chain_targets: std.ArrayListUnmanaged(*Expr) = .{};
        defer chain_targets.deinit(self.allocator);

        // Python pushes (type, value, traceback) on stack when entering handler
        // Use placeholder exprs so operations like COMPARE_OP work
        for (0..3) |_| {
            const placeholder = try a.create(Expr);
            placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
            try sim.stack.push(.{ .expr = placeholder });
        }

        var i: usize = 0;
        while (i < head.instructions.len) : (i += 1) {
            const inst = head.instructions[i];
            if (inst.opcode == .POP_EXCEPT) {
                try sim.simulate(inst);
                continue;
            }
            errdefer if (self.last_error_ctx == null) {
                self.last_error_ctx = .{
                    .code_name = self.code.name,
                    .block_id = start,
                    .offset = inst.offset,
                    .opcode = inst.opcode.name(),
                };
            };

            if (inst.opcode == .IMPORT_NAME) {
                if (try self.tryDecompileImportFromGroup(&sim, head.instructions, i, &stmts, a)) |end_idx| {
                    i = end_idx;
                    continue;
                }
            }

            switch (inst.opcode) {
                .UNPACK_SEQUENCE, .UNPACK_EX => {
                    const skip_count = try self.handleUnpack(&sim, &chain_targets, head.instructions, i, &stmts, a);
                    i += skip_count;
                    continue;
                },
                .STORE_FAST, .STORE_NAME, .STORE_GLOBAL, .STORE_DEREF => {
                    if (skip_store) {
                        skip_store = false;
                        try sim.simulate(inst);
                        continue;
                    }
                    const name = switch (inst.opcode) {
                        .STORE_FAST => sim.getLocal(inst.arg),
                        .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg),
                        .STORE_DEREF => sim.getDeref(inst.arg),
                        else => unreachable,
                    };
                    if (name) |n| {
                        var value = sim.stack.pop() orelse {
                            try sim.simulate(inst);
                            continue;
                        };
                        if (value == .unknown or value == .null_marker) {
                            const real_idx = skip + i;
                            if (try self.tryRecoverTernaryStore(start, real_idx)) |expr| {
                                value.deinit(sim.allocator, sim.stack_alloc);
                                value = .{ .expr = expr };
                            }
                        }
                        if (try self.handleStoreValue(&sim, n, value)) |stmt| {
                            try stmts.append(a, stmt);
                        }
                    } else {
                        try sim.simulate(inst);
                    }
                },
                .POP_TOP => {
                    if (sim.stack.len() == 0) continue;
                    const val = sim.stack.pop().?;
                    switch (val) {
                        .expr => |expr| {
                            if (self.makeExprStmt(expr)) |stmt| {
                                try stmts.append(a, stmt);
                            } else |err| {
                                if (err != error.SkipStatement) return err;
                            }
                        },
                        else => val.deinit(sim.allocator, sim.stack_alloc),
                    }
                },
                .RETURN_VALUE => {
                    const value = try sim.stack.popExpr();
                    const stmt = try self.makeReturn(value);
                    try stmts.append(a, stmt);
                },
                .RETURN_CONST => {
                    if (sim.getConst(inst.arg)) |obj| {
                        const value = try sim.objToExpr(obj);
                        const stmt = try self.makeReturn(value);
                        try stmts.append(a, stmt);
                    }
                },
                .EXEC_STMT,
                .RAISE_VARARGS,
                .DELETE_NAME,
                .DELETE_FAST,
                .DELETE_GLOBAL,
                .DELETE_DEREF,
                .DELETE_ATTR,
                .DELETE_SUBSCR,
                .DELETE_SLICE_0,
                .DELETE_SLICE_1,
                .DELETE_SLICE_2,
                .DELETE_SLICE_3,
                => {
                    if (try self.tryEmitStatement(inst, &sim, start, skip + i)) |stmt| {
                        try stmts.append(a, stmt);
                    }
                },
                else => {
                    try sim.simulate(inst);
                },
            }
        }

        if (head_has_pop_except) {
            return stmts.toOwnedSlice(a);
        }

        if (start + 1 < end) {
            var exc_stack: [3]StackValue = undefined;
            for (&exc_stack) |*slot| {
                const placeholder = try a.create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                slot.* = .{ .expr = placeholder };
            }
            const rest_start = start + 1;
            const rest_end = end;
            var saved: ?[]?[]StackValue = null;
            var local: ?[]?[]StackValue = null;
            if (self.stack_in.len > 0) {
                const limit = @min(rest_end, @as(u32, @intCast(self.stack_in.len)));
                if (rest_start < limit) {
                    const local_entries = try self.computeStackInRange(rest_start, limit, &exc_stack);
                    local = local_entries;
                    const count: usize = @intCast(limit - rest_start);
                    const saved_entries = try a.alloc(?[]StackValue, count);
                    saved = saved_entries;
                    var idx: u32 = 0;
                    while (idx < count) : (idx += 1) {
                        const bid = rest_start + idx;
                        saved_entries[@intCast(idx)] = self.stack_in[bid];
                        self.stack_in[bid] = local_entries[@intCast(idx)];
                    }
                }
            }
            defer {
                if (saved) |saved_entries| {
                    const count: usize = saved_entries.len;
                    var idx: usize = 0;
                    while (idx < count) : (idx += 1) {
                        const bid = rest_start + @as(u32, @intCast(idx));
                        self.stack_in[bid] = saved_entries[idx];
                    }
                    a.free(saved_entries);
                }
                if (local) |local_entries| {
                    for (local_entries) |entry_opt| {
                        if (entry_opt) |entry| {
                            if (entry.len > 0) self.allocator.free(entry);
                        }
                    }
                    self.allocator.free(local_entries);
                }
            }

            const rest = try self.decompileStructuredRangeNoTryWithStackAllowHandlers(rest_start, rest_end, &exc_stack);
            try stmts.appendSlice(a, rest);
        }

        return stmts.toOwnedSlice(a);
    }

    fn decompileHandlerBodyLinear(
        self: *Decompiler,
        start: u32,
        end: u32,
        skip: usize,
    ) DecompileError![]const *Stmt {
        if (start >= end or start >= self.cfg.blocks.len) return &[_]*Stmt{};
        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;

        for (0..3) |_| {
            const placeholder = try a.create(Expr);
            placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
            try sim.stack.push(.{ .expr = placeholder });
        }

        var bid = start;
        var first = true;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            const block = &self.cfg.blocks[bid];
            const skip_first = if (first) skip else 0;
            try self.processBlockWithSimAndSkip(block, &sim, &stmts, a, skip_first);
            first = false;
        }

        return stmts.toOwnedSlice(a);
    }

    fn collectReachableNoExceptionInto(
        self: *Decompiler,
        start: u32,
        handler_set: *const GenSet,
        visited: *GenSet,
        queue: *std.ArrayListUnmanaged(u32),
        allow_start_in_handler: bool,
        allow_loop_back: bool,
    ) DecompileError!void {
        visited.reset();
        queue.clearRetainingCapacity();

        if (start >= self.cfg.blocks.len) return;
        if (handler_set.isSet(start) and !allow_start_in_handler) return;

        try visited.set(self.allocator, start);
        try queue.append(self.allocator, start);

        while (queue.items.len > 0) {
            const node = queue.items[queue.items.len - 1];
            queue.items.len -= 1;
            const block = &self.cfg.blocks[node];
            for (block.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (!allow_loop_back and edge.edge_type == .loop_back) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (handler_set.isSet(edge.target)) continue;
                if (!visited.isSet(edge.target)) {
                    try visited.set(self.allocator, edge.target);
                    try queue.append(self.allocator, edge.target);
                }
            }
        }
    }

    fn collectReachableNoExceptionFromStarts(
        self: *Decompiler,
        starts: []const u32,
        handler_set: *const GenSet,
        visited: *GenSet,
        queue: *std.ArrayListUnmanaged(u32),
        allow_loop_back: bool,
    ) DecompileError!void {
        visited.reset();
        queue.clearRetainingCapacity();

        for (starts) |start| {
            if (start >= self.cfg.blocks.len) continue;
            if (visited.isSet(start)) continue;
            try visited.set(self.allocator, start);
            try queue.append(self.allocator, start);
        }

        while (queue.items.len > 0) {
            const node = queue.items[queue.items.len - 1];
            queue.items.len -= 1;
            const block = &self.cfg.blocks[node];
            for (block.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (!allow_loop_back and edge.edge_type == .loop_back) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (handler_set.isSet(edge.target)) continue;
                if (!visited.isSet(edge.target)) {
                    try visited.set(self.allocator, edge.target);
                    try queue.append(self.allocator, edge.target);
                }
            }
        }
    }

    fn reachableNoExceptionAllowHandlers(
        self: *Decompiler,
        start: u32,
        target: u32,
        visited: *GenSet,
        queue: *std.ArrayListUnmanaged(u32),
        allow_loop_back: bool,
    ) DecompileError!bool {
        visited.reset();
        queue.clearRetainingCapacity();

        if (start >= self.cfg.blocks.len or target >= self.cfg.blocks.len) return false;
        try visited.set(self.allocator, start);
        try queue.append(self.allocator, start);

        while (queue.items.len > 0) {
            const node = queue.items[queue.items.len - 1];
            queue.items.len -= 1;
            if (node == target) return true;
            const block = &self.cfg.blocks[node];
            for (block.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (!allow_loop_back and edge.edge_type == .loop_back) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (!visited.isSet(edge.target)) {
                    try visited.set(self.allocator, edge.target);
                    try queue.append(self.allocator, edge.target);
                }
            }
        }
        return false;
    }

    fn isFinallyHandler(self: *Decompiler, handler_block: u32, scratch: *TryScratch) DecompileError!bool {
        if (handler_block >= self.cfg.blocks.len) return false;
        const block = &self.cfg.blocks[handler_block];
        if (self.hasExceptionHandlerOpcodes(block)) return false;
        for (block.instructions) |inst| {
            if (inst.opcode == .CHECK_EXC_MATCH) return false;
            if (inst.opcode == .COMPARE_OP and inst.arg == 10) return false;
            if (inst.opcode == .POP_EXCEPT) return false;
        }
        for (block.instructions) |inst| {
            if (inst.opcode == .RERAISE or inst.opcode == .END_FINALLY) return true;
        }

        scratch.normal_reach.reset();
        scratch.queue.clearRetainingCapacity();
        try scratch.queue.append(self.allocator, handler_block);

        while (scratch.queue.items.len > 0) {
            const bid = scratch.queue.items[scratch.queue.items.len - 1];
            scratch.queue.items.len -= 1;
            if (bid >= self.cfg.blocks.len) continue;
            if (scratch.normal_reach.isSet(bid)) continue;
            try scratch.normal_reach.set(self.allocator, bid);
            const blk = &self.cfg.blocks[bid];
            for (blk.instructions) |inst| {
                if (inst.opcode == .RERAISE or inst.opcode == .END_FINALLY) return true;
            }
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (!scratch.normal_reach.isSet(edge.target)) {
                    try scratch.queue.append(self.allocator, edge.target);
                }
            }
        }
        return false;
    }

    fn finallyHandlerHasReturn(
        self: *Decompiler,
        handler_block: u32,
        handler_set: *const GenSet,
        scratch: *TryScratch,
    ) DecompileError!bool {
        if (handler_block >= self.cfg.blocks.len) return false;
        scratch.normal_reach.reset();
        scratch.queue.clearRetainingCapacity();
        try scratch.queue.append(self.allocator, handler_block);

        while (scratch.queue.items.len > 0) {
            const bid = scratch.queue.items[scratch.queue.items.len - 1];
            scratch.queue.items.len -= 1;
            if (bid >= self.cfg.blocks.len) continue;
            if (scratch.normal_reach.isSet(bid)) continue;
            try scratch.normal_reach.set(self.allocator, bid);
            const blk = &self.cfg.blocks[bid];
            for (blk.instructions) |inst| {
                switch (inst.opcode) {
                    .RETURN_VALUE, .RETURN_CONST => return true,
                    else => {},
                }
            }
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                if (edge.target >= self.cfg.blocks.len) continue;
                if (handler_set.isSet(edge.target)) continue;
                if (!scratch.normal_reach.isSet(edge.target)) {
                    try scratch.queue.append(self.allocator, edge.target);
                }
            }
        }
        return false;
    }

    fn hasExceptionHandlerOpcodes(self: *Decompiler, block: *const BasicBlock) bool {
        _ = self;
        var has_dup = false;
        var has_exc_cmp = false;
        var has_jump = false;
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .PUSH_EXC_INFO, .CHECK_EXC_MATCH, .JUMP_IF_NOT_EXC_MATCH => return true,
                .DUP_TOP => has_dup = true,
                .COMPARE_OP => {
                    if (inst.arg == 10) has_exc_cmp = true;
                },
                .JUMP_IF_FALSE, .POP_JUMP_IF_FALSE => has_jump = true,
                else => {},
            }
        }
        return has_dup and has_exc_cmp and has_jump;
    }

    fn hasExceptionSuccessor(self: *Decompiler, block: *const BasicBlock) bool {
        _ = self;
        for (block.successors) |edge| {
            if (edge.edge_type == .exception) return true;
        }
        return false;
    }

    fn hasWithExitCleanup(self: *Decompiler, block: *const BasicBlock) bool {
        _ = self;
        if (block.instructions.len < 4) return false;
        var i: usize = 0;
        while (i + 3 < block.instructions.len) : (i += 1) {
            const a = block.instructions[i];
            const b = block.instructions[i + 1];
            const c = block.instructions[i + 2];
            const d = block.instructions[i + 3];
            if (a.opcode == .LOAD_CONST and
                b.opcode == .DUP_TOP and
                c.opcode == .DUP_TOP and
                d.opcode == .CALL_FUNCTION and d.arg == 3)
            {
                return true;
            }
        }
        return false;
    }

    fn needsExceptionSeed(self: *Decompiler, block_id: u32, block: *const BasicBlock) bool {
        _ = block_id;
        if (block.is_exception_handler or self.hasExceptionHandlerOpcodes(block)) return true;
        for (block.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            if (pred.is_exception_handler or self.hasExceptionHandlerOpcodes(pred)) return true;
        }
        return false;
    }

    fn exceptionSeedCount(self: *Decompiler, block_id: u32, block: *const BasicBlock) usize {
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .WITH_EXCEPT_START => return self.withExcSeedCount(),
                else => {},
            }
        }
        if (!self.needsExceptionSeed(block_id, block)) return 0;
        return self.excHandlerSeedCount();
    }

    fn excSeedFlow(self: *Decompiler, block: *const BasicBlock) usize {
        for (block.instructions) |inst| {
            if (inst.opcode == .WITH_EXCEPT_START) return self.withExcSeedCount();
        }
        if (block.is_exception_handler or self.hasExceptionHandlerOpcodes(block)) {
            return self.excHandlerSeedCount();
        }
        return 0;
    }

    fn excHandlerSeedCount(self: *Decompiler) usize {
        if (self.version.major < 3) return 3;
        if (self.version.gte(3, 11)) return 1;
        if (self.version.gte(3, 7)) return 6;
        return 3;
    }

    fn withExcSeedCount(self: *Decompiler) usize {
        if (self.version.major < 3) return 4;
        if (self.version.gte(3, 11)) return 2;
        if (self.version.gte(3, 9)) return 6;
        return 4;
    }

    fn emitForPrelude(
        self: *Decompiler,
        pattern: ctrl.ForPattern,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        alloc: std.mem.Allocator,
    ) DecompileError!void {
        if (pattern.setup_block >= self.cfg.blocks.len) return;
        const setup = &self.cfg.blocks[pattern.setup_block];
        var get_iter_idx: ?usize = null;
        for (setup.instructions, 0..) |inst, idx| {
            if (inst.opcode == .GET_ITER or inst.opcode == .FOR_LOOP) {
                get_iter_idx = idx;
            }
        }
        if (get_iter_idx == null or get_iter_idx.? == 0) return;
        var prelude_block = setup.*;
        prelude_block.instructions = setup.instructions[0..get_iter_idx.?];

        var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
        defer tmp.deinit(self.arena.allocator());
        var skip_first_store = false;
        var pred_for_iter = false;
        for (setup.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            const term = pred.terminator() orelse continue;
            if (term.opcode != .FOR_ITER and term.opcode != .FOR_LOOP) continue;
            for (pred.successors) |edge| {
                if (edge.edge_type == .normal and edge.target == pattern.setup_block) {
                    pred_for_iter = true;
                    break;
                }
            }
            if (pred_for_iter) break;
        }
        if (pred_for_iter) {
            for (prelude_block.instructions) |inst| {
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
                switch (inst.opcode) {
                    .UNPACK_SEQUENCE,
                    .UNPACK_EX,
                    .STORE_FAST,
                    .STORE_NAME,
                    .STORE_GLOBAL,
                    .STORE_DEREF,
                    => {
                        skip_first_store = true;
                        break;
                    },
                    else => {},
                }
                if (skip_first_store) break;
            }
        }
        var seed_pop = false;
        try self.processBlockStatements(
            pattern.setup_block,
            &prelude_block,
            &tmp,
            &skip_first_store,
            &seed_pop,
            false,
            null,
            0,
        );
        if (tmp.items.len > 0) {
            try stmts.appendSlice(alloc, tmp.items);
        }
    }

    fn shouldDeferForPrelude(
        self: *Decompiler,
        block_id: u32,
        limit: u32,
    ) DecompileError!bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        var has_iter = false;
        for (blk.instructions) |inst| {
            if (inst.opcode == .GET_ITER or inst.opcode == .FOR_LOOP) {
                has_iter = true;
                break;
            }
        }
        if (!has_iter) return false;
        for (blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            const succ_id = edge.target;
            if (succ_id >= self.cfg.blocks.len or succ_id >= limit) continue;
            const succ = &self.cfg.blocks[succ_id];
            const term = succ.terminator() orelse continue;
            if (term.opcode != .FOR_ITER and term.opcode != .FOR_LOOP) continue;
            return true;
        }
        return false;
    }

    fn isForSetupInLoop(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        _ = loop_header;
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        var has_iter = false;
        for (blk.instructions) |inst| {
            if (inst.opcode == .GET_ITER or inst.opcode == .FOR_LOOP) {
                has_iter = true;
                break;
            }
        }
        if (!has_iter) return false;
        for (blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            const succ_id = edge.target;
            if (succ_id >= self.cfg.blocks.len) continue;
            const succ = &self.cfg.blocks[succ_id];
            const term = succ.terminator() orelse continue;
            if (term.opcode == .FOR_ITER or term.opcode == .FOR_LOOP) return true;
        }
        return false;
    }

    /// Decompile a for loop pattern.
    fn decompileFor(self: *Decompiler, pattern: ctrl.ForPattern) DecompileError!?*Stmt {
        self.loop_depth += 1;
        defer self.loop_depth -= 1;
        if (self.loop_depth > 128) return null;
        if (self.loop_in_progress) |*set| {
            if (set.isSet(pattern.header_block)) return null;
            set.set(pattern.header_block);
            defer set.unset(pattern.header_block);
        }
        // Get the iterator expression from the setup block
        // Python 3+: ... GET_ITER
        // Python 1.x-2.2: ... LOAD_CONST 0 (sequence on TOS, index pushed)
        const setup = &self.cfg.blocks[pattern.setup_block];
        const header = &self.cfg.blocks[pattern.header_block];

        var iter_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer iter_sim.deinit();

        if (pattern.setup_block < self.stack_in.len) {
            if (self.stack_in[pattern.setup_block]) |entry| {
                for (entry) |val| {
                    const cloned = try iter_sim.cloneStackValue(val);
                    try iter_sim.stack.push(cloned);
                }
            }
        }

        const header_term = header.terminator() orelse return null;
        var last_get_iter: ?usize = null;
        if (header_term.opcode == .FOR_LOOP) {
            // Python 1.x-2.2: Setup block pushes sequence, header block adds index
            // Simulate setup block completely, it should leave sequence on TOS
            for (setup.instructions) |inst| {
                try iter_sim.simulate(inst);
            }
            // After simulating setup, stack should be [seq, idx, ...other stuff]
            // But we only want the sequence. Pop everything after the sequence.
            // Actually, the last LOAD_CONST in setup pushes the index.
            // So before the last LOAD_CONST, TOS is the sequence.
            // Simplification: Assume TOS-1 is sequence, TOS is index
            if (iter_sim.stack.items.items.len >= 2) {
                _ = iter_sim.stack.pop(); // pop index
            }
        } else {
            // Python 3+: GET_ITER
            for (setup.instructions, 0..) |inst, idx| {
                if (inst.opcode == .GET_ITER) {
                    last_get_iter = idx;
                }
            }
            const stop_idx = last_get_iter orelse setup.instructions.len;
            for (setup.instructions[0..stop_idx]) |inst| {
                try iter_sim.simulate(inst);
            }
        }

        var iter_expr = try iter_sim.stack.popExpr();
        if (last_get_iter) |gi| {
            if (gi > 0) {
                const prev = setup.instructions[gi - 1];
                const simple = switch (prev.opcode) {
                    .LOAD_FAST => if (iter_sim.getLocal(prev.arg)) |name| try self.makeName(name, .load) else null,
                    .LOAD_NAME, .LOAD_GLOBAL => if (iter_sim.getName(prev.arg)) |name| try self.makeName(name, .load) else null,
                    .LOAD_DEREF => if (iter_sim.getDeref(prev.arg)) |name| try self.makeName(name, .load) else null,
                    .LOAD_CONST => if (iter_sim.getConst(prev.arg)) |obj| try iter_sim.objToExpr(obj) else null,
                    else => null,
                };
                if (simple) |expr| {
                    iter_expr = expr;
                }
            }
            const get_iter_off = setup.instructions[gi].offset;
            var boolop_idx: ?usize = null;
            var boolop_and = false;
            for (setup.instructions[0..gi], 0..) |inst, idx| {
                if (inst.opcode == .JUMP_IF_TRUE_OR_POP or inst.opcode == .JUMP_IF_FALSE_OR_POP) {
                    if (inst.jumpTarget(self.cfg.version)) |target_off| {
                        if (target_off == get_iter_off) {
                            boolop_idx = idx;
                            boolop_and = inst.opcode == .JUMP_IF_FALSE_OR_POP;
                            break;
                        }
                    }
                }
            }
            if (boolop_idx) |j| {
                var left_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                defer left_sim.deinit();
                if (pattern.setup_block < self.stack_in.len) {
                    if (self.stack_in[pattern.setup_block]) |entry| {
                        for (entry) |val| {
                            const cloned = try left_sim.cloneStackValue(val);
                            try left_sim.stack.push(cloned);
                        }
                    }
                }
                for (setup.instructions[0..j]) |inst| {
                    try left_sim.simulate(inst);
                }
                const left_expr = try left_sim.stack.popExpr();

                var right_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                defer right_sim.deinit();
                if (pattern.setup_block < self.stack_in.len) {
                    if (self.stack_in[pattern.setup_block]) |entry| {
                        for (entry) |val| {
                            const cloned = try right_sim.cloneStackValue(val);
                            try right_sim.stack.push(cloned);
                        }
                    }
                }
                for (setup.instructions[0..j]) |inst| {
                    try right_sim.simulate(inst);
                }
                _ = try right_sim.stack.popExpr();
                for (setup.instructions[j + 1 .. gi]) |inst| {
                    try right_sim.simulate(inst);
                }
                const right_expr = try right_sim.stack.popExpr();
                iter_expr = try self.makeBoolPair(left_expr, right_expr, if (boolop_and) .and_ else .or_);
            }
        }
        if (self.isPlaceholderExpr(iter_expr) and
            setup.instructions.len == 1 and setup.instructions[0].opcode == .GET_ITER and
            setup.predecessors.len >= 2)
        {
            var jump_pred: ?u32 = null;
            var fall_pred: ?u32 = null;
            var is_and = false;
            for (setup.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                if (pred.terminator()) |term| {
                    if (term.opcode == .JUMP_IF_TRUE_OR_POP or term.opcode == .JUMP_IF_FALSE_OR_POP) {
                        if (term.jumpTarget(self.cfg.version)) |target_off| {
                            if (target_off == setup.start_offset) {
                                jump_pred = pred_id;
                                is_and = term.opcode == .JUMP_IF_FALSE_OR_POP;
                                continue;
                            }
                        }
                    }
                }
                for (pred.successors) |edge| {
                    if (edge.edge_type != .normal) continue;
                    if (edge.target == pattern.setup_block) {
                        fall_pred = pred_id;
                        break;
                    }
                }
            }
            if (jump_pred != null and fall_pred != null) {
                var left_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                defer left_sim.deinit();
                if (jump_pred.? < self.stack_in.len) {
                    if (self.stack_in[jump_pred.?]) |entry| {
                        for (entry) |val| {
                            const cloned = try left_sim.cloneStackValue(val);
                            try left_sim.stack.push(cloned);
                        }
                    }
                }
                const jump_blk = &self.cfg.blocks[jump_pred.?];
                if (jump_blk.instructions.len > 0) {
                    const stop = jump_blk.instructions.len - 1;
                    for (jump_blk.instructions[0..stop]) |inst| {
                        try left_sim.simulate(inst);
                    }
                    const left_expr = try left_sim.stack.popExpr();

                    var right_sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
                    defer right_sim.deinit();
                    if (fall_pred.? < self.stack_in.len) {
                        if (self.stack_in[fall_pred.?]) |entry| {
                            for (entry) |val| {
                                const cloned = try right_sim.cloneStackValue(val);
                                try right_sim.stack.push(cloned);
                            }
                        }
                    }
                    const fall_blk = &self.cfg.blocks[fall_pred.?];
                    for (fall_blk.instructions) |inst| {
                        try right_sim.simulate(inst);
                    }
                    const right_expr = try right_sim.stack.popExpr();
                    iter_expr = try self.makeBoolPair(left_expr, right_expr, if (is_and) .and_ else .or_);
                }
            }
        }

        // Get the loop target from the body block's first STORE_* or UNPACK_SEQUENCE
        const body = &self.cfg.blocks[pattern.body_block];
        const a = self.arena.allocator();
        var target_sim = self.initSim(a, a, self.code, self.version);
        defer target_sim.deinit();
        var target: *Expr = undefined;
        var found_target = false;

        for (body.instructions, 0..) |inst, inst_idx| {
            switch (inst.opcode) {
                .STORE_FAST => {
                    // Check for pattern: STORE_FAST var, LOAD_FAST var, UNPACK_SEQUENCE
                    // This is Python 3.9's way of doing nested tuple unpacking in for loops
                    if (inst_idx + 2 < body.instructions.len) {
                        const next = body.instructions[inst_idx + 1];
                        const after = body.instructions[inst_idx + 2];
                        if (next.opcode == .LOAD_FAST and next.arg == inst.arg and
                            (after.opcode == .UNPACK_SEQUENCE or after.opcode == .UNPACK_EX))
                        {
                            // Use the UNPACK_SEQUENCE as the target
                            const unpack = try self.collectUnpackTgts(&target_sim, body.instructions, inst_idx + 2, a);
                            if (unpack != null and unpack.?.ok) {
                                const tuple_expr = try a.create(Expr);
                                tuple_expr.* = .{ .tuple = .{ .elts = unpack.?.tgts, .ctx = .store } };
                                target = tuple_expr;
                                found_target = true;
                                break;
                            }
                        }
                    }
                    const name = if (self.code.varnames.len > inst.arg)
                        self.code.varnames[inst.arg]
                    else
                        "_";
                    target = try self.makeName(name, .store);
                    found_target = true;
                    break;
                },
                .STORE_NAME, .STORE_GLOBAL => {
                    const name = if (self.code.names.len > inst.arg)
                        self.code.names[inst.arg]
                    else
                        "_";
                    target = try self.makeName(name, .store);
                    found_target = true;
                    break;
                },
                .UNPACK_SEQUENCE, .UNPACK_EX => {
                    const unpack = try self.collectUnpackTgts(&target_sim, body.instructions, inst_idx, a);
                    if (unpack != null and unpack.?.ok) {
                        const tuple_expr = try a.create(Expr);
                        tuple_expr.* = .{ .tuple = .{ .elts = unpack.?.tgts, .ctx = .store } };
                        target = tuple_expr;
                        found_target = true;
                        break;
                    }
                    const cnt = if (inst.opcode == .UNPACK_EX) blk: {
                        const before = inst.arg & 0xFF;
                        const after = (inst.arg >> 8) & 0xFF;
                        break :blk before + 1 + after;
                    } else inst.arg;
                    const star_pos: ?u32 = if (inst.opcode == .UNPACK_EX) blk: {
                        const before = inst.arg & 0xFF;
                        break :blk before;
                    } else null;
                    if (cnt == 0) {
                        target = try a.create(Expr);
                        target.* = .{ .tuple = .{ .elts = &.{}, .ctx = .store } };
                    } else {
                        const cnt_usize: usize = @intCast(cnt);
                        var elts = try a.alloc(*Expr, cnt_usize);
                        var i: usize = 0;
                        while (i < cnt_usize) : (i += 1) {
                            var t = try self.makeName("_", .store);
                            t = try self.starTgt(a, t, i, star_pos);
                            elts[i] = t;
                        }
                        target = try a.create(Expr);
                        target.* = .{ .tuple = .{ .elts = elts, .ctx = .store } };
                    }
                    found_target = true;
                    break;
                },
                else => {},
            }
        }

        if (!found_target) {
            target = try self.makeName("_", .store);
        }

        // Decompile the body (skip the first STORE_FAST which is the target)
        const body_stmts = try self.decompileForBody(pattern.body_block, pattern.header_block);
        const merged_break = try self.mergeBreakGuards(body_stmts);
        const merged_body = try self.mergeContGuards(merged_break);
        const folded_body = try self.rewriteContRaise(merged_body);
        var else_body: []const *Stmt = &.{};
        if (pattern.else_block) |else_id| {
            const end_block: ?u32 = if (pattern.exit_block > else_id) pattern.exit_block else null;
            else_body = try self.decompileBranchRange(else_id, end_block, &.{}, 0);
        }
        const stmt = try a.create(Stmt);
        stmt.* = .{ .for_stmt = .{
            .target = target,
            .iter = iter_expr,
            .body = folded_body,
            .else_body = else_body,
            .type_comment = null,
            .is_async = false,
        } };

        return stmt;
    }

    fn stripLoopTargetAssigns(self: *Decompiler, block: *const BasicBlock, stmts: *std.ArrayListUnmanaged(*Stmt)) DecompileError!void {
        var names: std.ArrayListUnmanaged([]const u8) = .{};
        defer names.deinit(self.arena.allocator());
        for (block.instructions) |inst| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
            const name: []const u8 = switch (inst.opcode) {
                .STORE_FAST => if (inst.arg < self.code.varnames.len) self.code.varnames[inst.arg] else "_",
                .STORE_NAME, .STORE_GLOBAL => if (inst.arg < self.code.names.len) self.code.names[inst.arg] else "_",
                .STORE_DEREF => blk: {
                    if (inst.arg < self.code.cellvars.len) break :blk self.code.cellvars[inst.arg];
                    const free_idx: usize = @as(usize, inst.arg) - self.code.cellvars.len;
                    if (free_idx < self.code.freevars.len) break :blk self.code.freevars[free_idx];
                    break :blk "_";
                },
                else => continue,
            };
            try names.append(self.arena.allocator(), name);
        }
        while (names.items.len > 0 and stmts.items.len > 0) {
            const stmt = stmts.items[stmts.items.len - 1];
            if (stmt.* != .assign) break;
            if (stmt.assign.targets.len != 1) break;
            const tgt = stmt.assign.targets[0];
            if (tgt.* != .name) break;
            if (stmt.assign.value.* != .constant or stmt.assign.value.constant != .ellipsis) break;
            if (!std.mem.eql(u8, tgt.name.id, names.items[names.items.len - 1])) break;
            stmts.items.len -= 1;
            names.items.len -= 1;
        }
    }

    /// Decompile a for loop body using loop-region membership.
    fn decompileForBody(self: *Decompiler, body_block_id: u32, header_block_id: u32) DecompileError![]const *Stmt {
        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        var visited = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer visited.deinit();

        var reachable = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer reachable.deinit();
        var reach_q: std.ArrayListUnmanaged(u32) = .{};
        defer reach_q.deinit(self.allocator);
        try reach_q.append(self.allocator, body_block_id);
        while (reach_q.items.len > 0) {
            const cur = reach_q.items[reach_q.items.len - 1];
            reach_q.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (reachable.isSet(cur)) continue;
            reachable.set(cur);
            const blk = &self.cfg.blocks[cur];
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception or edge.edge_type == .loop_back) continue;
                const next = edge.target;
                if (next >= self.cfg.blocks.len) continue;
                if (!self.analyzer.inLoop(next, header_block_id)) continue;
                try reach_q.append(self.allocator, next);
            }
        }

        var skip_first_store = true;
        var seed_pop = false;
        var block_idx = body_block_id;
        var loop_end_offset: ?u32 = null;
        var loop_end_block: ?u32 = null;
        if (header_block_id < self.cfg.blocks.len) {
            const header = &self.cfg.blocks[header_block_id];
            for (header.successors) |edge| {
                if (edge.edge_type == .conditional_false and edge.target < self.cfg.blocks.len) {
                    loop_end_offset = self.cfg.blocks[edge.target].start_offset;
                    loop_end_block = edge.target;
                    break;
                }
            }
        }
        const loop_limit = loop_end_block orelse @as(u32, @intCast(self.cfg.blocks.len));

        while (block_idx < self.cfg.blocks.len) {
            const block = &self.cfg.blocks[block_idx];
            if (loop_end_offset) |end_off| {
                if (block.start_offset >= end_off) break;
            }
            if (self.consumed.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            if (!self.analyzer.inLoop(block_idx, header_block_id)) {
                block_idx += 1;
                continue;
            }
            if (!reachable.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            if (block_idx == header_block_id and block_idx != body_block_id) break;

            if (self.isForSetupInLoop(block_idx, header_block_id)) {
                block_idx += 1;
                continue;
            }
            if (visited.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            visited.set(block_idx);

            var has_loop_target = false;
            if (skip_first_store) {
                for (block.instructions) |inst| {
                    if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                    if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
                    switch (inst.opcode) {
                        .UNPACK_SEQUENCE,
                        .UNPACK_EX,
                        .STORE_FAST,
                        .STORE_NAME,
                        .STORE_GLOBAL,
                        .STORE_DEREF,
                        => {
                            has_loop_target = true;
                            break;
                        },
                        else => {},
                    }
                    if (has_loop_target) break;
                }
            }

            if (try self.tryDecompileBoolOpIntoWithSkip(block_idx, loop_limit, &stmts, a, skip_first_store)) |next_block| {
                skip_first_store = false;
                block_idx = next_block;
                continue;
            }
            if (try self.tryDecompileTernaryIntoWithSkip(block_idx, loop_limit, &stmts, a, skip_first_store)) |next_block| {
                skip_first_store = false;
                block_idx = next_block;
                continue;
            }

            // Check for nested control flow patterns
            const pattern = try self.analyzer.detectPattern(block_idx);

            switch (pattern) {
                .if_stmt => |p| {
                    // Process statements before the condition
                    try self.processPartialBlock(block, &stmts, a, &skip_first_store, null);

                    const parts = try self.loopIfParts(p, header_block_id, &visited, null) orelse {
                        block_idx += 1;
                        continue;
                    };
                    const else_is_assert = if (parts.else_block) |else_id|
                        self.isAssertRaiseBlock(else_id)
                    else
                        false;
                    const then_is_assert = self.isAssertRaiseBlock(parts.then_block);
                    if (else_is_assert != then_is_assert) {
                        if (else_is_assert) {
                            const else_id = parts.else_block.?;
                            if (try self.tryDecompileAssertBlock(parts.condition, else_id, 0)) |stmt| {
                                try stmts.append(a, stmt);
                                if (parts.then_body.len > 0) {
                                    try stmts.appendSlice(a, parts.then_body);
                                }
                                if (try self.nextLoopBlockAfterIf(p, header_block_id, block_idx, null)) |next_id| {
                                    self.markVisitedRange(&visited, header_block_id, block.start_offset, self.cfg.blocks[next_id].start_offset);
                                    block_idx = next_id;
                                    continue;
                                }
                                break;
                            }
                        } else {
                            const inv = try self.invertConditionExpr(parts.condition);
                            if (try self.tryDecompileAssertBlock(inv, parts.then_block, 0)) |stmt| {
                                try stmts.append(a, stmt);
                                if (parts.else_body.len > 0) {
                                    try stmts.appendSlice(a, parts.else_body);
                                }
                                if (try self.nextLoopBlockAfterIf(p, header_block_id, block_idx, null)) |next_id| {
                                    self.markVisitedRange(&visited, header_block_id, block.start_offset, self.cfg.blocks[next_id].start_offset);
                                    block_idx = next_id;
                                    continue;
                                }
                                break;
                            }
                        }
                    }
                    var skip_else_cont = false;
                    if (parts.then_body.len > 0 and parts.else_body.len > 0) {
                        const then_term = self.bodyEndsLoopTerminal(parts.then_body);
                        const else_term = self.bodyEndsLoopTerminal(parts.else_body);
                        if (!then_term and !else_term) {
                            skip_else_cont = true;
                        }
                        const then_cont = self.loopBlockLeadsToContinue(parts.then_block, header_block_id);
                        const else_cont = if (parts.else_block) |else_id|
                            self.loopBlockLeadsToContinue(else_id, header_block_id)
                        else
                            false;
                        if (then_cont and else_cont) {
                            skip_else_cont = true;
                        }
                        const then_back = self.hasLoopBackEdge(&self.cfg.blocks[parts.then_block], header_block_id);
                        const else_back = if (parts.else_block) |else_id|
                            self.hasLoopBackEdge(&self.cfg.blocks[else_id], header_block_id)
                        else
                            false;
                        if (then_back and else_back) {
                            skip_else_cont = true;
                        }
                        if (then_cont == else_cont) {
                            // fallthrough to other handling
                        } else {
                            const guard_then = then_cont;
                            const else_is_jump_target = self.elseIsJumpTarget(parts.cond_op);
                            const guard_taken = if (guard_then) !else_is_jump_target else else_is_jump_target;
                            const guard_cond = try self.guardCondForBranch(parts.condition, parts.cond_op, guard_taken);
                            var guard_body = if (guard_then) parts.then_body else parts.else_body;
                            if (!self.bodyEndsLoopTerminal(guard_body)) {
                                const cont = try self.makeContinue();
                                const next_body = try a.alloc(*Stmt, guard_body.len + 1);
                                std.mem.copyForwards(*Stmt, next_body[0..guard_body.len], guard_body);
                                next_body[guard_body.len] = cont;
                                guard_body = next_body;
                            }
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = guard_cond,
                                .body = guard_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, if_stmt);
                            const tail_body = if (guard_then) parts.else_body else parts.then_body;
                            if (tail_body.len > 0) {
                                try stmts.appendSlice(a, tail_body);
                            }
                            if (try self.nextLoopBlockAfterIf(p, header_block_id, block_idx, null)) |next_id| {
                                self.markVisitedRange(&visited, header_block_id, block.start_offset, self.cfg.blocks[next_id].start_offset);
                                block_idx = next_id;
                                continue;
                            }
                            break;
                        }
                    }
                    if (parts.then_leads and !parts.else_leads and parts.then_body.len > 0 and parts.else_body.len > 0 and
                        !parts.else_is_continuation and self.isTrueJump(parts.cond_op))
                    {
                        var guard_body = parts.then_body;
                        if (!self.bodyEndsLoopTerminal(guard_body)) {
                            const cont = try self.makeContinue();
                            const next_body = try a.alloc(*Stmt, guard_body.len + 1);
                            std.mem.copyForwards(*Stmt, next_body[0..guard_body.len], guard_body);
                            next_body[guard_body.len] = cont;
                            guard_body = next_body;
                        }
                        const if_stmt = try a.create(Stmt);
                        if_stmt.* = .{ .if_stmt = .{
                            .condition = parts.condition,
                            .body = guard_body,
                            .else_body = &.{},
                        } };
                        try stmts.append(a, if_stmt);
                        try stmts.appendSlice(a, parts.else_body);
                        if (try self.nextLoopBlockAfterIf(p, header_block_id, block_idx, null)) |next_id| {
                            self.markVisitedRange(&visited, header_block_id, block.start_offset, self.cfg.blocks[next_id].start_offset);
                            block_idx = next_id;
                            continue;
                        }
                        break;
                    }
                    var use_else_cont = parts.else_is_continuation;
                    if (use_else_cont and parts.else_body.len > 0) {
                        const only_cont = parts.else_body.len == 1 and parts.else_body[0].* == .continue_stmt;
                        if (!only_cont) {
                            use_else_cont = false;
                        }
                    }
                    if (!skip_else_cont and use_else_cont and parts.else_block != null and self.isTrueJump(parts.cond_op)) {
                        const else_is_jump_target = self.elseIsJumpTarget(parts.cond_op);
                        const prefer_if = parts.condition.* == .bool_op;
                        if ((else_is_jump_target and parts.else_body.len == 0 and parts.then_body.len > 0) or
                            (prefer_if and !else_is_jump_target and parts.else_body.len == 0 and parts.then_body.len > 0 and !self.bodyEndsTerminal(parts.then_body)))
                        {
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = parts.condition,
                                .body = parts.then_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, if_stmt);
                        } else {
                            const guard_cond = try self.guardCondFromJump(parts.condition, parts.cond_op);
                            var guard_body = parts.else_body;
                            var needs_continue = true;
                            if (guard_body.len > 0) {
                                const last = guard_body[guard_body.len - 1];
                                if (last.* == .continue_stmt or self.stmtIsTerminal(last)) {
                                    needs_continue = false;
                                }
                            }
                            if (needs_continue) {
                                const cont = try self.makeContinue();
                                const next_body = try a.alloc(*Stmt, guard_body.len + 1);
                                if (guard_body.len > 0) {
                                    std.mem.copyForwards(*Stmt, next_body[0..guard_body.len], guard_body);
                                }
                                next_body[guard_body.len] = cont;
                                guard_body = next_body;
                            }
                            const guard_stmt = try a.create(Stmt);
                            guard_stmt.* = .{ .if_stmt = .{
                                .condition = guard_cond,
                                .body = guard_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, guard_stmt);
                            if (parts.then_body.len > 0) {
                                try stmts.appendSlice(a, parts.then_body);
                            }
                        }
                    } else {
                        const if_stmt = try a.create(Stmt);
                        if_stmt.* = .{ .if_stmt = .{
                            .condition = parts.condition,
                            .body = parts.then_body,
                            .else_body = parts.else_body,
                        } };
                        try stmts.append(a, if_stmt);
                    }
                    if (try self.nextLoopBlockAfterIf(p, header_block_id, block_idx, null)) |next_id| {
                        self.markVisitedRange(&visited, header_block_id, block.start_offset, self.cfg.blocks[next_id].start_offset);
                        block_idx = next_id;
                        continue;
                    }
                    break;
                },
                .for_loop => |p| {
                    if (try self.tryDecompileInlineListComp(p)) |result| {
                        self.deinitStackValues(result.stack);
                        block_idx = result.exit_block;
                        continue;
                    }
                    try self.emitForPrelude(p, &stmts, a);
                    const stmt = try self.decompileFor(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    self.markLoopVisited(p.header_block, &visited);
                    block_idx = p.exit_block;
                    continue;
                },
                .while_loop => |p| {
                    const stmt = try self.decompileWhile(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    self.markLoopVisited(p.header_block, &visited);
                    if (self.loop_next) |next| {
                        block_idx = next;
                        self.loop_next = null;
                    } else {
                        block_idx = p.exit_block;
                    }
                    continue;
                },
                .try_stmt => |p| {
                    if (try self.tryDecompileAsyncFor(p)) |result| {
                        if (result.stmt) |s| {
                            try stmts.append(a, s);
                        }
                        block_idx = result.next_block;
                        continue;
                    }
                    const result = try self.decompileTryWithLoop(p, header_block_id, &visited);
                    const leave_loop = self.tryNeedsBreak(&p, header_block_id);
                    if (result.stmt) |s| {
                        if (leave_loop) {
                            try self.appendTryBreak(s);
                        }
                        try stmts.append(a, s);
                    }
                    if (leave_loop) break;
                    block_idx = result.next_block;
                    continue;
                },
                .with_stmt => |p| {
                    const result = try self.decompileWith(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                    continue;
                },
                .match_stmt => |p| {
                    const result = try self.decompileMatch(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                    continue;
                },
                else => {
                    // Process block statements, stop at loop-back jump
                    const has_back_edge = self.hasLoopBackEdge(block, header_block_id);
                    try self.processBlockStatements(
                        block_idx,
                        block,
                        &stmts,
                        &skip_first_store,
                        &seed_pop,
                        has_back_edge,
                        header_block_id,
                        0,
                    );
                    if (has_back_edge) break;
                    block_idx += 1;
                },
            }
        }

        return stmts.toOwnedSlice(a);
    }

    /// Check if a block has a back edge to the loop header.
    fn hasLoopBackEdge(self: *Decompiler, block: *const cfg_mod.BasicBlock, header_id: u32) bool {
        _ = self;
        for (block.successors) |edge| {
            if (edge.edge_type == .loop_back and edge.target == header_id) {
                return true;
            }
        }
        return false;
    }

    fn markLoopVisited(self: *Decompiler, header_id: u32, visited: *std.DynamicBitSet) void {
        if (self.analyzer.loopSet(header_id)) |body| {
            visited.setUnion(body.*);
        }
    }

    fn markVisitedRange(
        self: *Decompiler,
        visited: *std.DynamicBitSet,
        loop_header: u32,
        start_off: u32,
        end_off: u32,
    ) void {
        var bid: u32 = 0;
        while (bid < self.cfg.blocks.len) : (bid += 1) {
            const blk = &self.cfg.blocks[bid];
            if (blk.start_offset < start_off or blk.start_offset >= end_off) continue;
            if (!self.analyzer.inLoop(bid, loop_header)) continue;
            visited.set(bid);
        }
    }

    fn resolveJumpOnlyBlock(self: *Decompiler, block_id: u32) u32 {
        var cur = block_id;
        var steps: usize = 0;
        while (cur < self.cfg.blocks.len and steps < 8) {
            const blk = &self.cfg.blocks[cur];
            const insts = blk.instructions;
            if (insts.len == 0) break;
            var jump_inst: ?decoder.Instruction = null;
            if (insts.len == 1) {
                const inst = insts[0];
                if (inst.opcode == .JUMP_FORWARD or inst.opcode == .JUMP_ABSOLUTE) {
                    jump_inst = inst;
                }
            } else {
                const last = insts[insts.len - 1];
                if (last.opcode != .JUMP_FORWARD and last.opcode != .JUMP_ABSOLUTE) break;
                var cleanup_only = true;
                for (insts[0 .. insts.len - 1]) |inst| {
                    switch (inst.opcode) {
                        .POP_BLOCK, .POP_TOP, .POP_EXCEPT, .END_FINALLY, .END_FOR, .NOP => {},
                        else => {
                            cleanup_only = false;
                            break;
                        },
                    }
                }
                if (!cleanup_only) break;
                jump_inst = last;
            }
            if (jump_inst) |inst| {
                if (inst.jumpTarget(self.cfg.version)) |target_offset| {
                    if (self.cfg.blockAtOffset(target_offset)) |target_id| {
                        if (target_id == cur) break;
                        cur = target_id;
                        steps += 1;
                        continue;
                    }
                }
            }
            if (self.blockIsCleanupOnly(blk)) {
                var next: ?u32 = null;
                for (blk.successors) |edge| {
                    if (edge.edge_type == .exception) continue;
                    if (next != null) {
                        next = null;
                        break;
                    }
                    next = edge.target;
                }
                if (next) |target_id| {
                    if (target_id == cur) break;
                    cur = target_id;
                    steps += 1;
                    continue;
                }
            }
            break;
        }
        return cur;
    }

    fn resolveJumpOnlyBlockNoCleanup(self: *Decompiler, block_id: u32) u32 {
        var cur = block_id;
        var steps: usize = 0;
        while (cur < self.cfg.blocks.len and steps < 8) {
            const blk = &self.cfg.blocks[cur];
            const insts = blk.instructions;
            if (insts.len != 1) break;
            const inst = insts[0];
            if (inst.opcode != .JUMP_FORWARD and inst.opcode != .JUMP_ABSOLUTE) break;
            if (inst.jumpTarget(self.cfg.version)) |target_offset| {
                if (self.cfg.blockAtOffset(target_offset)) |target_id| {
                    if (target_id == cur) break;
                    cur = target_id;
                    steps += 1;
                    continue;
                }
            }
            break;
        }
        return cur;
    }

    pub fn blockIsCleanupOnly(self: *Decompiler, block: *const cfg_mod.BasicBlock) bool {
        _ = self;
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .POP_BLOCK, .POP_TOP, .POP_EXCEPT, .END_FINALLY, .END_FOR, .NOP => {},
                else => return false,
            }
        }
        return true;
    }

    fn blockIsReturnNone(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        if (blk.successors.len != 0) return false;
        var insts: [2]decoder.Instruction = undefined;
        var count: usize = 0;
        for (blk.instructions) |inst| {
            if (inst.opcode == .NOP) continue;
            if (count >= insts.len) return false;
            insts[count] = inst;
            count += 1;
        }
        if (count == 1) {
            const inst = insts[0];
            if (inst.opcode != .RETURN_CONST) return false;
            if (inst.arg >= self.code.consts.len) return false;
            return switch (self.code.consts[inst.arg]) {
                .none => true,
                else => false,
            };
        }
        if (count != 2) return false;
        if (insts[0].opcode != .LOAD_CONST) return false;
        if (insts[1].opcode != .RETURN_VALUE) return false;
        if (insts[0].arg >= self.code.consts.len) return false;
        return switch (self.code.consts[insts[0].arg]) {
            .none => true,
            else => false,
        };
    }

    fn isTryReturnCleanupBlock(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        if (blk.instructions.len != 3) return false;
        return blk.instructions[0].opcode == .ROT_TWO and
            blk.instructions[1].opcode == .POP_TOP and
            blk.instructions[2].opcode == .RETURN_VALUE;
    }

    fn hasConditionalPred(self: *Decompiler, block_id: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        for (blk.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            for (pred.successors) |edge| {
                if (edge.target != block_id) continue;
                switch (edge.edge_type) {
                    .conditional_true, .conditional_false => return true,
                    else => {},
                }
            }
        }
        return false;
    }

    fn blockFallsThrough(self: *Decompiler, from: u32, to: u32) bool {
        if (from >= self.cfg.blocks.len or to >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[from];
        for (blk.successors) |edge| {
            if (edge.edge_type == .normal and edge.target == to) return true;
        }
        return false;
    }

    fn blockExitsLoop(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        var saw_succ = false;
        for (blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            if (edge.target >= self.cfg.blocks.len) continue;
            saw_succ = true;
            if (self.analyzer.inLoop(edge.target, loop_header)) return false;
        }
        return saw_succ;
    }

    fn tryHasInlineBreak(self: *Decompiler, try_block: u32, handler_start: u32, loop_header: u32) bool {
        if (try_block >= self.cfg.blocks.len or handler_start >= self.cfg.blocks.len or loop_header >= self.cfg.blocks.len) return false;
        const try_end = self.cfg.blocks[try_block].end_offset;
        const handler_off = self.cfg.blocks[handler_start].start_offset;
        const header_off = self.cfg.blocks[loop_header].start_offset;
        for (self.cfg.blocks) |*blk| {
            if (blk.predecessors.len != 0) continue;
            if (blk.start_offset < try_end or blk.start_offset >= handler_off) continue;
            if (blk.instructions.len != 2) continue;
            if (blk.instructions[0].opcode != .POP_BLOCK) continue;
            const jmp = blk.instructions[1];
            switch (jmp.opcode) {
                .JUMP_ABSOLUTE, .JUMP_FORWARD, .JUMP_BACKWARD, .JUMP_BACKWARD_NO_INTERRUPT => {},
                else => continue,
            }
            if (jmp.jumpTarget(self.cfg.version)) |tgt| {
                if (tgt == header_off) return true;
            }
        }
        return false;
    }

    fn loopBreakTarget(self: *Decompiler, block_id: u32, loop_header: u32) ?u32 {
        if (block_id >= self.cfg.blocks.len) return null;
        const blk = &self.cfg.blocks[block_id];
        const term = blk.terminator() orelse return null;
        switch (term.opcode) {
            .JUMP_FORWARD,
            .JUMP_BACKWARD,
            .JUMP_BACKWARD_NO_INTERRUPT,
            .JUMP_ABSOLUTE,
            => {},
            else => return null,
        }
        if (term.jumpTarget(self.cfg.version)) |target_offset| {
            if (self.cfg.blockAtOffset(target_offset)) |target_id| {
                if (!self.analyzer.inLoop(target_id, loop_header)) return target_id;
            }
        }
        return null;
    }

    fn loopBlockLeadsToBreak(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        if (self.loopBreakTarget(block_id, loop_header) != null) return true;
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        if (!self.blockIsCleanupOnly(blk)) return false;
        var succ: ?u32 = null;
        for (blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            if (succ != null) return false;
            succ = edge.target;
        }
        if (succ == null) return false;
        return switch (self.analyzer.detectLoopExit(succ.?, &[_]u32{loop_header})) {
            .break_stmt => true,
            else => false,
        };
    }

    fn loopBlockLeadsToContinue(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        var cur = block_id;
        var steps: usize = 0;
        while (cur < self.cfg.blocks.len and steps < 8) : (steps += 1) {
            const blk = &self.cfg.blocks[cur];
            if (blk.terminator()) |term| {
                if (term.isUnconditionalJump()) {
                    if (term.jumpTarget(self.cfg.version)) |target_offset| {
                        if (self.cfg.blockAtOffset(target_offset)) |target_id| {
                            if (target_id == loop_header and !self.isLoopTailBack(cur, loop_header)) {
                                return true;
                            }
                        }
                    }
                }
            }
            const jump_only = self.resolveJumpOnlyBlock(cur) != cur;
            if (!jump_only and !self.blockIsCleanupOnly(blk)) {
                const term = blk.terminator() orelse return false;
                switch (term.opcode) {
                    .POP_BLOCK,
                    .END_FINALLY,
                    .END_FOR,
                    .END_ASYNC_FOR,
                    => {},
                    else => return false,
                }
            }
            const exit = self.analyzer.detectLoopExit(cur, &[_]u32{loop_header});
            switch (exit) {
                .continue_stmt => return true,
                else => {},
            }
            var next: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (next != null) return false;
                next = edge.target;
            }
            if (next == null) return false;
            const next_id = next.?;
            if (next_id == loop_header) return true;
            if (!self.analyzer.inLoop(next_id, loop_header)) {
                if (self.resolveJumpOnlyBlock(next_id) == loop_header) return true;
                return false;
            }
            if (next_id == cur) return false;
            var pred_count: u32 = 0;
            for (self.cfg.blocks[next_id].predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                for (pred.successors) |edge| {
                    if (edge.target != next_id) continue;
                    if (edge.edge_type == .exception) continue;
                    pred_count += 1;
                    break;
                }
                if (pred_count > 1) return false;
            }
            if (pred_count == 0) return false;
            cur = next_id;
        }
        return false;
    }

    fn loopBlockHasExit(self: *Decompiler, start: u32, loop_header: u32) DecompileError!bool {
        if (start >= self.cfg.blocks.len) return false;
        var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
        defer seen.deinit();
        var queue: std.ArrayListUnmanaged(u32) = .{};
        defer queue.deinit(self.allocator);
        try queue.append(self.allocator, start);

        while (queue.items.len > 0) {
            const cur = queue.items[queue.items.len - 1];
            queue.items.len -= 1;
            if (cur >= self.cfg.blocks.len) continue;
            if (seen.isSet(cur)) continue;
            seen.set(cur);

            if (self.isTerminalBlock(cur)) return true;
            const exit = self.analyzer.detectLoopExit(cur, &[_]u32{loop_header});
            if (exit == .break_stmt) return true;

            for (self.cfg.blocks[cur].successors) |edge| {
                if (edge.edge_type == .exception) continue;
                const next = edge.target;
                if (next == loop_header) continue;
                if (!self.analyzer.inLoop(next, loop_header)) return true;
                if (!seen.isSet(next)) {
                    try queue.append(self.allocator, next);
                }
            }
        }

        return false;
    }

    fn inLoopRelaxed(self: *Decompiler, block: u32, header: u32, loop_exit: ?u32) bool {
        if (self.analyzer.inLoop(block, header)) return true;
        if (loop_exit) |exit_id| {
            if (block < self.cfg.blocks.len and header < self.cfg.blocks.len and exit_id < self.cfg.blocks.len) {
                const off = self.cfg.blocks[block].start_offset;
                const head_off = self.cfg.blocks[header].start_offset;
                const exit_off = self.cfg.blocks[exit_id].start_offset;
                if (off > head_off and off < exit_off) return true;
            }
        }
        return false;
    }

    fn earlierStopBlock(self: *Decompiler, a: ?u32, b: ?u32) ?u32 {
        if (a == null) return b;
        if (b == null) return a;
        const a_id = a.?;
        const b_id = b.?;
        if (a_id >= self.cfg.blocks.len) return b;
        if (b_id >= self.cfg.blocks.len) return a;
        const a_off = self.cfg.blocks[a_id].start_offset;
        const b_off = self.cfg.blocks[b_id].start_offset;
        return if (a_off <= b_off) a else b;
    }

    fn stopAfter(self: *Decompiler, start_block: u32, a: ?u32, b: ?u32) ?u32 {
        if (start_block >= self.cfg.blocks.len) return self.earlierStopBlock(a, b);
        const start_off = self.cfg.blocks[start_block].start_offset;

        var a_ok = a;
        if (a_ok) |aid| {
            if (aid >= self.cfg.blocks.len or self.cfg.blocks[aid].start_offset <= start_off) {
                a_ok = null;
            }
        }
        var b_ok = b;
        if (b_ok) |bid| {
            if (bid >= self.cfg.blocks.len or self.cfg.blocks[bid].start_offset <= start_off) {
                b_ok = null;
            }
        }
        return self.earlierStopBlock(a_ok, b_ok);
    }

    fn blockLeadsToHeader(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        if (block_id == loop_header) return true;
        var cur = block_id;
        var steps: usize = 0;
        while (cur < self.cfg.blocks.len and steps < 8) : (steps += 1) {
            const blk = &self.cfg.blocks[cur];
            const jump_only = self.jumpTargetIfJumpOnlyEdge(cur, true, true) != null;
            if (!jump_only and !self.blockIsCleanupOnly(blk)) return false;
            var next: ?u32 = null;
            for (self.cfg.blocks[cur].successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (next != null) return false;
                next = edge.target;
            }
            if (next == null) return false;
            const next_id = next.?;
            if (next_id == loop_header) return true;
            if (next_id == cur) return false;
            cur = next_id;
        }
        return false;
    }

    fn handlerIsContinue(self: *Decompiler, start: u32, end: u32, loop_header: u32) bool {
        var bid = start;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            if (self.cfg.blocks[bid].is_exception_handler) continue;
            const exit = self.analyzer.detectLoopExit(bid, &[_]u32{loop_header});
            if (exit == .continue_stmt and !self.isLoopTailBack(bid, loop_header)) return true;
        }
        return false;
    }

    fn handlerHasExplicitContinue(self: *Decompiler, start: u32, end: u32, loop_header: u32) bool {
        var count: u32 = 0;
        var has_loop = false;
        var has_dead = false;
        var bid = start;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            const blk = &self.cfg.blocks[bid];
            var has_pop = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .POP_EXCEPT) {
                    has_pop = true;
                    break;
                }
            }
            if (!has_pop) continue;
            const term = blk.terminator() orelse continue;
            if (!term.isUnconditionalJump()) continue;
            const target_off = term.jumpTarget(self.cfg.version) orelse continue;
            const target_id = self.cfg.blockAtOffset(target_off) orelse continue;
            if (target_id != loop_header) continue;
            if (self.isLoopTailBack(bid, loop_header)) continue;
            count += 1;
            if (blk.predecessors.len == 0) has_dead = true;
            has_loop = true;
        }
        if (has_loop and has_dead) return true;
        return has_loop and count >= 2;
    }

    fn handlerHasContinueJump(self: *Decompiler, start: u32, end: u32, loop_header: u32) bool {
        var bid = start;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            const blk = &self.cfg.blocks[bid];
            var has_pop = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .POP_EXCEPT) {
                    has_pop = true;
                    break;
                }
            }
            if (!has_pop) continue;
            const term = blk.terminator() orelse continue;
            if (!term.isUnconditionalJump()) continue;
            const target_off = term.jumpTarget(self.cfg.version) orelse continue;
            const target_id = self.cfg.blockAtOffset(target_off) orelse continue;
            if (target_id != loop_header) continue;
            if (self.isLoopTailBack(bid, loop_header)) continue;
            return true;
        }
        return false;
    }

    fn handlerHasBreakJump(self: *Decompiler, start: u32, end: u32, loop_header: u32) bool {
        var bid = start;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            const blk = &self.cfg.blocks[bid];
            var has_pop = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .POP_EXCEPT) {
                    has_pop = true;
                    break;
                }
            }
            if (!has_pop) continue;
            if (self.loopBlockLeadsToBreak(bid, loop_header)) return true;
        }
        return false;
    }

    fn isLoopTailBack(self: *Decompiler, block_id: u32, loop_header: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        if (!self.hasLoopBackEdge(blk, loop_header)) return false;
        const body = self.analyzer.loopSet(loop_header) orelse return false;
        const off = blk.start_offset;
        var i: u32 = 0;
        while (i < self.cfg.blocks.len) : (i += 1) {
            if (i == loop_header) continue;
            if (!body.isSet(@intCast(i))) continue;
            if (self.cfg.blocks[i].predecessors.len == 0) continue;
            if (self.cfg.blocks[i].start_offset > off) return false;
        }
        return true;
    }

    fn hasSingleNormalSuccessor(self: *Decompiler, block_id: u32, target: u32) bool {
        if (block_id >= self.cfg.blocks.len) return false;
        const blk = &self.cfg.blocks[block_id];
        var count: u32 = 0;
        var only: ?u32 = null;
        for (blk.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            count += 1;
            only = edge.target;
            if (count > 1) return false;
        }
        return count == 1 and only.? == target;
    }

    fn continuesToHeader(
        self: *Decompiler,
        start: u32,
        header: u32,
        path_out: ?*std.ArrayListUnmanaged(u32),
    ) DecompileError!bool {
        var cur = start;
        var steps: usize = 0;
        if (path_out) |p| {
            p.* = .{};
            try p.append(self.arena.allocator(), cur);
        }
        if (start == header) return true;
        while (cur < self.cfg.blocks.len and steps < 8) {
            if (self.jumpTargetIfJumpOnlyEdge(cur, true, true)) |target| {
                if (path_out) |p| {
                    try p.append(self.arena.allocator(), target);
                }
                return target == header;
            }
            const blk = &self.cfg.blocks[cur];
            var only_cleanup = true;
            for (blk.instructions) |inst| {
                switch (inst.opcode) {
                    .POP_BLOCK, .POP_TOP, .NOP, .NOT_TAKEN, .CACHE => {},
                    else => {
                        only_cleanup = false;
                        break;
                    },
                }
            }
            if (!only_cleanup) return false;
            var next: ?u32 = null;
            for (blk.successors) |edge| {
                if (edge.edge_type == .exception) continue;
                if (next != null) return false;
                next = edge.target;
            }
            if (next == null) return false;
            cur = next.?;
            steps += 1;
            if (path_out) |p| {
                try p.append(self.arena.allocator(), cur);
            }
        }
        return false;
    }

    fn guardBranchToHeader(
        self: *Decompiler,
        block: *const cfg_mod.BasicBlock,
        term: decoder.Instruction,
        header: u32,
        trace_on: bool,
    ) DecompileError!?GuardBranch {
        const target_off = term.jumpTarget(self.cfg.version) orelse return null;
        const jump_id = self.cfg.blockAtOffset(target_off) orelse return null;
        var fall_id: ?u32 = null;
        for (block.successors) |edge| {
            if (edge.edge_type == .exception) continue;
            if (edge.target == jump_id) continue;
            if (fall_id != null) return null;
            fall_id = edge.target;
        }
        if (fall_id == null) return null;
        var jump_path: std.ArrayListUnmanaged(u32) = .{};
        var fall_path: std.ArrayListUnmanaged(u32) = .{};
        const jump_cont = try self.continuesToHeader(
            jump_id,
            header,
            if (trace_on) &jump_path else null,
        );
        const fall_cont = try self.continuesToHeader(
            fall_id.?,
            header,
            if (trace_on) &fall_path else null,
        );
        if (jump_cont == fall_cont) return null;
        if (jump_cont) {
            return .{
                .target = jump_id,
                .taken = true,
                .path = if (trace_on) jump_path.items else &.{},
            };
        }
        return .{
            .target = fall_id.?,
            .taken = false,
            .path = if (trace_on) fall_path.items else &.{},
        };
    }

    fn writeTrace(self: *Decompiler, value: anytype) DecompileError!void {
        const file = self.trace_file orelse return;
        var buf: [2048]u8 = undefined;
        var writer = file.writerStreaming(&buf);
        const out = &writer.interface;
        try std.json.Stringify.value(value, .{}, out);
        try out.writeAll("\n");
        try out.flush();
    }

    fn emitDecisionTrace(
        self: *Decompiler,
        block_id: u32,
        note: []const u8,
        cond: ?*Expr,
    ) DecompileError!void {
        if (!self.trace_decisions or self.trace_file == null) return;
        const cond_text = if (cond) |c| try self.exprToString(c) else null;
        const ev = DecisionTrace{
            .kind = "decision",
            .block = block_id,
            .note = note,
            .cond = cond_text,
        };
        try self.writeTrace(ev);
    }

    fn exprToString(self: *Decompiler, expr: *const Expr) DecompileError![]const u8 {
        var cg = codegen.Writer.init(self.arena.allocator());
        defer cg.deinit(self.arena.allocator());
        try cg.writeExpr(self.arena.allocator(), expr);
        return try cg.getOutput(self.arena.allocator());
    }

    fn stackTraceVal(self: *Decompiler, val: StackValue) DecompileError!TraceStackVal {
        return switch (val) {
            .expr => |e| .{ .tag = "expr", .text = try self.exprToString(e) },
            .function_obj => |f| .{ .tag = "func", .text = f.code.name },
            .class_obj => |c| .{ .tag = "class", .text = c.name },
            .comp_builder => .{ .tag = "comp_builder", .text = null },
            .comp_obj => |c| .{ .tag = "comp", .text = @tagName(c.kind) },
            .code_obj => |c| .{ .tag = "code", .text = c.name },
            .import_module => |m| .{ .tag = "import", .text = m.module },
            .null_marker => .{ .tag = "null", .text = null },
            .saved_local => |name| .{ .tag = "saved_local", .text = name },
            .type_alias => .{ .tag = "type_alias", .text = null },
            .exc_marker => .{ .tag = "exc", .text = null },
            .unknown => .{ .tag = "unknown", .text = null },
        };
    }

    fn stackTraceSlice(self: *Decompiler, vals: []const StackValue) DecompileError![]const TraceStackVal {
        const a = self.arena.allocator();
        if (vals.len == 0) return &.{};
        const out = try a.alloc(TraceStackVal, vals.len);
        for (vals, 0..) |val, idx| {
            out[idx] = try self.stackTraceVal(val);
        }
        return out;
    }

    fn emitGuardTrace(
        self: *Decompiler,
        block_id: u32,
        header_id: u32,
        term: decoder.Instruction,
        target_id: u32,
        guard_cond: *Expr,
        insert_idx: usize,
        path: []const u32,
    ) DecompileError!void {
        if (!self.trace_loop_guards or self.trace_file == null) return;
        const stack_vals = if (block_id < self.stack_in.len)
            (self.stack_in[block_id] orelse &.{})
        else
            &.{};
        const stack_in = try self.stackTraceSlice(stack_vals);
        const guard_expr = try self.exprToString(guard_cond);
        const ev = GuardTrace{
            .kind = "loop_guard",
            .block = block_id,
            .header = header_id,
            .term_op = @tagName(term.opcode),
            .target = target_id,
            .continues_path = path,
            .stack_in = stack_in,
            .guard_expr = guard_expr,
            .insert_idx = insert_idx,
        };
        try self.writeTrace(ev);
    }

    fn traceSimBlock(self: *Decompiler, block_id: u32) DecompileError!void {
        if (self.trace_file == null) return;
        const target = self.trace_sim_block orelse return;
        if (target != block_id) return;
        if (block_id >= self.cfg.blocks.len) return error.InvalidBlock;
        const block = &self.cfg.blocks[block_id];
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        if (block_id < self.stack_in.len) {
            if (self.stack_in[block_id]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }
        for (block.instructions) |inst| {
            const before = try self.stackTraceSlice(sim.stack.items.items);
            try sim.simulate(inst);
            const after = try self.stackTraceSlice(sim.stack.items.items);
            const ev = SimTrace{
                .kind = "sim_step",
                .block = block_id,
                .offset = inst.offset,
                .op = @tagName(inst.opcode),
                .arg = inst.arg,
                .stack_before = before,
                .stack_after = after,
            };
            try self.writeTrace(ev);
            if (block.terminator()) |term| {
                if (term.offset == inst.offset) break;
            }
        }
    }

    fn emitStoreSubscr(
        self: *Decompiler,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!void {
        const a = self.arena.allocator();
        const key = try sim.stack.popExpr();
        const container = try sim.stack.popExpr();
        const annotation = try sim.stack.popExpr();

        // Check for variable annotation pattern: __annotations__['varname'] = type
        if (container.* == .name and std.mem.eql(u8, container.name.id, "__annotations__") and
            key.* == .constant and key.constant == .string)
        {
            const var_name = key.constant.string;
            const target = try self.makeName(var_name, .store);

            // Check if previous statement was an assignment to the same variable
            // Pattern: x = value; __annotations__['x'] = type => x: type = value
            var assign_value: ?*Expr = null;
            if (stmts.items.len > 0) {
                const prev = stmts.items[stmts.items.len - 1];
                if (prev.* == .assign and prev.assign.targets.len == 1) {
                    const prev_target = prev.assign.targets[0];
                    if (prev_target.* == .name and std.mem.eql(u8, prev_target.name.id, var_name)) {
                        assign_value = prev.assign.value;
                        // Remove the previous assignment
                        _ = stmts.pop();
                    }
                }
            }

            const stmt = try a.create(Stmt);
            stmt.* = .{ .ann_assign = .{
                .target = target,
                .annotation = annotation,
                .value = assign_value,
                .simple = true,
            } };
            try stmts.append(stmts_allocator, stmt);
        } else {
            const subscript = try a.create(Expr);
            subscript.* = .{ .subscript = .{
                .value = container,
                .slice = key,
                .ctx = .store,
            } };
            const stmt = try self.makeAssign(subscript, annotation);
            try stmts.append(stmts_allocator, stmt);
        }
    }

    fn emitStoreSlice(
        self: *Decompiler,
        sim: *SimContext,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!void {
        const a = self.arena.allocator();
        const stop = try sim.stack.popExpr();
        const start = try sim.stack.popExpr();
        const container = try sim.stack.popExpr();
        const value = try sim.stack.popExpr();

        const slice_expr = try a.create(Expr);
        const lower = if (start.* == .constant and start.constant == .none) null else start;
        const upper = if (stop.* == .constant and stop.constant == .none) null else stop;
        slice_expr.* = .{ .slice = .{ .lower = lower, .upper = upper, .step = null } };

        const subscript = try a.create(Expr);
        subscript.* = .{ .subscript = .{
            .value = container,
            .slice = slice_expr,
            .ctx = .store,
        } };
        const stmt = try self.makeAssign(subscript, value);
        try stmts.append(stmts_allocator, stmt);
    }

    fn emitStoreAttr(
        self: *Decompiler,
        sim: *SimContext,
        chain_targets: *std.ArrayListUnmanaged(*Expr),
        block_id: u32,
        instructions: []const decoder.Instruction,
        idx: *usize,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first: usize,
        limit: ?usize,
    ) DecompileError!void {
        const a = self.arena.allocator();
        const real_idx = skip_first + idx.*;
        const has_dup_before = if (real_idx >= 2) blk: {
            const maybe_dup = instructions[real_idx - 2];
            break :blk maybe_dup.opcode == .DUP_TOP or maybe_dup.opcode == .COPY;
        } else false;
        const next_is_unpack = blk: {
            const next_idx = idx.* + 1;
            if (next_idx >= instructions.len) break :blk false;
            if (limit) |lim| {
                if (next_idx >= lim) break :blk false;
            }
            break :blk instructions[next_idx].opcode == .UNPACK_SEQUENCE;
        };

        // If part of a chain followed by UNPACK_SEQUENCE, defer to UNPACK handler
        if (has_dup_before and next_is_unpack) {
            const container_val = sim.stack.pop() orelse return error.StackUnderflow;
            _ = sim.stack.pop() orelse return error.StackUnderflow; // pop dup'd value
            if (container_val == .expr) {
                const attr_name = sim.getName(instructions[idx.*].arg) orelse "__unknown__";
                const target = try self.makeAttribute(container_val.expr, attr_name, .store);
                try chain_targets.append(self.allocator, target);
            }
            return;
        }

        const is_chain = has_dup_before;

        if (is_chain) {
            // This is an attribute chain assignment
            var targets: std.ArrayListUnmanaged(*Expr) = .{};

            // Build first target from current instruction's context
            const container_val = sim.stack.pop() orelse return error.StackUnderflow;
            _ = sim.stack.pop() orelse return error.StackUnderflow; // pop dup'd value

            if (container_val == .expr) {
                const attr_name = sim.getName(instructions[idx.*].arg) orelse "__unknown__";
                const first_target = try self.makeAttribute(container_val.expr, attr_name, .store);
                try targets.append(a, first_target);
            }

            // Look ahead for more attribute chain targets
            var j: usize = idx.* + 1;
            while (j < instructions.len) {
                if (limit) |lim| {
                    if (j >= lim) break;
                }
                const next_inst = instructions[j];
                if (next_inst.opcode == .DUP_TOP or next_inst.opcode == .COPY) {
                    // DUP + attr target
                    try sim.simulate(next_inst);
                    if (j + 2 < instructions.len) {
                        if (limit) |lim| {
                            if (j + 2 >= lim) break;
                        }
                        const load_inst = instructions[j + 1];
                        const store_inst = instructions[j + 2];
                        if (store_inst.opcode == .STORE_ATTR) {
                            try sim.simulate(load_inst);
                            const cont_val = sim.stack.pop() orelse return error.StackUnderflow;
                            _ = sim.stack.pop() orelse return error.StackUnderflow;
                            if (cont_val == .expr) {
                                const attr = sim.getName(store_inst.arg) orelse "__unknown__";
                                const target = try self.makeAttribute(cont_val.expr, attr, .store);
                                try targets.append(a, target);
                            }
                            j += 3;
                            continue;
                        }
                    }
                    break;
                } else if (next_inst.opcode == .LOAD_NAME or
                    next_inst.opcode == .LOAD_FAST or
                    next_inst.opcode == .LOAD_GLOBAL or
                    next_inst.opcode == .LOAD_DEREF)
                {
                    // Final attr target (no DUP), possibly through LOAD_ATTR chain.
                    if (limit) |lim| {
                        if (j >= lim) break;
                    }
                    var k: usize = j;
                    try sim.simulate(instructions[k]);
                    k += 1;
                    while (k < instructions.len and instructions[k].opcode == .LOAD_ATTR) {
                        if (limit) |lim| {
                            if (k >= lim) break;
                        }
                        try sim.simulate(instructions[k]);
                        k += 1;
                    }
                    if (k < instructions.len) {
                        if (limit) |lim| {
                            if (k >= lim) break;
                        }
                        if (instructions[k].opcode == .STORE_ATTR) {
                            const cont_val = sim.stack.pop() orelse return error.StackUnderflow;
                            if (cont_val == .expr) {
                                const attr = sim.getName(instructions[k].arg) orelse "__unknown__";
                                const target = try self.makeAttribute(cont_val.expr, attr, .store);
                                try targets.append(a, target);
                            }
                            j = k + 1;
                        }
                    }
                    break;
                } else {
                    break;
                }
            }

            // Get the value
            const value = sim.stack.pop() orelse return error.StackUnderflow;
            if (value == .expr and targets.items.len > 0) {
                const stmt = try a.create(Stmt);
                stmt.* = .{ .assign = .{
                    .targets = targets.items,
                    .value = value.expr,
                    .type_comment = null,
                } };
                try stmts.append(stmts_allocator, stmt);
            }
            idx.* = j - 1;
            return;
        }

        // Regular single attribute assignment
        const container_val = sim.stack.pop() orelse {
            try sim.simulate(instructions[idx.*]);
            return;
        };
        const value_val = sim.stack.pop() orelse {
            try sim.simulate(instructions[idx.*]);
            return;
        };

        const container = if (container_val == .expr) container_val.expr else return;
        var value_expr: ?*Expr = null;
        if (value_val == .expr) {
            value_expr = value_val.expr;
        } else {
            const store_idx = skip_first + idx.*;
            if (try self.tryRecoverTernaryStore(block_id, store_idx)) |expr| {
                value_expr = expr;
            } else {
                return;
            }
        }
        const value = value_expr.?;

        const attr_name = sim.getName(instructions[idx.*].arg) orelse "__unknown__";
        const attr_expr = try self.makeAttribute(container, attr_name, .store);
        const force = storeAttrAug(instructions, idx.*);
        if (try self.tryMakeAugAssign(sim, attr_expr, value, force)) |stmt| {
            try stmts.append(stmts_allocator, stmt);
        } else {
            const stmt = try self.makeAssign(attr_expr, value);
            try stmts.append(stmts_allocator, stmt);
        }
    }

    /// Process statements in a block, stopping before control flow jumps.
    fn processBlockStatements(
        self: *Decompiler,
        block_id: u32,
        block: *const cfg_mod.BasicBlock,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        skip_first_store: *bool,
        seed_pop: *bool,
        stop_at_jump: bool,
        loop_header: ?u32,
        skip_first: usize,
    ) DecompileError!void {
        const a = self.arena.allocator();
        var sim = self.initSim(a, a, self.code, self.version);
        defer sim.deinit();
        var chain_targets: std.ArrayListUnmanaged(*Expr) = .{};
        defer chain_targets.deinit(self.allocator);
        if (self.hasExceptionSuccessor(block) or self.hasWithExitCleanup(block)) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }
        const seed = if (block_id < self.stack_in.len) blk: {
            if (self.stack_in[block_id]) |entry| break :blk entry;
            break :blk &.{};
        } else &.{};

        const exc_count = self.exceptionSeedCount(block_id, block);
        if (seed.len > 0) {
            for (seed) |val| {
                const cloned = try sim.cloneStackValue(val);
                try sim.stack.push(cloned);
            }
        }
        if (exc_count > 0) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
            for (0..exc_count) |_| {
                const placeholder = try a.create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                try sim.stack.push(.{ .expr = placeholder });
            }
        }

        // FOR_LOOP header needs [seq, idx] on stack from setup predecessor
        const term = block.terminator();
        if (seed.len == 0 and term != null and term.?.opcode == .FOR_LOOP) {
            // Find setup predecessor (not the loop back edge)
            for (block.predecessors) |pred_id| {
                if (pred_id < block_id) { // Setup comes before header
                    const pred = &self.cfg.blocks[pred_id];
                    for (pred.instructions) |inst| {
                        try sim.simulate(inst);
                    }
                    break;
                }
            }
        }

        if (seed.len == 0 and skip_first_store.*) {
            // Loop target consumes the iteration value from the stack.
            try sim.stack.push(.unknown);
        }
        var suppress_pop = seed_pop.*;
        seed_pop.* = false;
        if (!suppress_pop and self.hasLegacyCondPop(block_id, block)) {
            suppress_pop = true;
        }
        if (suppress_pop and sim.stack.len() == 0) {
            // Legacy JUMP_IF_* leaves the condition on stack for a leading POP_TOP.
            try sim.stack.push(.unknown);
        }
        const has_inline = self.hasInlinePend(block_id);
        if (has_inline) {
            try self.pushInlinePend(block_id, &sim);
        }

        if (sim.stack.len() == 0 and self.needsPredecessorSeed(block)) {
            try self.seedFromPredecessors(block.id, &sim);
        }

        if (sim.stack.len() == 0) {
            sim.lenient = true;
            sim.stack.allow_underflow = true;
        }

        var skip_store_count: u32 = 0;
        const extra_skip = if (has_inline) inlineCleanupSkip(block, skip_first) else 0;
        const instructions = block.instructions;
        var idx: usize = 0;
        if (skip_first > 0) {
            const limit = @min(skip_first, instructions.len);
            while (idx < limit) : (idx += 1) {
                const inst = instructions[idx];
                errdefer if (self.last_error_ctx == null) {
                    self.last_error_ctx = .{
                        .code_name = self.code.name,
                        .block_id = block_id,
                        .offset = inst.offset,
                        .opcode = inst.opcode.name(),
                    };
                };
                try sim.simulate(inst);
            }
        }
        if (extra_skip > 0) {
            const next_idx = idx + extra_skip;
            idx = if (next_idx > instructions.len) instructions.len else next_idx;
        }
        while (idx < instructions.len) : (idx += 1) {
            const inst = instructions[idx];
            errdefer if (self.last_error_ctx == null) {
                self.last_error_ctx = .{
                    .code_name = self.code.name,
                    .block_id = block_id,
                    .offset = inst.offset,
                    .opcode = inst.opcode.name(),
                };
            };
            try self.flushPendingPrint(inst.opcode, stmts, a);
            if (try self.handlePrintOp(&sim, inst, stmts, a)) {
                continue;
            }
            if (inst.opcode == .POP_TOP and suppress_pop) {
                const val = sim.stack.pop() orelse return error.StackUnderflow;
                val.deinit(sim.allocator, sim.stack_alloc);
                suppress_pop = false;
                continue;
            }
            if (inst.opcode == .IMPORT_NAME) {
                if (try self.tryDecompileImportFromGroup(&sim, instructions, idx, stmts, a)) |end_idx| {
                    idx = end_idx;
                    continue;
                }
            }
            if (returnCleanupSkip(instructions, idx)) |skip| {
                idx += skip - 1;
                continue;
            }
            if (loop_header) |header_id| {
                if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                    if (block.terminator()) |blk_term| {
                        if (blk_term.offset == inst.offset) {
                            const trace_on = self.trace_loop_guards and self.trace_file != null;
                            if (try self.guardBranchToHeader(block, inst, header_id, trace_on)) |branch| {
                                const cond = try sim.stack.popExpr();
                                const guard_cond = try self.guardCondForBranch(cond, inst.opcode, branch.taken);
                                if (trace_on) {
                                    const insert_idx = stmts.items.len;
                                    try self.emitGuardTrace(
                                        block_id,
                                        header_id,
                                        inst,
                                        branch.target,
                                        guard_cond,
                                        insert_idx,
                                        branch.path,
                                    );
                                }
                                const cont = try self.makeContinue();
                                const body = try a.alloc(*Stmt, 1);
                                body[0] = cont;
                                const guard_stmt = try a.create(Stmt);
                                guard_stmt.* = .{ .if_stmt = .{
                                    .condition = guard_cond,
                                    .body = body,
                                    .else_body = &.{},
                                } };
                                try stmts.append(a, guard_stmt);
                                return;
                            }
                        }
                    }
                }
            }
            switch (inst.opcode) {
                .UNPACK_SEQUENCE, .UNPACK_EX => {
                    const count = if (inst.opcode == .UNPACK_EX) blk: {
                        const before = inst.arg & 0xFF;
                        const after = (inst.arg >> 8) & 0xFF;
                        break :blk before + 1 + after;
                    } else inst.arg;
                    if (skip_first_store.*) {
                        skip_first_store.* = false;
                        if (count == 0) {
                            // Empty unpack as for loop target - just consume the value
                            _ = sim.stack.pop();
                            continue;
                        }
                        skip_store_count = count;
                        try sim.simulate(inst);
                        continue;
                    }
                    // Handle nested UNPACK_SEQUENCE when skipping for-loop targets
                    if (skip_store_count > 0) {
                        // This UNPACK_SEQUENCE is unpacking one of the elements from the outer unpack
                        // Decrement for the one element consumed, add the inner count
                        skip_store_count = skip_store_count - 1 + count;
                        try sim.simulate(inst);
                        continue;
                    }
                    const skip_count = try self.handleUnpack(&sim, &chain_targets, instructions, idx, stmts, a);
                    if (skip_count > 0) {
                        idx += skip_count;
                        continue;
                    }
                    continue;
                },
                .STORE_FAST, .STORE_NAME, .STORE_GLOBAL, .STORE_DEREF => {
                    if (skip_store_count > 0) {
                        skip_store_count -= 1;
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        val.deinit(sim.allocator, sim.stack_alloc);
                        continue;
                    }
                    if (skip_first_store.*) {
                        skip_first_store.* = false;
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        val.deinit(sim.allocator, sim.stack_alloc);
                        continue;
                    }
                    var name = switch (inst.opcode) {
                        .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                        .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                        else => sim.getName(inst.arg) orelse "__unknown__",
                    };
                    if (inst.opcode == .STORE_DEREF and self.version.gte(3, 14) and std.mem.eql(u8, name, "__classdict__")) {
                        name = "__unknown__";
                    }
                    var chain_idx = idx;
                    if (try self.tryHandleChainAssignStore(&sim, instructions, &chain_idx, name, stmts, a)) {
                        idx = chain_idx;
                        continue;
                    }
                    var value = sim.stack.pop() orelse return error.StackUnderflow;
                    if (value == .unknown or value == .null_marker) {
                        const real_idx = skip_first + idx;
                        if (try self.tryRecoverTernaryStore(block_id, real_idx)) |expr| {
                            value.deinit(sim.allocator, sim.stack_alloc);
                            value = .{ .expr = expr };
                        }
                    }
                    if (try self.handleStoreValue(&sim, name, value)) |stmt| {
                        try stmts.append(a, stmt);
                    }
                },
                .STORE_SUBSCR => {
                    var chain_idx = idx;
                    if (try self.tryHandleChainAssignSubscr(&sim, instructions, &chain_idx, stmts, a)) {
                        idx = chain_idx;
                        continue;
                    }
                    try self.emitStoreSubscr(&sim, stmts, a);
                },
                .STORE_SLICE => {
                    try self.emitStoreSlice(&sim, stmts, a);
                },
                .STORE_ATTR => {
                    try self.emitStoreAttr(&sim, &chain_targets, block_id, instructions, &idx, stmts, a, skip_first, null);
                },
                .JUMP_FORWARD, .JUMP_BACKWARD, .JUMP_BACKWARD_NO_INTERRUPT, .JUMP_ABSOLUTE => {
                    // When stop_at_jump is true, we're at the natural end of a loop body.
                    // The terminating back-edge is NOT a continue statement - it's implicit.
                    // Only emit break/continue for jumps that are NOT the natural terminator.
                    if (stop_at_jump) return;
                    if (loop_header) |header_id| {
                        const exit = self.analyzer.detectLoopExit(block_id, &[_]u32{header_id});
                        switch (exit) {
                            .break_stmt => {
                                const stmt = try self.makeBreak();
                                try stmts.append(a, stmt);
                                return;
                            },
                            .continue_stmt => {
                                const stmt = try self.makeContinue();
                                try stmts.append(a, stmt);
                                var cur = block_id;
                                var next = cur + 1;
                                while (next < self.cfg.blocks.len) : (next += 1) {
                                    const prev_blk = &self.cfg.blocks[cur];
                                    const next_blk = &self.cfg.blocks[next];
                                    if (next_blk.start_offset != prev_blk.end_offset) break;
                                    const target = self.jumpTargetIfJumpOnlyInst(next, true) orelse break;
                                    if (target != header_id) break;
                                    try self.consumed.set(self.allocator, next);
                                    const extra = try self.makeContinue();
                                    try stmts.append(a, extra);
                                    cur = next;
                                }
                                return;
                            },
                            else => {},
                        }
                    }
                },
                .RETURN_VALUE => {
                    var value = try sim.stack.popExpr();
                    if (self.isPlaceholderExpr(value)) {
                        if (try self.tryRecoverWithReturnValue(block, idx)) |recovered| {
                            value = recovered;
                        }
                    }
                    // Skip 'return None' at module level (implicit return)
                    if (self.isModuleLevel() and value.* == .constant and value.constant == .none) {
                        continue;
                    }
                    const stmt = try self.makeReturn(value);
                    try stmts.append(a, stmt);
                },
                .RETURN_CONST => {
                    if (sim.getConst(inst.arg)) |obj| {
                        const value = try sim.objToExpr(obj);
                        // Skip 'return None' at module level (implicit return)
                        if (self.isModuleLevel() and value.* == .constant and value.constant == .none) {
                            continue;
                        }
                        const stmt = try self.makeReturn(value);
                        try stmts.append(a, stmt);
                    }
                },
                .POP_TOP => {
                    try self.handlePopTopStmt(&sim, block, stmts, a);
                },
                .YIELD_VALUE => {
                    if (self.version.lt(2, 5) and sim.comp_builder == null) {
                        const value = try sim.stack.popExpr();
                        const expr = try a.create(Expr);
                        expr.* = .{ .yield_expr = .{ .value = value } };
                        if (self.makeExprStmt(expr)) |stmt| {
                            try stmts.append(a, stmt);
                        } else |err| {
                            if (err != error.SkipStatement) return err;
                        }
                    } else {
                        try sim.simulate(inst);
                    }
                },
                .EXEC_STMT,
                .RAISE_VARARGS,
                .DELETE_NAME,
                .DELETE_FAST,
                .DELETE_GLOBAL,
                .DELETE_DEREF,
                .DELETE_ATTR,
                .DELETE_SUBSCR,
                .DELETE_SLICE_0,
                .DELETE_SLICE_1,
                .DELETE_SLICE_2,
                .DELETE_SLICE_3,
                => {
                    if (try self.tryEmitStatement(inst, &sim, block_id, skip_first + idx)) |stmt| {
                        try stmts.append(a, stmt);
                    }
                },
                .WITH_EXCEPT_START, .WITH_CLEANUP_START, .WITH_CLEANUP_FINISH, .WITH_CLEANUP => {
                    continue;
                },
                else => {
                    try sim.simulate(inst);
                },
            }
        }
    }

    fn handlePopTopStmt(
        self: *Decompiler,
        sim: *SimContext,
        block: *const cfg_mod.BasicBlock,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!void {
        if (sim.stack.len() == 0) {
            return;
        }
        if (block.instructions.len > 0 and block.instructions[0].opcode == .POP_TOP) {
            const last = block.instructions[block.instructions.len - 1];
            if (last.opcode == .RETURN_VALUE or last.opcode == .RETURN_CONST) {
                var cleanup_pred = false;
                for (block.predecessors) |pred_id| {
                    if (pred_id >= self.cfg.blocks.len) continue;
                    const pred = &self.cfg.blocks[pred_id];
                    var j = pred.instructions.len;
                    while (j > 0) {
                        j -= 1;
                        const inst = pred.instructions[j];
                        if (inst.opcode == .NOP or inst.opcode == .NOT_TAKEN) continue;
                        if (inst.opcode == .POP_BLOCK) {
                            cleanup_pred = true;
                        }
                        break;
                    }
                    if (cleanup_pred) break;
                }
                if (cleanup_pred) {
                    const cleanup = sim.stack.pop().?;
                    cleanup.deinit(sim.allocator, sim.stack_alloc);
                    return;
                }
            }
        }
        if (block.instructions.len == 2) {
            const first = block.instructions[0];
            const second = block.instructions[1];
            if (first.opcode == .POP_TOP and second.isUnconditionalJump()) {
                const cleanup = sim.stack.pop().?;
                var val = cleanup;
                val.deinit(sim.allocator, sim.stack_alloc);
                return;
            }
        }
        const val = sim.stack.pop().?;
        switch (val) {
            .expr => |e| {
                if (self.makeExprStmt(e)) |stmt| {
                    try stmts.append(stmts_allocator, stmt);
                } else |err| {
                    if (err != error.SkipStatement) return err;
                }
            },
            else => {
                // Discard non-expression values (e.g., intermediate stack values)
                val.deinit(sim.allocator, sim.stack_alloc);
            },
        }
    }

    /// Process part of a block (before control flow instruction).
    pub fn processPartialBlock(
        self: *Decompiler,
        block: *const cfg_mod.BasicBlock,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
        skip_first_store: *bool,
        stop_idx: ?usize,
    ) DecompileError!void {
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        defer sim.deinit();
        var chain_targets: std.ArrayListUnmanaged(*Expr) = .{};
        defer chain_targets.deinit(self.allocator);

        if (block.id < self.stack_in.len) {
            if (self.stack_in[block.id]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }
        if (sim.stack.len() == 0 and self.needsPredecessorSeed(block)) {
            try self.seedFromPredecessors(block.id, &sim);
        }

        const instructions = block.instructions;
        var idx: usize = 0;
        var skip_store_count: u32 = 0;
        while (idx < instructions.len) : (idx += 1) {
            if (stop_idx) |limit| {
                if (idx >= limit) break;
            }
            const inst = instructions[idx];
            // Stop at control flow instructions
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;

            if (inst.opcode == .IMPORT_NAME) {
                if (try self.tryDecompileImportFromGroup(&sim, instructions, idx, stmts, stmts_allocator)) |end_idx| {
                    idx = end_idx;
                    continue;
                }
            }
            switch (inst.opcode) {
                .UNPACK_SEQUENCE, .UNPACK_EX => {
                    const count = if (inst.opcode == .UNPACK_EX) blk: {
                        const before = inst.arg & 0xFF;
                        const after = (inst.arg >> 8) & 0xFF;
                        break :blk before + 1 + after;
                    } else inst.arg;
                    if (skip_first_store.*) {
                        skip_first_store.* = false;
                        if (count == 0) {
                            _ = sim.stack.pop();
                            continue;
                        }
                        skip_store_count = count;
                        try sim.simulate(inst);
                        continue;
                    }
                    // Handle nested UNPACK_SEQUENCE when skipping for-loop targets
                    if (skip_store_count > 0) {
                        // This UNPACK_SEQUENCE is unpacking one of the elements from the outer unpack
                        // Decrement for the one element consumed, add the inner count
                        skip_store_count = skip_store_count - 1 + count;
                        try sim.simulate(inst);
                        continue;
                    }
                    const skip_count = try self.handleUnpack(&sim, &chain_targets, instructions, idx, stmts, stmts_allocator);
                    if (skip_count > 0) {
                        idx += skip_count;
                        continue;
                    }
                },
                .STORE_FAST, .STORE_NAME, .STORE_GLOBAL, .STORE_DEREF => {
                    if (skip_store_count > 0) {
                        skip_store_count -= 1;
                        const val = sim.stack.pop() orelse return error.StackUnderflow;
                        val.deinit(sim.allocator, sim.stack_alloc);
                        continue;
                    }
                    if (skip_first_store.*) {
                        skip_first_store.* = false;
                        continue;
                    }
                    const name = switch (inst.opcode) {
                        .STORE_FAST => sim.getLocal(inst.arg) orelse "__unknown__",
                        .STORE_NAME, .STORE_GLOBAL => sim.getName(inst.arg) orelse "__unknown__",
                        .STORE_DEREF => sim.getDeref(inst.arg) orelse "__unknown__",
                        else => "__unknown__",
                    };
                    if (idx > 0 and instructions[idx - 1].opcode == .ROT_TWO and
                        idx + 1 < instructions.len and
                        !std.mem.eql(u8, name, "__classcell__"))
                    {
                        const next_inst = instructions[idx + 1];
                        const next_name: ?[]const u8 = switch (next_inst.opcode) {
                            .STORE_FAST => sim.getLocal(next_inst.arg),
                            .STORE_NAME, .STORE_GLOBAL => sim.getName(next_inst.arg),
                            .STORE_DEREF => sim.getDeref(next_inst.arg),
                            else => null,
                        };
                        if (next_name) |nn| {
                            if (!std.mem.eql(u8, nn, "__classcell__")) {
                                const items = sim.stack.items.items;
                                if (items.len >= 2 and
                                    (items[items.len - 1] == .expr or items[items.len - 1] == .unknown) and
                                    (items[items.len - 2] == .expr or items[items.len - 2] == .unknown))
                                {
                                    const arena = self.arena.allocator();
                                    const target1 = try self.makeName(name, .store);
                                    const target2 = try self.makeName(nn, .store);
                                    const val1 = try sim.stack.popExpr();
                                    const val2 = try sim.stack.popExpr();
                                    const rhs_elts = try arena.alloc(*Expr, 2);
                                    rhs_elts[0] = val1;
                                    rhs_elts[1] = val2;
                                    const rhs_tuple = try ast.makeTuple(arena, rhs_elts, .load);
                                    const tgt_slice = try arena.alloc(*Expr, 2);
                                    tgt_slice[0] = target1;
                                    tgt_slice[1] = target2;
                                    const stmt = try self.makeUnpackAssignExprs(tgt_slice, rhs_tuple);
                                    try stmts.append(stmts_allocator, stmt);
                                    idx += 1;
                                    continue;
                                }
                            }
                        }
                    }
                    // Check for walrus operator: COPY 1 followed by STORE_* with value used later
                    const prev_was_copy_1 = idx > 0 and instructions[idx - 1].opcode == .COPY and instructions[idx - 1].arg == 1;
                    if (prev_was_copy_1) {
                        const next_idx = idx + 1;
                        var is_walrus = false;
                        if (next_idx < instructions.len) {
                            const next_op = instructions[next_idx].opcode;
                            is_walrus = switch (next_op) {
                                .DUP_TOP, .COPY, .STORE_NAME, .STORE_FAST, .STORE_GLOBAL, .STORE_DEREF => false,
                                .COMPARE_OP, .CONTAINS_OP, .IS_OP,
                                .TO_BOOL, .POP_JUMP_IF_TRUE, .POP_JUMP_IF_FALSE,
                                .POP_JUMP_IF_NONE, .POP_JUMP_IF_NOT_NONE,
                                .POP_JUMP_FORWARD_IF_TRUE, .POP_JUMP_FORWARD_IF_FALSE,
                                .POP_JUMP_FORWARD_IF_NONE, .POP_JUMP_FORWARD_IF_NOT_NONE,
                                .LOAD_SMALL_INT, .LOAD_CONST, .LOAD_FAST, .LOAD_FAST_BORROW,
                                .LOAD_NAME, .LOAD_GLOBAL, .BINARY_OP,
                                => true,
                                else => false,
                            };
                        }

                        if (is_walrus) {
                            const copied = sim.stack.pop() orelse return error.StackUnderflow;
                            const val_expr = switch (copied) {
                                .expr => |e| e,
                                else => blk: {
                                    copied.deinit(sim.allocator, sim.stack_alloc);
                                    break :blk null;
                                },
                            };

                            if (val_expr) |expr| {
                                const arena = self.arena.allocator();
                                const target = try self.makeName(name, .store);
                                const named = try arena.create(Expr);
                                named.* = .{ .named_expr = .{ .target = target, .value = expr } };

                                if (sim.stack.pop()) |orig| {
                                    orig.deinit(sim.allocator, sim.stack_alloc);
                                }
                                try sim.stack.push(.{ .expr = named });
                                continue;
                            }
                        }
                    }

                    // Skip Python 3.14+ internal names (PEP 649)
                    if (self.version.gte(3, 14) and inst.opcode == .STORE_NAME) {
                        const is_internal = std.mem.eql(u8, name, "__annotate__") or
                            std.mem.eql(u8, name, "__conditional_annotations__");
                        if (is_internal) {
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                    }

                    // Try to recover PEP 695 constructs (type aliases, generic funcs/classes)
                    if (self.version.gte(3, 12)) {
                        if (try self.tryRecoverTypeAlias(&sim, instructions, idx, name)) |type_stmt| {
                            try stmts.append(stmts_allocator, type_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        if (try self.tryRecoverGenericTypeAlias(&sim, instructions, idx, name)) |type_stmt| {
                            try stmts.append(stmts_allocator, type_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        if (try self.tryRecoverGenericFunction(&sim, instructions, idx, name)) |func_stmt| {
                            try stmts.append(stmts_allocator, func_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                        if (try self.tryRecoverGenericClass(&sim, instructions, idx, name)) |class_stmt| {
                            try stmts.append(stmts_allocator, class_stmt);
                            const val = sim.stack.pop() orelse return error.StackUnderflow;
                            val.deinit(sim.allocator, sim.stack_alloc);
                            continue;
                        }
                    }

                    var chain_idx = idx;
                    if (try self.tryHandleChainAssignStore(&sim, instructions, &chain_idx, name, stmts, stmts_allocator)) {
                        idx = chain_idx;
                        continue;
                    }
                    var value = sim.stack.pop() orelse blk: {
                        if (sim.lenient or sim.stack.allow_underflow) break :blk StackValue.unknown;
                        return error.StackUnderflow;
                    };
                    if (value == .unknown or value == .null_marker) {
                        if (try self.tryRecoverTernaryStore(block.id, idx)) |expr| {
                            value.deinit(sim.allocator, sim.stack_alloc);
                            value = .{ .expr = expr };
                        }
                    }
                    if (try self.handleStoreValue(&sim, name, value)) |stmt| {
                        try stmts.append(stmts_allocator, stmt);
                    }
                },
                .STORE_ATTR => {
                    try self.emitStoreAttr(&sim, &chain_targets, block.id, instructions, &idx, stmts, stmts_allocator, 0, stop_idx);
                },
                .STORE_SUBSCR => {
                    var chain_idx = idx;
                    if (try self.tryHandleChainAssignSubscr(&sim, instructions, &chain_idx, stmts, stmts_allocator)) {
                        idx = chain_idx;
                        continue;
                    }
                    try self.emitStoreSubscr(&sim, stmts, stmts_allocator);
                },
                .STORE_SLICE => {
                    try self.emitStoreSlice(&sim, stmts, stmts_allocator);
                },
                .POP_TOP => {
                    try self.handlePopTopStmt(&sim, block, stmts, stmts_allocator);
                },
                else => {
                    try sim.simulate(inst);
                },
            }
        }
    }

    fn allowsEmptyPop(self: *Decompiler, block: *const cfg_mod.BasicBlock) bool {
        for (block.instructions) |inst| {
            switch (inst.opcode) {
                .END_FINALLY, .POP_EXCEPT, .RERAISE, .END_FOR => return true,
                else => {},
            }
        }
        if (block.instructions.len > 0 and block.instructions[0].opcode == .POP_TOP) {
            for (block.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                const term = pred.terminator() orelse continue;
                if (ctrl.Analyzer.isConditionalJump(undefined, term.opcode)) return true;
            }
        }
        // Check if predecessor is a for loop header (FOR_ITER terminator)
        for (block.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            const term = pred.terminator() orelse continue;
            if (term.opcode == .FOR_ITER) return true;
        }
        // Check if this is an exception handler
        if (block.is_exception_handler) return true;
        return false;
    }

    const LoopIfParts = struct {
        condition: *Expr,
        then_body: []const *Stmt,
        else_body: []const *Stmt,
        else_is_continuation: bool,
        then_leads: bool,
        else_leads: bool,
        cond_op: Opcode,
        then_block: u32,
        else_block: ?u32,
    };

    fn condExprFromBlock(
        self: *Decompiler,
        block_id: u32,
        sim: *SimContext,
        then_block: u32,
        else_block: ?u32,
        skip_first: usize,
    ) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];

        var conds: [2]*Expr = undefined;
        var jumps: [2]Opcode = undefined;
        var targets: [2]?u32 = .{ null, null };
        var cond_count: usize = 0;

        const instructions = block.instructions;
        var idx: usize = if (skip_first > instructions.len) instructions.len else skip_first;
        while (idx < instructions.len) : (idx += 1) {
            const inst = instructions[idx];
            if (inst.opcode == .NOT_TAKEN or inst.opcode == .CACHE) continue;
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) {
                const cond = try sim.stack.popExpr();
                if (cond_count < conds.len) {
                    conds[cond_count] = cond;
                    jumps[cond_count] = inst.opcode;
                    if (inst.jumpTarget(self.cfg.version)) |target_off| {
                        targets[cond_count] = self.cfg.blockAtOffset(target_off);
                    }
                    cond_count += 1;
                }
                if (cond_count >= 2) break;
                continue;
            }
            try sim.simulate(inst);
        }

        if (cond_count == 0) return null;
        if (cond_count == 1) return conds[0];

        if (else_block) |else_id| {
            if (targets[0] != null and targets[1] != null) {
                const t0 = targets[0].?;
                const t1 = targets[1].?;
                if (t0 == then_block and t1 == else_id and
                    self.isTrueJump(jumps[0]) and self.isFalseJump(jumps[1]))
                {
                    return try self.makeBoolPair(conds[0], conds[1], .or_);
                }
                if (t0 == else_id and t1 == else_id and
                    self.isFalseJump(jumps[0]) and self.isFalseJump(jumps[1]))
                {
                    return try self.makeBoolPair(conds[0], conds[1], .and_);
                }
            }
        }

        return conds[0];
    }

    fn condExprFromBlockSeeded(
        self: *Decompiler,
        block_id: u32,
        then_block: u32,
        else_block: ?u32,
    ) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        if (block_id < self.stack_in.len) {
            if (self.stack_in[block_id]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }
        const exc_count = self.exceptionSeedCount(block_id, block);
        if (exc_count > 0) {
            for (0..exc_count) |_| {
                const placeholder = try self.arena.allocator().create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                try sim.stack.push(.{ .expr = placeholder });
            }
        }
        if (self.stackAllUnknown(&sim.stack) and self.needsPredecessorSeed(block)) {
            sim.stack.reset();
            try self.seedFromPredecessors(block_id, &sim);
        }
        return self.condExprFromBlock(block_id, &sim, then_block, else_block, 0);
    }

    const LoopCond = struct {
        expr: *Expr,
        base_vals: []StackValue,
    };

    fn loopCondExpr(
        self: *Decompiler,
        block_id: u32,
        then_block: u32,
        else_block: ?u32,
        skip_first: usize,
    ) DecompileError!?LoopCond {
        if (block_id >= self.cfg.blocks.len) return null;
        const cond_block = &self.cfg.blocks[block_id];

        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;

        if (block_id < self.stack_in.len) {
            if (self.stack_in[block_id]) |entry| {
                for (entry) |val| {
                    const cloned = try sim.cloneStackValue(val);
                    try sim.stack.push(cloned);
                }
            }
        }
        const exc_count = self.exceptionSeedCount(block_id, cond_block);
        if (exc_count > 0) {
            for (0..exc_count) |_| {
                const placeholder = try self.arena.allocator().create(Expr);
                placeholder.* = .{ .name = .{ .id = "__exception__", .ctx = .load } };
                try sim.stack.push(.{ .expr = placeholder });
            }
        }
        if (self.stackAllUnknown(&sim.stack) and self.needsPredecessorSeed(cond_block)) {
            sim.stack.reset();
            try self.seedFromPredecessors(block_id, &sim);
        }

        const expr = (try self.condExprFromBlock(block_id, &sim, then_block, else_block, skip_first)) orelse return null;
        const base_vals = try self.cloneStackValues(sim.stack.items.items);
        return .{ .expr = expr, .base_vals = base_vals };
    }

    fn decompileLoopExitBranch(
        self: *Decompiler,
        block_id: u32,
        end_block: ?u32,
        seed_pop: bool,
    ) DecompileError![]const *Stmt {
        const skip: usize = if (seed_pop) 1 else 0;
        if (self.jumpTargetIfJumpOnly(block_id, true) != null) {
            try self.consumed.set(self.allocator, block_id);
            return &[_]*Stmt{};
        }
        const end = end_block orelse (block_id + 1);
        const body = try self.decompileBlockRangeWithStackAndSkip(block_id, end, &.{}, skip);
        var bid = block_id;
        while (bid < end and bid < self.cfg.blocks.len) : (bid += 1) {
            try self.consumed.set(self.allocator, bid);
        }
        return body;
    }

    fn loopIfParts(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        loop_header: u32,
        visited: *std.DynamicBitSet,
        stop_block: ?u32,
    ) DecompileError!?LoopIfParts {
        if (self.if_in_progress) |*set| {
            if (set.isSet(pattern.condition_block)) return null;
            set.set(pattern.condition_block);
            defer set.unset(pattern.condition_block);
        }
        var stop = stop_block;
        if (stop != null and stop.? == loop_header) {
            stop = null;
        }
        const cond_block = &self.cfg.blocks[pattern.condition_block];
        const term = cond_block.terminator() orelse return null;
        var cond_op = term.opcode;
        const legacy_cond = cond_op == .JUMP_IF_FALSE or cond_op == .JUMP_IF_TRUE;

        var last_stmt_idx: ?usize = null;
        for (cond_block.instructions, 0..) |inst, idx| {
            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
            if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
            switch (inst.opcode) {
                .STORE_FAST,
                .STORE_NAME,
                .STORE_GLOBAL,
                .STORE_DEREF,
                .STORE_ATTR,
                .STORE_SUBSCR,
                .POP_TOP,
                .DELETE_NAME,
                .DELETE_FAST,
                .DELETE_GLOBAL,
                .DELETE_DEREF,
                .DELETE_ATTR,
                .DELETE_SUBSCR,
                .RETURN_VALUE,
                .RETURN_CONST,
                .RAISE_VARARGS,
                => last_stmt_idx = idx + 1,
                else => {},
            }
        }
        const skip_cond = last_stmt_idx orelse 0;

        const cond_res = (try self.loopCondExpr(
            pattern.condition_block,
            pattern.then_block,
            pattern.else_block,
            skip_cond,
        )) orelse return null;
        var condition = cond_res.expr;
        const base_vals = cond_res.base_vals;
        defer self.deinitStackValues(base_vals);
        var then_block = pattern.then_block;
        var else_block = pattern.else_block;
        var is_elif = pattern.is_elif;
        var merge_block: ?u32 = pattern.merge_block;
        if (try self.loopIfMergeFromEnd(pattern, loop_header)) |loop_merge| {
            if (try self.postDominates(loop_merge, pattern.condition_block)) {
                merge_block = loop_merge;
            }
        }
        if (merge_block == null and else_block != null) {
            const else_id = else_block.?;
            if (!try self.reachesBlockNoBack(then_block, else_id, pattern.condition_block)) {
                if (try self.commonMergeNoLoopBack(then_block, else_id, pattern.condition_block)) |mid| {
                    if (self.analyzer.inLoop(mid, loop_header)) {
                        merge_block = mid;
                    }
                }
            }
        }
        if (is_elif) {
            if (else_block) |else_id| {
                const else_pat = try self.analyzer.detectPattern(else_id);
                if (else_pat == .if_stmt) {
                    const elif_pat = else_pat.if_stmt;
                    if (elif_pat.then_block == then_block and elif_pat.else_block != null and
                        self.resolveJumpOnlyBlock(elif_pat.else_block.?) == loop_header)
                    {
                        const elif_block = &self.cfg.blocks[elif_pat.condition_block];
                        var elif_last: ?usize = null;
                        for (elif_block.instructions, 0..) |inst, idx| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, inst.opcode)) break;
                            if (inst.opcode == .JUMP_BACKWARD or inst.opcode == .JUMP_BACKWARD_NO_INTERRUPT) break;
                            switch (inst.opcode) {
                                .STORE_FAST,
                                .STORE_NAME,
                                .STORE_GLOBAL,
                                .STORE_DEREF,
                                .STORE_ATTR,
                                .STORE_SUBSCR,
                                .POP_TOP,
                                .DELETE_NAME,
                                .DELETE_FAST,
                                .DELETE_GLOBAL,
                                .DELETE_DEREF,
                                .DELETE_ATTR,
                                .DELETE_SUBSCR,
                                .RETURN_VALUE,
                                .RETURN_CONST,
                                .RAISE_VARARGS,
                                => elif_last = idx + 1,
                                else => {},
                            }
                        }
                        const elif_skip = elif_last orelse 0;
                        if (try self.loopCondExpr(elif_pat.condition_block, elif_pat.then_block, elif_pat.else_block, elif_skip)) |elif_res| {
                            defer self.deinitStackValues(elif_res.base_vals);
                            condition = try self.makeBoolPair(condition, elif_res.expr, .or_);
                            if (self.cfg.blocks[elif_pat.condition_block].terminator()) |elif_term| {
                                cond_op = elif_term.opcode;
                            }
                            visited.set(else_id);
                            else_block = elif_pat.else_block;
                            is_elif = false;
                        }
                    }
                }
            }
        }
        if (!is_elif) {
            if (merge_block) |merge_id| {
                if (else_block) |else_id| {
                    if (merge_id == else_id) {
                        const else_term = self.isTerminalBlock(else_id);
                        if (!else_term and try self.postDominates(else_id, then_block)) {
                            else_block = null;
                        }
                    }
                }
            }
        }
        if (!is_elif) {
            if (else_block) |else_id| {
                const else_res = self.resolveJumpOnlyBlock(else_id);
                const then_res = self.resolveJumpOnlyBlock(then_block);
                if (else_res != loop_header and then_res != loop_header and
                    !self.blockLeadsToHeader(then_block, loop_header) and
                    else_id > pattern.condition_block and
                    try self.reachesBlockNoBack(then_block, else_id, loop_header))
                {
                    var keep_else = false;
                    if (else_id < self.cfg.blocks.len) {
                        const else_blk = &self.cfg.blocks[else_id];
                        if (else_blk.terminator()) |else_term| {
                            if (ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) {
                                for (else_blk.successors) |edge| {
                                    if (edge.edge_type == .exception) continue;
                                    if (self.resolveJumpOnlyBlock(edge.target) == loop_header) {
                                        keep_else = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (!keep_else) {
                        if (merge_block == null) {
                            merge_block = else_id;
                        }
                        else_block = null;
                        if (self.if_next == null) {
                            self.if_next = merge_block.?;
                        }
                    }
                }
            }
        }

        var cond_tree_applied = false;
        if (!is_elif) {
            if (else_block) |else_id| {
                var seen = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                defer seen.deinit();
                const else_res = self.resolveJumpOnlyBlock(else_id);
                const else_to_header = else_res == loop_header or self.loopBlockLeadsToContinue(else_id, loop_header);
                var cur = then_block;
                var final_then = then_block;
                var final_then_raw = then_block;
                var progressed = false;
                var chain_expr: ?*Expr = condition;
                while (cur < self.cfg.blocks.len) {
                    if (seen.isSet(cur)) break;
                    seen.set(cur);
                    const blk = &self.cfg.blocks[cur];
                    const blk_term = blk.terminator() orelse break;
                    if (!ctrl.Analyzer.isConditionalJump(undefined, blk_term.opcode)) break;
                    if (condBlockHasPrelude(blk)) break;
                    var t_id: ?u32 = null;
                    var f_id: ?u32 = null;
                    for (blk.successors) |edge| {
                        if (edge.edge_type == .exception) continue;
                        if (edge.edge_type == .conditional_false) {
                            f_id = edge.target;
                        } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                            t_id = edge.target;
                        }
                    }
                    if (t_id == null or f_id == null) break;
                    if (self.resolveJumpOnlyBlock(f_id.?) != else_res) break;
                    if (t_id.? == else_id) break;
                    progressed = true;
                    if (chain_expr) |expr| {
                        if (try self.condExprFromBlockSeeded(cur, t_id.?, f_id.?)) |cond2| {
                            chain_expr = try self.makeBoolPair(expr, cond2, .and_);
                        } else {
                            chain_expr = null;
                        }
                    }
                    final_then_raw = t_id.?;
                    final_then = self.resolveJumpOnlyBlock(t_id.?);
                    cur = t_id.?;
                }
                if (progressed and final_then != then_block and !else_to_header) {
                    var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                    defer in_stack.deinit();
                    var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
                    defer memo.deinit(self.allocator);
                    var mark_seen = false;
                    if (try self.buildCondTree(
                        pattern.condition_block,
                        pattern.condition_block,
                        condition,
                        final_then,
                        else_id,
                        base_vals,
                        null,
                        null,
                        &in_stack,
                        &memo,
                    )) |expr| {
                        condition = expr;
                        const raw_break = self.loopBreakTarget(final_then_raw, loop_header) != null;
                        const raw_in_loop = self.analyzer.inLoop(final_then_raw, loop_header);
                        const final_in_loop = self.analyzer.inLoop(final_then, loop_header);
                        const prefer_raw = final_then == loop_header or (raw_in_loop and !final_in_loop and raw_break);
                        then_block = if (prefer_raw) final_then_raw else final_then;
                        cond_tree_applied = true;
                        try self.markCondChainConsumed(pattern.condition_block, &memo);
                        mark_seen = true;
                    } else if (chain_expr) |expr| {
                        condition = expr;
                        const raw_break = self.loopBreakTarget(final_then_raw, loop_header) != null;
                        const raw_in_loop = self.analyzer.inLoop(final_then_raw, loop_header);
                        const final_in_loop = self.analyzer.inLoop(final_then, loop_header);
                        const prefer_raw = final_then == loop_header or (raw_in_loop and !final_in_loop and raw_break);
                        then_block = if (prefer_raw) final_then_raw else final_then;
                        cond_tree_applied = true;
                        mark_seen = true;
                    }
                    if (mark_seen) {
                        var bid: u32 = 0;
                        while (bid < self.cfg.blocks.len) : (bid += 1) {
                            if (!seen.isSet(bid)) continue;
                            if (bid == pattern.condition_block) continue;
                            const chain_blk = &self.cfg.blocks[bid];
                            const chain_term = chain_blk.terminator() orelse continue;
                            if (!ctrl.Analyzer.isConditionalJump(undefined, chain_term.opcode)) continue;
                            try self.consumed.set(self.allocator, bid);
                            visited.set(bid);
                        }
                    }
                }
            }
        }

        if (!cond_tree_applied) {
            if (else_block) |else_id| {
                if (self.resolveJumpOnlyBlock(then_block) == loop_header) {
                    var seen_true = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                    defer seen_true.deinit();
                    var cur_true = else_id;
                    var final_else = else_id;
                    var progressed_true = false;
                    while (cur_true < self.cfg.blocks.len) {
                        if (seen_true.isSet(cur_true)) break;
                        seen_true.set(cur_true);
                        const blk = &self.cfg.blocks[cur_true];
                        const blk_term = blk.terminator() orelse break;
                        if (!ctrl.Analyzer.isConditionalJump(undefined, blk_term.opcode)) break;
                        if (condBlockHasPrelude(blk)) break;
                        var t_id: ?u32 = null;
                        var f_id: ?u32 = null;
                        for (blk.successors) |edge| {
                            if (edge.edge_type == .exception) continue;
                            if (edge.edge_type == .conditional_false) {
                                f_id = edge.target;
                            } else if (edge.edge_type == .conditional_true or edge.edge_type == .normal) {
                                t_id = edge.target;
                            }
                        }
                        if (t_id == null or f_id == null) break;
                        if (self.resolveJumpOnlyBlock(t_id.?) != loop_header) break;
                        if (f_id.? == loop_header) break;
                        progressed_true = true;
                        final_else = self.resolveJumpOnlyBlock(f_id.?);
                        cur_true = f_id.?;
                    }
                    if (progressed_true and final_else != else_id) {
                        var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                        defer in_stack.deinit();
                        var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
                        defer memo.deinit(self.allocator);
                        if (try self.buildCondTree(
                            pattern.condition_block,
                            pattern.condition_block,
                            condition,
                            loop_header,
                            final_else,
                            base_vals,
                            null,
                            null,
                            &in_stack,
                            &memo,
                        )) |expr| {
                            condition = expr;
                            else_block = final_else;
                            cond_tree_applied = true;
                            try self.markCondChainConsumed(pattern.condition_block, &memo);
                        }
                    }
                }
            }
        }

        if (!cond_tree_applied and !is_elif) {
            if (else_block) |else_id| {
                if (else_id < self.cfg.blocks.len) {
                    const else_blk = &self.cfg.blocks[else_id];
                    if (else_blk.terminator()) |else_term| {
                        if (ctrl.Analyzer.isConditionalJump(undefined, else_term.opcode)) {
                            if (try self.condChainFalseTarget(else_id, then_block)) |fb| {
                                var in_stack = try std.DynamicBitSet.initEmpty(self.allocator, self.cfg.blocks.len);
                                defer in_stack.deinit();
                                var memo: std.AutoHashMapUnmanaged(u32, *Expr) = .{};
                                defer memo.deinit(self.allocator);
                                if (try self.buildCondTree(
                                    pattern.condition_block,
                                    pattern.condition_block,
                                    condition,
                                    then_block,
                                    fb,
                                    base_vals,
                                    null,
                                    null,
                                    &in_stack,
                                    &memo,
                                )) |expr| {
                                    condition = expr;
                                    else_block = fb;
                                    cond_tree_applied = true;
                                    try self.markCondChainConsumed(pattern.condition_block, &memo);
                                }
                            }
                        }
                    }
                }
            }
        }

        if (!cond_tree_applied and self.isTrueJump(cond_op) and else_block != null) {
            const then_res = self.resolveJumpOnlyBlock(then_block);
            if (then_res != loop_header) {
                const else_res = self.resolveJumpOnlyBlock(else_block.?);
                const else_cont = else_res == loop_header or
                    self.loopBlockLeadsToContinue(else_block.?, loop_header);
                if (!else_cont) {
                    condition = try self.invertConditionExpr(condition);
                    try self.emitDecisionTrace(pattern.condition_block, "loop_if_invert_true_jump", condition);
                    const tmp = then_block;
                    then_block = else_block.?;
                    else_block = tmp;
                    is_elif = false;
                    cond_op = self.invertJumpOpcode(cond_op);
                }
            }
        }

        const then_res = self.resolveJumpOnlyBlock(then_block);
        const else_res = if (else_block) |else_id| self.resolveJumpOnlyBlock(else_id) else null;
        var then_to_header = then_res == loop_header or self.loopBlockLeadsToContinue(then_block, loop_header);
        var else_to_header = false;
        if (else_block) |else_id| {
            if (else_res) |res| {
                if (res == loop_header) else_to_header = true;
            }
            if (!else_to_header and self.loopBlockLeadsToContinue(else_id, loop_header)) {
                var else_has_body = false;
                if (else_res) |res| {
                    if (res < self.cfg.blocks.len) {
                        const else_blk = &self.cfg.blocks[res];
                        if (!self.blockIsCleanupOnly(else_blk) and self.jumpTargetIfJumpOnly(res, true) == null) {
                            else_has_body = true;
                        }
                    }
                }
                if (!else_has_body) {
                    else_to_header = true;
                }
            }
        }

        const then_is_continue = then_res == loop_header;
        const then_empty = then_is_continue or self.blockIsCleanupOnly(&self.cfg.blocks[then_block]);
        if (then_to_header and then_empty and else_block != null and !else_to_header and !then_is_continue) {
            condition = try self.invertConditionExpr(condition);
            try self.emitDecisionTrace(pattern.condition_block, "loop_if_invert_then_to_header", condition);
            then_block = else_block.?;
            else_block = null;
            is_elif = false;
            then_to_header = false;
            else_to_header = true;
        }

        if (then_to_header and else_block == null) return null;

        const then_in_loop = self.analyzer.inLoop(then_block, loop_header);
        const else_in_loop = if (else_block) |else_id|
            self.analyzer.inLoop(else_id, loop_header)
        else
            false;
        const merge_in_loop = if (merge_block) |merge_id|
            self.analyzer.inLoop(merge_id, loop_header)
        else
            false;
        var else_is_continuation = else_to_header or (else_in_loop and !merge_in_loop and !then_in_loop);
        var else_is_fallthrough = false;
        if (stop_block) |stop_id| {
            if (else_block) |else_id| {
                if (else_id == stop_id) {
                    else_is_continuation = true;
                    else_is_fallthrough = true;
                } else if (stop_id < self.cfg.blocks.len and else_id < self.cfg.blocks.len) {
                    const stop_off = self.cfg.blocks[stop_id].start_offset;
                    const else_off = self.cfg.blocks[else_id].start_offset;
                    const cond_off = self.cfg.blocks[pattern.condition_block].start_offset;
                    if (stop_off > cond_off and else_off >= stop_off) {
                        else_is_continuation = true;
                        else_is_fallthrough = true;
                    }
                }
            }
        }
        if (!else_is_fallthrough) {
            if (else_block) |else_id| {
                if (self.isLoopTailBack(else_id, loop_header)) {
                    var other_pred = false;
                    for (self.cfg.blocks[else_id].predecessors) |pred_id| {
                        if (pred_id >= self.cfg.blocks.len) continue;
                        if (pred_id == pattern.condition_block) continue;
                        if (!self.analyzer.inLoop(pred_id, loop_header)) continue;
                        const pred = &self.cfg.blocks[pred_id];
                        for (pred.successors) |edge| {
                            if (edge.edge_type == .exception) continue;
                            if (edge.target == else_id) {
                                other_pred = true;
                                break;
                            }
                        }
                        if (other_pred) break;
                    }
                    if (other_pred) {
                        else_is_continuation = true;
                        else_is_fallthrough = true;
                    }
                }
            }
        }
        if (!else_is_continuation) {
            if (else_block) |else_id| {
                if (self.hasSingleNormalSuccessor(then_block, else_id)) {
                    else_is_continuation = true;
                    else_is_fallthrough = true;
                }
            }
        }
        if (!else_is_continuation) {
            if (merge_block) |merge_id| {
                if (else_block) |else_id| {
                    if (merge_id == else_id) {
                        const else_blk = &self.cfg.blocks[else_id];
                        if (self.blockIsCleanupOnly(else_blk) or self.resolveJumpOnlyBlock(else_id) != else_id) {
                            else_is_continuation = true;
                            else_is_fallthrough = true;
                        }
                    }
                }
            }
        }
        const then_break_tgt = self.loopBreakTarget(then_block, loop_header);
        const then_exit_outside = then_in_loop and self.blockExitsLoop(then_block, loop_header) and !then_to_header;
        const then_exit = then_break_tgt != null or self.isTerminalBlock(then_block) or then_exit_outside;
        if (then_exit and else_is_continuation and else_block != null and else_in_loop) {
            else_is_fallthrough = true;
        }
        if (else_is_continuation) {
            if (else_block) |else_id| {
                const else_resolved = self.resolveJumpOnlyBlock(else_id);
                if (else_resolved < self.cfg.blocks.len and else_resolved != loop_header) {
                    const else_blk = &self.cfg.blocks[else_resolved];
                    if (!self.blockIsCleanupOnly(else_blk) and self.jumpTargetIfJumpOnly(else_resolved, true) == null) {
                        else_is_continuation = false;
                    }
                }
            }
        }
        if (else_is_fallthrough) {
            else_is_continuation = true;
        }
        // Decompile the then body
        var skip_first = false;
        const then_block_ptr = &self.cfg.blocks[then_block];
        var seed_then = legacy_cond and then_block_ptr.instructions.len > 0 and then_block_ptr.instructions[0].opcode == .POP_TOP;
        var body_stop: ?u32 = null;
        if (else_block) |else_id| {
            if (else_id > then_block) {
                body_stop = else_id;
            } else if (else_is_continuation) {
                body_stop = else_id;
            }
        }
        if (merge_in_loop) {
            if (merge_block) |merge_id| {
                if (merge_id > then_block and (body_stop == null or merge_id < body_stop.?)) {
                    body_stop = merge_id;
                }
            }
        }
        const scoped_body_stop = self.stopAfter(then_block, body_stop, stop);
        const a = self.arena.allocator();
        const then_resolved = self.resolveJumpOnlyBlock(then_block);
        var then_body: []const *Stmt = &[_]*Stmt{};
        if (then_resolved == loop_header) {
            try self.consumed.set(self.allocator, then_block);
        } else {
            then_body = if ((then_exit and !then_in_loop) or then_exit_outside) blk: {
                var end = scoped_body_stop;
                if (then_break_tgt) |tgt| {
                    if (end == null or tgt < end.?) end = tgt;
                }
                const body = try self.decompileLoopExitBranch(then_block, end, seed_then);
                break :blk body;
            } else try self.decompileLoopBody(
                then_block,
                loop_header,
                &skip_first,
                &seed_then,
                visited,
                scoped_body_stop,
                0,
                false,
            );
            if (!self.bodyEndsLoopTerminal(then_body)) {
                if (then_block < self.cfg.blocks.len) {
                    const then_blk = &self.cfg.blocks[then_block];
                    const last_inst = if (then_blk.instructions.len > 0) then_blk.instructions[then_blk.instructions.len - 1] else null;
                    if (last_inst != null and last_inst.?.opcode == .POP_BLOCK) {
                        var single_succ: ?u32 = null;
                        var multi = false;
                        for (then_blk.successors) |edge| {
                            if (edge.edge_type == .exception) continue;
                            if (single_succ != null) {
                                multi = true;
                                break;
                            }
                            single_succ = edge.target;
                        }
                        if (!multi) {
                            if (single_succ) |succ_id| {
                                if (succ_id < self.cfg.blocks.len and self.isTerminalBlock(succ_id) and self.termSinglePred(succ_id)) {
                                    var tmp: std.ArrayListUnmanaged(*Stmt) = .{};
                                    defer tmp.deinit(a);
                                    try self.decompileBlockIntoWithStackAndSkip(succ_id, &tmp, a, &.{}, 0);
                                    if (tmp.items.len > 0) {
                                        const last = tmp.items[tmp.items.len - 1];
                                        if (self.stmtIsTerminal(last)) {
                                            then_body = try self.appendStmt(a, then_body, last);
                                            try self.consumed.set(self.allocator, succ_id);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Decompile the else body if present
        var else_body = if (else_block) |else_id| blk: {
            var skip = false;
            const else_block_ptr = &self.cfg.blocks[else_id];
            var seed_else = legacy_cond and else_block_ptr.instructions.len > 0 and else_block_ptr.instructions[0].opcode == .POP_TOP;
            const else_break_tgt = self.loopBreakTarget(else_id, loop_header);
            const else_exit_outside = else_in_loop and self.blockExitsLoop(else_id, loop_header) and !else_to_header;
            const else_exit = else_break_tgt != null or self.isTerminalBlock(else_id) or else_exit_outside;
            const else_stop = stop_blk: {
                if (merge_in_loop and merge_block != null and merge_block.? != else_id) {
                    const merge_id = merge_block.?;
                    if (merge_id < self.cfg.blocks.len and else_id < self.cfg.blocks.len) {
                        if (self.cfg.blocks[merge_id].start_offset <= self.cfg.blocks[else_id].start_offset) {
                            break :stop_blk null;
                        }
                    }
                    break :stop_blk merge_id;
                }
                break :stop_blk null;
            };
            const scoped_else_stop = self.stopAfter(else_id, else_stop, stop);
            if ((else_exit and !else_in_loop) or else_exit_outside) {
                var end = scoped_else_stop;
                if (else_break_tgt) |tgt| {
                    if (end == null or tgt < end.?) end = tgt;
                }
                break :blk try self.decompileLoopExitBranch(else_id, end, seed_else);
            }
            if (else_is_continuation) {
                if (else_is_fallthrough) break :blk &[_]*Stmt{};
                if (self.resolveJumpOnlyBlock(else_id) == loop_header) {
                    break :blk &[_]*Stmt{};
                }
                if (else_in_loop) {
                    break :blk try self.decompileLoopBody(
                        else_id,
                        loop_header,
                        &skip,
                        &seed_else,
                        visited,
                        scoped_else_stop,
                        0,
                        false,
                    );
                }
                const else_end = try self.branchEnd(else_id, null);
                break :blk try self.decompileBranchRange(else_id, else_end, &.{}, 0);
            }
            if (is_elif) {
                const else_pattern = try self.analyzer.detectPattern(else_id);
                if (else_pattern == .if_stmt) {
                    const elif_stmt = try self.decompileLoopIf(else_pattern.if_stmt, loop_header, visited);
                    if (elif_stmt) |s| {
                        visited.set(else_id);
                        const body = try a.alloc(*Stmt, 1);
                        body[0] = s;
                        break :blk body;
                    }
                }
            }
            break :blk try self.decompileLoopBody(
                else_id,
                loop_header,
                &skip,
                &seed_else,
                visited,
                scoped_else_stop,
                0,
                false,
            );
        } else &[_]*Stmt{};
        if (then_is_continue and then_body.len == 0) {
            const cont = try self.makeContinue();
            var extra: usize = 0;
            var cur = then_block;
            var next = cur + 1;
            while (next < self.cfg.blocks.len) : (next += 1) {
                const prev_blk = &self.cfg.blocks[cur];
                const next_blk = &self.cfg.blocks[next];
                if (next_blk.start_offset != prev_blk.end_offset) break;
                const target = self.jumpTargetIfJumpOnlyInst(next, true) orelse break;
                if (target != loop_header) break;
                try self.consumed.set(self.allocator, next);
                extra += 1;
                cur = next;
            }
            const body = try a.alloc(*Stmt, 1 + extra);
            body[0] = cont;
            for (0..extra) |i| {
                body[i + 1] = try self.makeContinue();
            }
            then_body = body;
        }
        if (self.loopBlockLeadsToBreak(then_block, loop_header)) {
            if (then_body.len == 0 or !self.bodyEndsLoopTerminal(then_body)) {
                const br = try self.makeBreak();
                const body = try a.alloc(*Stmt, then_body.len + 1);
                if (then_body.len > 0) {
                    std.mem.copyForwards(*Stmt, body[0..then_body.len], then_body);
                }
                body[then_body.len] = br;
                then_body = body;
            }
        }
        if (else_block != null and self.loopBlockLeadsToBreak(else_block.?, loop_header)) {
            if (else_body.len == 0 or !self.bodyEndsLoopTerminal(else_body)) {
                const br = try self.makeBreak();
                const body = try a.alloc(*Stmt, else_body.len + 1);
                if (else_body.len > 0) {
                    std.mem.copyForwards(*Stmt, body[0..else_body.len], else_body);
                }
                body[else_body.len] = br;
                else_body = body;
            }
        }
        const then_leads = then_res == loop_header or
            self.loopBlockLeadsToContinue(then_block, loop_header) or
            self.blockLeadsToHeader(then_block, loop_header);
        var else_leads = false;
        if (else_block) |else_id| {
            const else_res2 = self.resolveJumpOnlyBlock(else_id);
            else_leads = else_res2 == loop_header or
                self.loopBlockLeadsToContinue(else_id, loop_header) or
                self.blockLeadsToHeader(else_id, loop_header);
        }
        var then_reaches_else = false;
        if (else_block) |else_id| {
            then_reaches_else = try self.reachesBlockNoBack(then_block, else_id, pattern.condition_block);
        }
        if (!else_is_continuation and else_block != null and then_leads and !else_leads and !then_reaches_else) {
            else_is_continuation = true;
        }
        if (then_leads and else_block != null and else_is_continuation and !then_reaches_else) {
            const else_empty = else_body.len == 0 or self.bodyEndsLoopTerminal(else_body);
            if (else_empty and (then_body.len == 0 or !self.bodyEndsLoopTerminal(then_body))) {
                const cont = try self.makeContinue();
                const body = try a.alloc(*Stmt, then_body.len + 1);
                if (then_body.len > 0) {
                    std.mem.copyForwards(*Stmt, body[0..then_body.len], then_body);
                }
                body[then_body.len] = cont;
                then_body = body;
            }
        }
        if (else_leads and !then_leads and else_body.len > 0 and then_body.len == 0) {
            if (!self.bodyEndsLoopTerminal(else_body)) {
                const cont = try self.makeContinue();
                const body = try a.alloc(*Stmt, else_body.len + 1);
                std.mem.copyForwards(*Stmt, body[0..else_body.len], else_body);
                body[else_body.len] = cont;
                else_body = body;
            }
        }
        if (then_leads and else_leads and then_body.len > 0 and else_body.len > 0) {
            else_is_continuation = false;
        }
        if (else_is_continuation and then_body.len > 0 and else_body.len > 0) {
            else_is_continuation = false;
        }
        if (merge_block != null and merge_block != pattern.merge_block) {
            self.if_next = merge_block;
        }

        return .{
            .condition = condition,
            .then_body = then_body,
            .else_body = else_body,
            .else_is_continuation = else_is_continuation,
            .then_leads = then_leads,
            .else_leads = else_leads,
            .cond_op = cond_op,
            .then_block = then_block,
            .else_block = else_block,
        };
    }

    /// Decompile an if statement that's inside a loop.
    fn decompileLoopIf(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        loop_header: u32,
        visited: *std.DynamicBitSet,
    ) DecompileError!?*Stmt {
        const parts = try self.loopIfParts(pattern, loop_header, visited, null) orelse return null;
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .{ .if_stmt = .{
            .condition = parts.condition,
            .body = parts.then_body,
            .else_body = parts.else_body,
        } };

        return stmt;
    }

    fn tryNeedsBreak(self: *Decompiler, pattern: *const ctrl.TryPattern, loop_header: u32) bool {
        if (pattern.try_block >= self.cfg.blocks.len) return false;
        const try_block = &self.cfg.blocks[pattern.try_block];
        var normal_target: ?u32 = null;
        for (try_block.successors) |edge| {
            if (edge.edge_type == .normal) {
                normal_target = edge.target;
                break;
            }
        }
        if (normal_target) |target_id| {
            const exit = self.analyzer.detectLoopExit(target_id, &[_]u32{loop_header});
            if (exit != .break_stmt) return false;
            if (self.jumpTargetIfJumpOnlyEdge(target_id, true, true) != null) return false;
        } else {
            return false;
        }
        for (pattern.handlers) |handler| {
            if (handler.handler_block >= self.cfg.blocks.len) continue;
            if (self.analyzer.inLoop(handler.handler_block, loop_header)) return true;
        }
        return false;
    }

    fn appendTryBreak(self: *Decompiler, stmt: *Stmt) DecompileError!void {
        if (stmt.* != .try_stmt) return;
        const else_body = stmt.try_stmt.else_body;
        if (else_body.len > 0) {
            switch (else_body[else_body.len - 1].*) {
                .break_stmt, .return_stmt, .raise_stmt, .continue_stmt => return,
                else => {},
            }
        }
        const a = self.arena.allocator();
        const br = try self.makeBreak();
        const new_body = try a.alloc(*Stmt, else_body.len + 1);
        if (else_body.len > 0) {
            std.mem.copyForwards(*Stmt, new_body[0..else_body.len], else_body);
        }
        new_body[else_body.len] = br;
        stmt.try_stmt.else_body = new_body;

        if (stmt.try_stmt.handlers.len > 0) {
            const handlers = stmt.try_stmt.handlers;
            var replaced = false;
            const next_handlers = try a.alloc(ast.ExceptHandler, handlers.len);
            for (handlers, 0..) |h, idx| {
                next_handlers[idx] = h;
                if (h.body.len == 0) {
                    const cont = try self.makeContinue();
                    const body = try a.alloc(*Stmt, 1);
                    body[0] = cont;
                    next_handlers[idx].body = body;
                    replaced = true;
                }
            }
            if (replaced) {
                stmt.try_stmt.handlers = next_handlers;
            }
        }
    }

    fn nextLoopBlockAfterIf(
        self: *Decompiler,
        pattern: ctrl.IfPattern,
        loop_header: u32,
        cur_block: u32,
        stop_block: ?u32,
    ) DecompileError!?u32 {
        if (self.if_next) |next| {
            self.if_next = null;
            self.chained_cmp_next_block = null;
            if (stop_block) |stop_id| {
                if (next == stop_id) return null;
            }
            if (next == loop_header) return null;
            if (!self.analyzer.inLoop(next, loop_header)) return null;
            if (next <= cur_block) return null;
            return next;
        }
        if (pattern.merge_block) |merge_id| {
            if (stop_block) |stop_id| {
                if (merge_id == stop_id) return null;
            }
            if (merge_id == loop_header) return null;
            if (!self.analyzer.inLoop(merge_id, loop_header)) return null;
            return merge_id;
        }

        var next_id = try self.findIfChainEnd(pattern);
        if (self.chained_cmp_next_block) |chain_next| {
            next_id = chain_next;
            self.chained_cmp_next_block = null;
        }
        if (stop_block) |stop_id| {
            if (next_id == stop_id) return null;
        }
        if (next_id == loop_header) return null;
        if (!self.analyzer.inLoop(next_id, loop_header)) return null;
        if (next_id <= cur_block) return null;
        return next_id;
    }

    /// Decompile a body within a loop using loop-region membership.
    fn decompileLoopBody(
        self: *Decompiler,
        start_block: u32,
        loop_header: u32,
        skip_first_store: *bool,
        seed_pop: *bool,
        visited: *std.DynamicBitSet,
        stop_block: ?u32,
        skip_first: usize,
        ignore_header_while: bool,
    ) DecompileError![]const *Stmt {
        const a = self.arena.allocator();
        var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
        errdefer stmts.deinit(a);

        var block_idx = start_block;
        var loop_end_offset: ?u32 = null;
        var loop_end_block: ?u32 = null;
        const start_offset: u32 = if (start_block < self.cfg.blocks.len)
            self.cfg.blocks[start_block].start_offset
        else
            0;
        const stop_offset: ?u32 = if (stop_block) |stop_id| blk: {
            if (stop_id < self.cfg.blocks.len) break :blk self.cfg.blocks[stop_id].start_offset;
            break :blk null;
        } else null;
        if (loop_header < self.cfg.blocks.len) {
            const header = &self.cfg.blocks[loop_header];
            for (header.successors) |edge| {
                if (edge.edge_type == .conditional_false and edge.target < self.cfg.blocks.len) {
                    if (!self.analyzer.inLoop(edge.target, loop_header)) {
                        const end_off = self.cfg.blocks[edge.target].start_offset;
                        if (end_off > start_offset) {
                            loop_end_offset = end_off;
                            loop_end_block = edge.target;
                            break;
                        }
                    }
                }
            }
        }
        const loop_limit = loop_end_block orelse @as(u32, @intCast(self.cfg.blocks.len));

        while (block_idx < self.cfg.blocks.len) {
            const block = &self.cfg.blocks[block_idx];
            if (stop_block) |stop_id| {
                if (block_idx == stop_id) break;
            }
            if (stop_offset) |stop_off| {
                if (stop_off > start_offset and block.start_offset >= stop_off) break;
            }
            if (loop_end_offset) |end_off| {
                if (block.start_offset >= end_off) break;
            }
            if (self.consumed.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            if (!self.analyzer.inLoop(block_idx, loop_header)) {
                block_idx += 1;
                continue;
            }
            if (block_idx == loop_header and block_idx != start_block) break;
            if (visited.isSet(block_idx)) {
                block_idx += 1;
                continue;
            }
            if (self.isForSetupInLoop(block_idx, loop_header)) {
                block_idx += 1;
                continue;
            }
            if (try self.shouldDeferForPrelude(block_idx, loop_limit)) {
                block_idx += 1;
                continue;
            }
            if (self.trace_blocks and self.trace_file != null) {
                const ev = BlockTrace{
                    .kind = "block_visit",
                    .phase = "loop_body",
                    .block = block_idx,
                    .start = start_block,
                    .end = loop_limit,
                };
                try self.writeTrace(ev);
            }
            visited.set(block_idx);

            if (self.trace_blocks and self.trace_file != null) {
                const ev = BlockTrace{
                    .kind = "block_step",
                    .phase = "loop_boolop",
                    .block = block_idx,
                    .start = start_block,
                    .end = loop_limit,
                };
                try self.writeTrace(ev);
            }
            if (try self.tryDecompileBoolOpIntoWithSkip(block_idx, loop_limit, &stmts, a, skip_first_store.*)) |next_block| {
                skip_first_store.* = false;
                block_idx = next_block;
                continue;
            }
            if (self.trace_blocks and self.trace_file != null) {
                const ev = BlockTrace{
                    .kind = "block_step",
                    .phase = "loop_ternary",
                    .block = block_idx,
                    .start = start_block,
                    .end = loop_limit,
                };
                try self.writeTrace(ev);
            }
            if (try self.tryDecompileTernaryIntoWithSkip(block_idx, loop_limit, &stmts, a, skip_first_store.*)) |next_block| {
                skip_first_store.* = false;
                block_idx = next_block;
                continue;
            }

            const has_back_edge = self.hasLoopBackEdge(block, loop_header);
            if (self.trace_blocks and self.trace_file != null) {
                const ev = BlockTrace{
                    .kind = "block_step",
                    .phase = "loop_pattern",
                    .block = block_idx,
                    .start = start_block,
                    .end = loop_limit,
                };
                try self.writeTrace(ev);
            }
            var pattern = try self.analyzer.detectPatternInLoop(block_idx);
            if (block_idx == start_block and pattern == .while_loop and pattern.while_loop.header_block == loop_header) {
                if (skip_first > 0 or ignore_header_while) {
                    pattern = .unknown;
                }
            }
            if (pattern == .unknown and !block.is_exception_handler and self.analyzer.hasExceptionEdge(block)) {
                if (try self.analyzer.detectTryPatternAt(block_idx)) |tp| {
                    pattern = .{ .try_stmt = tp };
                }
            }

            switch (pattern) {
                .if_stmt => |p| {
                    try self.processPartialBlock(block, &stmts, a, skip_first_store, null);

                    const parts = try self.loopIfParts(p, loop_header, visited, stop_block) orelse {
                        block_idx += 1;
                        continue;
                    };
                    const else_is_assert = if (parts.else_block) |else_id|
                        self.isAssertRaiseBlock(else_id)
                    else
                        false;
                    const then_is_assert = self.isAssertRaiseBlock(parts.then_block);
                    if (else_is_assert != then_is_assert) {
                        if (else_is_assert) {
                            const else_id = parts.else_block.?;
                            if (try self.tryDecompileAssertBlock(parts.condition, else_id, 0)) |stmt| {
                                try stmts.append(a, stmt);
                                if (parts.then_body.len > 0) {
                                    try stmts.appendSlice(a, parts.then_body);
                                }
                                if (try self.nextLoopBlockAfterIf(p, loop_header, block_idx, stop_block)) |next_id| {
                                    block_idx = next_id;
                                    continue;
                                }
                                break;
                            }
                        } else {
                            const inv = try self.invertConditionExpr(parts.condition);
                            if (try self.tryDecompileAssertBlock(inv, parts.then_block, 0)) |stmt| {
                                try stmts.append(a, stmt);
                                if (parts.else_body.len > 0) {
                                    try stmts.appendSlice(a, parts.else_body);
                                }
                                if (try self.nextLoopBlockAfterIf(p, loop_header, block_idx, stop_block)) |next_id| {
                                    block_idx = next_id;
                                    continue;
                                }
                                break;
                            }
                        }
                    }
                    if (parts.then_body.len > 0 and parts.else_body.len > 0) {
                        const last_then = parts.then_body[parts.then_body.len - 1];
                        if (last_then.* == .continue_stmt) {
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = parts.condition,
                                .body = parts.then_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, if_stmt);
                            try stmts.appendSlice(a, parts.else_body);
                            if (try self.nextLoopBlockAfterIf(p, loop_header, block_idx, stop_block)) |next_id| {
                                block_idx = next_id;
                                continue;
                            }
                            break;
                        }
                    }

                    const else_cont = if (parts.else_is_continuation and parts.else_block != null) blk: {
                        const else_id = parts.else_block.?;
                        if (self.resolveJumpOnlyBlock(else_id) == loop_header or
                            self.loopBlockLeadsToContinue(else_id, loop_header) or
                            self.blockLeadsToHeader(else_id, loop_header))
                        {
                            break :blk true;
                        }
                        break :blk false;
                    } else false;
                    const then_guard = parts.then_leads and parts.else_block != null and !parts.else_leads;
                    var consumed_else = false;
                    if (parts.else_block) |else_id| {
                        if (parts.else_body.len > 0 and self.blockLeadsToHeader(else_id, loop_header)) {
                            if (try self.reachesBlockNoBack(parts.then_block, else_id, p.condition_block)) {
                                const if_stmt = try a.create(Stmt);
                                if_stmt.* = .{ .if_stmt = .{
                                    .condition = parts.condition,
                                    .body = parts.then_body,
                                    .else_body = &.{},
                                } };
                                try stmts.append(a, if_stmt);
                                try stmts.appendSlice(a, parts.else_body);
                                consumed_else = true;
                            }
                        }
                    }
                    if (consumed_else) {
                        // else body already appended as tail merge
                    } else if (then_guard) {
                        const if_stmt = try a.create(Stmt);
                        if_stmt.* = .{ .if_stmt = .{
                            .condition = parts.condition,
                            .body = parts.then_body,
                            .else_body = &.{},
                        } };
                        try stmts.append(a, if_stmt);
                        if (parts.else_body.len > 0) {
                            try stmts.appendSlice(a, parts.else_body);
                        }
                        consumed_else = true;
                    } else if (else_cont) {
                        const else_is_jump_target = self.elseIsJumpTarget(parts.cond_op);
                        var emitted_then_if = false;
                        const prefer_if = parts.condition.* == .bool_op;
                        if (self.bodyAllContinue(parts.then_body) and parts.else_body.len > 0 and self.isTrueJump(parts.cond_op)) {
                            const inv = try self.invertConditionExpr(parts.condition);
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = inv,
                                .body = parts.else_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, if_stmt);
                            consumed_else = true;
                        } else if (self.bodyEndsTerminal(parts.then_body) and parts.else_body.len > 0) {
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = parts.condition,
                                .body = parts.then_body,
                                .else_body = &.{},
                            } };
                            try stmts.append(a, if_stmt);
                            try stmts.appendSlice(a, parts.else_body);
                            consumed_else = true;
                        } else if (parts.then_leads and parts.else_leads and parts.then_body.len > 0 and parts.else_body.len > 0) {
                            const if_stmt = try a.create(Stmt);
                            if_stmt.* = .{ .if_stmt = .{
                                .condition = parts.condition,
                                .body = parts.then_body,
                                .else_body = parts.else_body,
                            } };
                            try stmts.append(a, if_stmt);
                            consumed_else = true;
                        } else {
                            if ((else_is_jump_target and parts.else_body.len == 0 and parts.then_body.len > 0) or
                                (prefer_if and !else_is_jump_target and parts.else_body.len == 0 and parts.then_body.len > 0 and !self.bodyEndsTerminal(parts.then_body)))
                            {
                                const if_stmt = try a.create(Stmt);
                                if_stmt.* = .{ .if_stmt = .{
                                    .condition = parts.condition,
                                    .body = parts.then_body,
                                    .else_body = &.{},
                                } };
                                try stmts.append(a, if_stmt);
                                emitted_then_if = true;
                            } else {
                                const guard_cond = try self.guardCondForBranch(parts.condition, parts.cond_op, else_is_jump_target);
                                var guard_body = parts.else_body;
                                var needs_continue = true;
                                if (guard_body.len > 0) {
                                    const last = guard_body[guard_body.len - 1];
                                    if (last.* == .continue_stmt or self.stmtIsTerminal(last)) {
                                        needs_continue = false;
                                    }
                                }
                                if (needs_continue) {
                                    const cont = try self.makeContinue();
                                    const next_body = try a.alloc(*Stmt, guard_body.len + 1);
                                    if (guard_body.len > 0) {
                                        std.mem.copyForwards(*Stmt, next_body[0..guard_body.len], guard_body);
                                    }
                                    next_body[guard_body.len] = cont;
                                    guard_body = next_body;
                                }
                                const guard_stmt = try a.create(Stmt);
                                guard_stmt.* = .{ .if_stmt = .{
                                    .condition = guard_cond,
                                    .body = guard_body,
                                    .else_body = &.{},
                                } };
                                try stmts.append(a, guard_stmt);
                            }
                            if (!emitted_then_if and parts.then_body.len > 0) {
                                try stmts.appendSlice(a, parts.then_body);
                            }
                            consumed_else = true;
                        }
                    } else {
                        const if_stmt = try a.create(Stmt);
                        if_stmt.* = .{ .if_stmt = .{
                            .condition = parts.condition,
                            .body = parts.then_body,
                            .else_body = parts.else_body,
                        } };
                        try stmts.append(a, if_stmt);
                    }

                    if (parts.else_is_continuation and !consumed_else) {
                        if (parts.else_block) |else_id| {
                            const else_res = self.resolveJumpOnlyBlock(else_id);
                            if (else_res != loop_header and else_id > block_idx) {
                                if (stop_block) |stop_id| {
                                    if (else_id == stop_id) break;
                                }
                                block_idx = else_id;
                                continue;
                            }
                        }
                    }

                    if (try self.nextLoopBlockAfterIf(p, loop_header, block_idx, stop_block)) |next_id| {
                        block_idx = next_id;
                        continue;
                    }
                    block_idx += 1;
                    continue;
                },
                .try_stmt => |p| {
                    if (try self.tryDecompileAsyncFor(p)) |result| {
                        if (result.stmt) |s| {
                            try stmts.append(a, s);
                        }
                        block_idx = result.next_block;
                        continue;
                    }
                    const result = try self.decompileTryWithLoop(p, loop_header, visited);
                    const leave_loop = self.tryNeedsBreak(&p, loop_header);
                    if (result.stmt) |s| {
                        if (leave_loop) {
                            try self.appendTryBreak(s);
                        }
                        try stmts.append(a, s);
                    }
                    if (leave_loop) break;
                    block_idx = result.next_block;
                    continue;
                },
                .while_loop => |p| {
                    const stmt = try self.decompileWhile(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    self.markLoopVisited(p.header_block, visited);
                    if (self.loop_next) |next| {
                        block_idx = next;
                        self.loop_next = null;
                    } else {
                        block_idx = p.exit_block;
                    }
                    continue;
                },
                .for_loop => |p| {
                    if (try self.tryDecompileInlineListComp(p)) |result| {
                        self.deinitStackValues(result.stack);
                        block_idx = result.exit_block;
                        continue;
                    }
                    if (p.setup_block < self.cfg.blocks.len and
                        (visited.isSet(p.setup_block) or self.consumed.isSet(p.setup_block)))
                    {
                        // Prelude already emitted when setup block was processed.
                    } else {
                        try self.emitForPrelude(p, &stmts, a);
                    }
                    const stmt = try self.decompileFor(p);
                    if (stmt) |s| {
                        try stmts.append(a, s);
                    }
                    self.markLoopVisited(p.header_block, visited);
                    block_idx = p.exit_block;
                    continue;
                },
                .with_stmt => |p| {
                    const result = try self.decompileWith(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                    continue;
                },
                .match_stmt => |p| {
                    try self.emitMatchPrelude(p.subject_block, &stmts, a);
                    const result = try self.decompileMatch(p);
                    if (result.stmt) |s| {
                        try stmts.append(a, s);
                    }
                    block_idx = result.next_block;
                    continue;
                },
                else => {
                    if (self.trace_blocks and self.trace_file != null) {
                        const ev = BlockTrace{
                            .kind = "block_step",
                            .phase = "loop_stmt",
                            .block = block_idx,
                            .start = start_block,
                            .end = loop_limit,
                        };
                        try self.writeTrace(ev);
                    }
                    // Process statements, stopping at back edge
                    const skip_body = if (block_idx == start_block) skip_first else 0;
                    try self.processBlockStatements(
                        block_idx,
                        block,
                        &stmts,
                        skip_first_store,
                        seed_pop,
                        has_back_edge,
                        loop_header,
                        skip_body,
                    );
                    try self.consumed.set(self.allocator, block_idx);
                    if (has_back_edge) break;

                    // Move to next block
                    if (block.successors.len == 0) break;

                    // Find the non-loop-back successor
                    var next_block: ?u32 = null;
                    for (block.successors) |edge| {
                        if (edge.edge_type != .loop_back) {
                            next_block = edge.target;
                            break;
                        }
                    }
                    if (next_block) |next_id| {
                        if (stop_block) |stop_id| {
                            if (next_id == stop_id) break;
                        }
                        if (next_id == loop_header) break;
                        block_idx = next_id;
                        continue;
                    }
                    break;
                },
            }
        }

        return stmts.toOwnedSlice(a);
    }

    fn deinitExprSlice(self: *Decompiler, items: []const *Expr) void {
        _ = self;
        _ = items;
    }

    fn deinitStmtSlice(self: *Decompiler, items: []const *Stmt) void {
        _ = self;
        _ = items;
    }

    fn trimTrailingReturnNone(self: *Decompiler, items: []const *Stmt) DecompileError![]const *Stmt {
        if (items.len == 0) return items;

        var end = items.len;
        while (end > 0 and Decompiler.isReturnNone(items[end - 1])) {
            end -= 1;
        }

        if (end == items.len) return items;
        if (end == 0) return &.{};

        const a = self.arena.allocator();
        const trimmed = try a.alloc(*Stmt, end);
        @memcpy(trimmed, items[0..end]);
        return trimmed;
    }

    fn trimExceptionCleanup(self: *Decompiler, items: []const *Stmt, handler_name: ?[]const u8) DecompileError![]const *Stmt {
        if (items.len < 2) return items;
        var last_term: ?usize = null;
        var i: usize = 0;
        while (i < items.len) : (i += 1) {
            if (self.stmtIsTerminal(items[i])) last_term = i;
        }
        if (last_term) |tid| {
            if (tid >= 2) {
                if (self.cleanupPairName(items[tid - 2 .. tid])) |name| {
                    if (handler_name == null or std.mem.eql(u8, name, handler_name.?)) {
                        const a = self.arena.allocator();
                        const out = try a.alloc(*Stmt, items.len - 2);
                        if (tid > 2) {
                            std.mem.copyForwards(*Stmt, out[0 .. tid - 2], items[0 .. tid - 2]);
                        }
                        std.mem.copyForwards(*Stmt, out[tid - 2 ..], items[tid..]);
                        return out;
                    }
                }
            }
            var j = tid + 1;
            while (j < items.len) {
                if (Decompiler.isReturnNone(items[j])) {
                    j += 1;
                    continue;
                }
                if (j + 1 < items.len) {
                    if (self.cleanupPairName(items[j .. j + 2])) |_| {
                        j += 2;
                        continue;
                    }
                }
                break;
            }
            if (j == items.len) {
                return items[0 .. tid + 1];
            }
        }
        var end = items.len;
        while (end >= 2) {
            const del_stmt = items[end - 1];
            const assign_stmt = items[end - 2];
            if (del_stmt.* != .delete) break;
            if (assign_stmt.* != .assign) break;
            if (del_stmt.delete.targets.len != 1) break;
            if (assign_stmt.assign.targets.len != 1) break;
            const del_target = del_stmt.delete.targets[0];
            const assign_target = assign_stmt.assign.targets[0];
            if (del_target.* != .name or assign_target.* != .name) break;
            if (!std.mem.eql(u8, del_target.name.id, assign_target.name.id)) break;
            const val = assign_stmt.assign.value;
            if (val.* != .constant or val.constant != .none) break;
            end -= 2;
        }
        return items[0..end];
    }

    fn stripDuplicateCleanupPairs(self: *Decompiler, items: []const *Stmt) DecompileError![]const *Stmt {
        if (items.len < 4) return items;
        const a = self.arena.allocator();
        var out = try a.alloc(*Stmt, items.len);
        var out_len: usize = 0;
        var i: usize = 0;
        var changed = false;
        while (i < items.len) {
            if (i + 1 < items.len) {
                if (self.cleanupPairName(items[i .. i + 2])) |name| {
                    if (out_len >= 2) {
                        if (self.cleanupPairName(out[out_len - 2 .. out_len])) |prev| {
                            if (std.mem.eql(u8, prev, name)) {
                                changed = true;
                                i += 2;
                                continue;
                            }
                        }
                    }
                }
            }
            out[out_len] = items[i];
            out_len += 1;
            i += 1;
        }
        if (!changed) return items;
        return out[0..out_len];
    }

    fn rewriteAwaitReturn(self: *Decompiler, items: []const *Stmt) DecompileError![]const *Stmt {
        if (items.len < 2) return items;
        const ret_idx = items.len - 1;
        const ret_stmt = items[ret_idx];
        if (ret_stmt.* != .return_stmt) return items;
        const ret_val = ret_stmt.return_stmt.value orelse return items;
        if (!self.isPlaceholderExpr(ret_val)) return items;

        var scan = ret_idx;
        while (scan >= 2) {
            if (self.cleanupPairName(items[scan - 2 .. scan])) |_| {
                scan -= 2;
                continue;
            }
            break;
        }
        if (scan == 0) return items;
        const await_idx = scan - 1;
        const await_stmt = items[await_idx];
        if (await_stmt.* != .expr_stmt) return items;
        const await_expr = await_stmt.expr_stmt.value;
        if (await_expr.* != .await_expr) return items;

        ret_stmt.return_stmt.value = await_expr;
        const a = self.arena.allocator();
        const out_len = await_idx + 1;
        const out = try a.alloc(*Stmt, out_len);
        if (await_idx > 0) {
            std.mem.copyForwards(*Stmt, out[0..await_idx], items[0..await_idx]);
        }
        out[await_idx] = ret_stmt;
        return out;
    }

    fn recoverExprFromBlock(self: *Decompiler, block_id: u32) DecompileError!?*Expr {
        if (block_id >= self.cfg.blocks.len) return null;
        const block = &self.cfg.blocks[block_id];
        var sim = self.initSim(self.arena.allocator(), self.arena.allocator(), self.code, self.version);
        defer sim.deinit();
        sim.lenient = true;
        sim.stack.allow_underflow = true;
        for (block.instructions) |inst| {
            try sim.simulate(inst);
        }
        if (sim.stack.peek() == null) return null;
        const expr = sim.stack.popExpr() catch |err| {
            if (self.isSoftSimErr(err)) return error.PatternNoMatch;
            return err;
        };
        if (self.isPlaceholderExpr(expr)) return null;
        return expr;
    }

    fn recoverHandlerReturnExpr(self: *Decompiler, start: u32, end: u32) DecompileError!?*Expr {
        const limit = @min(end, @as(u32, @intCast(self.cfg.blocks.len)));
        var bid = start;
        while (bid < limit) : (bid += 1) {
            const blk = &self.cfg.blocks[bid];
            var has_pop_except = false;
            var has_return = false;
            for (blk.instructions) |inst| {
                if (inst.opcode == .POP_EXCEPT) has_pop_except = true;
                if (inst.opcode == .RETURN_VALUE or inst.opcode == .RETURN_CONST) has_return = true;
            }
            if (!has_pop_except or !has_return) continue;
            for (blk.predecessors) |pred_id| {
                if (pred_id >= self.cfg.blocks.len) continue;
                const pred = &self.cfg.blocks[pred_id];
                if (pred.instructions.len == 0) continue;
                const last = pred.instructions[pred.instructions.len - 1];
                if (last.opcode != .POP_BLOCK) continue;
                const expr = self.recoverExprFromBlock(pred_id) catch |err| switch (err) {
                    error.PatternNoMatch => null,
                    else => return err,
                };
                if (expr) |e| return e;
            }
        }
        return null;
    }

    fn replaceFirstPlaceholderReturn(self: *Decompiler, stmts: []const *Stmt, value: *Expr) bool {
        for (stmts) |stmt| {
            switch (stmt.*) {
                .return_stmt => {
                    if (stmt.return_stmt.value) |ret_val| {
                        if (self.isPlaceholderExpr(ret_val)) {
                            stmt.return_stmt.value = value;
                            return true;
                        }
                    }
                },
                .if_stmt => |ifs| {
                    if (self.replaceFirstPlaceholderReturn(ifs.body, value)) return true;
                    if (self.replaceFirstPlaceholderReturn(ifs.else_body, value)) return true;
                },
                .for_stmt => |fs| {
                    if (self.replaceFirstPlaceholderReturn(fs.body, value)) return true;
                    if (self.replaceFirstPlaceholderReturn(fs.else_body, value)) return true;
                },
                .while_stmt => |ws| {
                    if (self.replaceFirstPlaceholderReturn(ws.body, value)) return true;
                    if (self.replaceFirstPlaceholderReturn(ws.else_body, value)) return true;
                },
                .with_stmt => |ws| {
                    if (self.replaceFirstPlaceholderReturn(ws.body, value)) return true;
                },
                .match_stmt => |ms| {
                    for (ms.cases) |case| {
                        if (self.replaceFirstPlaceholderReturn(case.body, value)) return true;
                    }
                },
                .try_stmt => |ts| {
                    if (self.replaceFirstPlaceholderReturn(ts.body, value)) return true;
                    for (ts.handlers) |handler| {
                        if (self.replaceFirstPlaceholderReturn(handler.body, value)) return true;
                    }
                    if (self.replaceFirstPlaceholderReturn(ts.else_body, value)) return true;
                    if (self.replaceFirstPlaceholderReturn(ts.finalbody, value)) return true;
                },
                .function_def, .class_def => {},
                else => {},
            }
        }
        return false;
    }

    fn rewriteHandlerReturnExpr(self: *Decompiler, body: []const *Stmt, start: u32, end: u32) DecompileError![]const *Stmt {
        const expr = try self.recoverHandlerReturnExpr(start, end) orelse return body;
        _ = self.replaceFirstPlaceholderReturn(body, expr);
        return body;
    }

    fn stripNestedExceptionCleanup(self: *Decompiler, body: []const *Stmt, handler_name: ?[]const u8) DecompileError![]const *Stmt {
        if (handler_name == null) return body;
        var changed = false;
        var out = body;
        for (out) |stmt| {
            switch (stmt.*) {
                .if_stmt => |*ifs| {
                    const new_then = try self.stripNestedExceptionCleanup(ifs.body, handler_name);
                    if (new_then.ptr != ifs.body.ptr or new_then.len != ifs.body.len) {
                        ifs.body = new_then;
                        changed = true;
                    }
                    const new_else = try self.stripNestedExceptionCleanup(ifs.else_body, handler_name);
                    if (new_else.ptr != ifs.else_body.ptr or new_else.len != ifs.else_body.len) {
                        ifs.else_body = new_else;
                        changed = true;
                    }
                },
                .for_stmt => |*fs| {
                    const new_body = try self.stripNestedExceptionCleanup(fs.body, handler_name);
                    if (new_body.ptr != fs.body.ptr or new_body.len != fs.body.len) {
                        fs.body = new_body;
                        changed = true;
                    }
                    const new_else = try self.stripNestedExceptionCleanup(fs.else_body, handler_name);
                    if (new_else.ptr != fs.else_body.ptr or new_else.len != fs.else_body.len) {
                        fs.else_body = new_else;
                        changed = true;
                    }
                },
                .while_stmt => |*ws| {
                    const new_body = try self.stripNestedExceptionCleanup(ws.body, handler_name);
                    if (new_body.ptr != ws.body.ptr or new_body.len != ws.body.len) {
                        ws.body = new_body;
                        changed = true;
                    }
                    const new_else = try self.stripNestedExceptionCleanup(ws.else_body, handler_name);
                    if (new_else.ptr != ws.else_body.ptr or new_else.len != ws.else_body.len) {
                        ws.else_body = new_else;
                        changed = true;
                    }
                },
                .with_stmt => |*ws| {
                    const new_body = try self.stripNestedExceptionCleanup(ws.body, handler_name);
                    if (new_body.ptr != ws.body.ptr or new_body.len != ws.body.len) {
                        ws.body = new_body;
                        changed = true;
                    }
                },
                .match_stmt => {},
                .try_stmt => |*ts| {
                    const new_body = try self.stripNestedExceptionCleanup(ts.body, handler_name);
                    if (new_body.ptr != ts.body.ptr or new_body.len != ts.body.len) {
                        ts.body = new_body;
                        changed = true;
                    }
                    // Skip nested handler bodies (const slice)
                    const new_else = try self.stripNestedExceptionCleanup(ts.else_body, handler_name);
                    if (new_else.ptr != ts.else_body.ptr or new_else.len != ts.else_body.len) {
                        ts.else_body = new_else;
                        changed = true;
                    }
                    const new_final = try self.stripNestedExceptionCleanup(ts.finalbody, handler_name);
                    if (new_final.ptr != ts.finalbody.ptr or new_final.len != ts.finalbody.len) {
                        ts.finalbody = new_final;
                        changed = true;
                    }
                },
                .function_def, .class_def => {},
                else => {},
            }
        }
        const trimmed = try self.trimExceptionCleanup(out, handler_name);
        if (trimmed.ptr != out.ptr or trimmed.len != out.len) {
            out = trimmed;
            changed = true;
        }
        if (!changed) return body;
        const a = self.arena.allocator();
        const next = try a.alloc(*Stmt, out.len);
        std.mem.copyForwards(*Stmt, next[0..out.len], out);
        return next;
    }

    fn moveReturnNoneIntoElse(self: *Decompiler, body: []const *Stmt) DecompileError![]const *Stmt {
        if (body.len < 2) return body;
        const last = body[body.len - 1];
        if (!Decompiler.isReturnNone(last)) return body;
        const prev = body[body.len - 2];
        if (prev.* != .if_stmt) return body;
        var ifs = &prev.if_stmt;
        if (!self.bodyEndsTerminal(ifs.body)) return body;
        if (self.bodyEndsTerminal(ifs.else_body)) return body;
        const a = self.arena.allocator();
        const new_else = try a.alloc(*Stmt, ifs.else_body.len + 1);
        if (ifs.else_body.len > 0) {
            std.mem.copyForwards(*Stmt, new_else[0..ifs.else_body.len], ifs.else_body);
        }
        new_else[ifs.else_body.len] = last;
        ifs.else_body = new_else;
        const out = try a.alloc(*Stmt, body.len - 1);
        std.mem.copyForwards(*Stmt, out[0 .. body.len - 1], body[0 .. body.len - 1]);
        return out;
    }

    fn cleanupPairName(self: *Decompiler, items: []const *Stmt) ?[]const u8 {
        _ = self;
        if (items.len != 2) return null;
        const assign_stmt = items[0];
        const del_stmt = items[1];
        if (assign_stmt.* != .assign or del_stmt.* != .delete) return null;
        if (assign_stmt.assign.targets.len != 1 or del_stmt.delete.targets.len != 1) return null;
        const assign_target = assign_stmt.assign.targets[0];
        const del_target = del_stmt.delete.targets[0];
        if (assign_target.* != .name or del_target.* != .name) return null;
        if (!std.mem.eql(u8, assign_target.name.id, del_target.name.id)) return null;
        const val = assign_stmt.assign.value;
        if (val.* != .constant or val.constant != .none) return null;
        return assign_target.name.id;
    }

    fn rewriteHandlerExplicitContinue(
        self: *Decompiler,
        body: []const *Stmt,
    ) DecompileError!?[]const *Stmt {
        if (body.len == 0) return null;
        var drop_first = false;
        var if_idx: usize = 0;
        if (body[0].* == .expr_stmt) {
            const v = body[0].expr_stmt.value;
            if (v.* == .name) {
                drop_first = true;
                if_idx = 1;
            }
        }
        if (if_idx >= body.len) return null;
        const if_stmt = body[if_idx];
        if (if_stmt.* != .if_stmt) return null;
        const ifs = if_stmt.if_stmt;
        const body_is_pass = ifs.body.len == 0 or (ifs.body.len == 1 and ifs.body[0].* == .pass);
        if (!body_is_pass) return null;
        var else_body = ifs.else_body;
        if (else_body.len == 0 and if_idx + 1 < body.len) {
            const next = body[if_idx + 1];
            if (next.* == .raise_stmt) {
                else_body = body[if_idx + 1 .. if_idx + 2];
            }
        }
        if (else_body.len != 1 or else_body[0].* != .raise_stmt) return null;

        const a = self.arena.allocator();
        const cont = try self.makeContinue();
        const new_if_body = try a.alloc(*Stmt, 1);
        new_if_body[0] = cont;
        const new_if = try a.create(Stmt);
        new_if.* = .{ .if_stmt = .{
            .condition = ifs.condition,
            .body = new_if_body,
            .else_body = else_body,
        } };

        const prefix_len: usize = if (drop_first) if_idx - 1 else if_idx;
        const out_len = prefix_len + 1;
        var out = try a.alloc(*Stmt, out_len);
        if (prefix_len > 0) {
            const start: usize = if (drop_first) 1 else 0;
            std.mem.copyForwards(*Stmt, out[0..prefix_len], body[start .. start + prefix_len]);
        }
        out[prefix_len] = new_if;
        return out;
    }

    fn rewriteHandlerContinueTail(
        self: *Decompiler,
        body: []const *Stmt,
    ) DecompileError!?[]const *Stmt {
        if (body.len < 2) return null;
        if (body[body.len - 1].* != .continue_stmt) return null;
        var drop_first = false;
        var if_idx: usize = 0;
        if (body[0].* == .expr_stmt) {
            const v = body[0].expr_stmt.value;
            if (v.* == .name) {
                drop_first = true;
                if_idx = 1;
            }
        }
        if (if_idx >= body.len - 1) return null;
        const if_stmt = body[if_idx];
        if (if_stmt.* != .if_stmt) return null;
        const ifs = if_stmt.if_stmt;
        const body_is_pass = ifs.body.len == 0 or (ifs.body.len == 1 and ifs.body[0].* == .pass);
        if (!body_is_pass) return null;
        var else_body = ifs.else_body;
        if (else_body.len == 0 and if_idx + 1 < body.len - 1) {
            const next = body[if_idx + 1];
            if (next.* == .raise_stmt) {
                else_body = body[if_idx + 1 .. if_idx + 2];
            }
        }
        if (else_body.len != 1 or else_body[0].* != .raise_stmt) return null;

        const a = self.arena.allocator();
        const cont = try self.makeContinue();
        const new_if_body = try a.alloc(*Stmt, 1);
        new_if_body[0] = cont;
        const new_if = try a.create(Stmt);
        new_if.* = .{ .if_stmt = .{
            .condition = ifs.condition,
            .body = new_if_body,
            .else_body = else_body,
        } };

        const prefix_len: usize = if (drop_first) if_idx - 1 else if_idx;
        const out_len = prefix_len + 1;
        var out = try a.alloc(*Stmt, out_len);
        if (prefix_len > 0) {
            const start: usize = if (drop_first) 1 else 0;
            std.mem.copyForwards(*Stmt, out[0..prefix_len], body[start .. start + prefix_len]);
        }
        out[prefix_len] = new_if;
        return out;
    }

    fn rewriteHandlerContinueCleanup(
        self: *Decompiler,
        body: []const *Stmt,
        exc_name: []const u8,
    ) DecompileError![]const *Stmt {
        if (body.len != 4) return body;
        if (body[0].* != .if_stmt) return body;
        if (body[3].* != .raise_stmt) return body;
        const ifs = body[0].if_stmt;
        if (ifs.else_body.len != 1 or ifs.else_body[0].* != .raise_stmt) return body;
        if (self.cleanupPairName(ifs.body)) |name| {
            if (!std.mem.eql(u8, name, exc_name)) return body;
        } else return body;
        if (self.cleanupPairName(body[1..3])) |name| {
            if (!std.mem.eql(u8, name, exc_name)) return body;
        } else return body;

        const a = self.arena.allocator();
        const cont = try self.makeContinue();
        const if_body = try a.alloc(*Stmt, 1);
        if_body[0] = cont;
        const if_stmt = try a.create(Stmt);
        if_stmt.* = .{ .if_stmt = .{
            .condition = ifs.condition,
            .body = if_body,
            .else_body = &.{},
        } };
        const out = try a.alloc(*Stmt, 2);
        out[0] = if_stmt;
        out[1] = body[3];
        return out;
    }

    fn takeDecorators(self: *Decompiler, decorators: *std.ArrayListUnmanaged(*Expr)) DecompileError![]const *Expr {
        if (decorators.items.len == 0) return &.{};
        const count = decorators.items.len;
        const a = self.arena.allocator();
        const out = try a.alloc(*Expr, count);
        var i: usize = 0;
        while (i < count) : (i += 1) {
            out[i] = decorators.items[count - 1 - i];
        }
        decorators.clearRetainingCapacity();
        return out;
    }

    fn unmangleClassName(self: *Decompiler, name: []const u8) DecompileError![]const u8 {
        return name_mangle.unmangleClassName(self.arena.allocator(), self.class_name, name);
    }

    fn makeName(self: *Decompiler, name: []const u8, ctx: ExprContext) DecompileError!*Expr {
        const unmangled = try self.unmangleClassName(name);
        return ast.makeName(self.arena.allocator(), unmangled, ctx);
    }

    fn makeRawName(self: *Decompiler, name: []const u8, ctx: ExprContext) DecompileError!*Expr {
        return ast.makeName(self.arena.allocator(), name, ctx);
    }

    fn makeAttribute(self: *Decompiler, value: *Expr, attr: []const u8, ctx: ExprContext) DecompileError!*Expr {
        const unmangled = try self.unmangleClassName(attr);
        return ast.makeAttribute(self.arena.allocator(), value, unmangled, ctx);
    }

    pub fn initSim(self: *Decompiler, allocator: Allocator, stack_alloc: Allocator, code: *const pyc.Code, version: Version) SimContext {
        var sim = SimContext.init(allocator, stack_alloc, code, version);
        sim.class_name = self.class_name;
        return sim;
    }

    fn childOptions(self: *const Decompiler) DecompileOptions {
        return .{
            .trace_loop_guards = self.trace_loop_guards,
            .trace_decisions = self.trace_decisions,
            .trace_stackflow = self.trace_stackflow,
            .trace_blocks = self.trace_blocks,
            .trace_file = self.trace_file,
        };
    }

    fn decompileNestedBody(self: *Decompiler, code: *const pyc.Code) DecompileError![]const *Stmt {
        return self.decompileNestedBodyWithClass(code, self.class_name);
    }

    fn decompileNestedBodyWithClass(self: *Decompiler, code: *const pyc.Code, class_name: ?[]const u8) DecompileError![]const *Stmt {
        const nested_ptr = try self.allocator.create(Decompiler);
        errdefer self.allocator.destroy(nested_ptr);

        nested_ptr.* = try Decompiler.initWithOptions(self.allocator, code, self.version, self.childOptions());
        errdefer nested_ptr.deinit();
        nested_ptr.class_name = class_name;
        nested_ptr.clone_sim.class_name = class_name;

        _ = nested_ptr.decompile() catch |err| {
            if (nested_ptr.last_error_ctx) |ctx| {
                self.last_error_ctx = ctx;
            }
            return err;
        };

        // Only track after successful decompile - errdefer handles failure cleanup
        try self.nested_decompilers.append(self.allocator, nested_ptr);
        const a = self.arena.allocator();
        const body = try a.dupe(*Stmt, nested_ptr.statements.items);
        return body;
    }

    fn makeFunctionDef(self: *Decompiler, name: []const u8, func: *stack_mod.FunctionValue) DecompileError!*Stmt {
        var cleanup_func = true;
        errdefer if (cleanup_func) func.deinit(self.allocator);

        const a = self.arena.allocator();

        var body = try self.decompileNestedBody(func.code);
        body = try self.trimTrailingReturnNone(body);

        // Generate global/nonlocal declarations
        var decls: std.ArrayListUnmanaged(*Stmt) = .{};
        defer decls.deinit(a);

        // Nonlocal: only freevars that are assigned in this scope
        var nonlocals: std.StringHashMapUnmanaged(void) = .{};
        defer nonlocals.deinit(a);
        if (func.code.freevars.len > 0) {
            var it_nonlocal = decoder.InstructionIterator.init(func.code.code, self.version);
            while (it_nonlocal.next()) |inst| {
                if (inst.opcode == .STORE_DEREF or inst.opcode == .DELETE_DEREF) {
                    if (inst.arg < func.code.cellvars.len) continue;
                    const free_idx: usize = @as(usize, inst.arg) - func.code.cellvars.len;
                    if (free_idx < func.code.freevars.len) {
                        try nonlocals.put(a, func.code.freevars[free_idx], {});
                    }
                }
            }
        }
        if (nonlocals.count() > 0) {
            const names = try a.alloc([]const u8, nonlocals.count());
            var it = nonlocals.keyIterator();
            var i: usize = 0;
            while (it.next()) |key| : (i += 1) {
                names[i] = try self.unmangleClassName(key.*);
            }
            const nl_stmt = try a.create(Stmt);
            nl_stmt.* = .{ .nonlocal_stmt = .{ .names = names } };
            try decls.append(a, nl_stmt);
        }

        // Global: scan bytecode for STORE_GLOBAL
        var globals: std.StringHashMapUnmanaged(void) = .{};
        defer globals.deinit(a);
        var iter = decoder.InstructionIterator.init(func.code.code, self.version);
        while (iter.next()) |inst| {
            if (inst.opcode == .STORE_GLOBAL) {
                if (inst.arg < func.code.names.len) {
                    try globals.put(a, func.code.names[inst.arg], {});
                }
            }
        }
        if (globals.count() > 0) {
            const names = try a.alloc([]const u8, globals.count());
            var it = globals.keyIterator();
            var i: usize = 0;
            while (it.next()) |key| : (i += 1) {
                names[i] = try self.unmangleClassName(key.*);
            }
            const g_stmt = try a.create(Stmt);
            g_stmt.* = .{ .global_stmt = .{ .names = names } };
            try decls.append(a, g_stmt);
        }

        // Prepend declarations to body
        if (decls.items.len > 0) {
            const new_body = try a.alloc(*Stmt, body.len + decls.items.len);
            @memcpy(new_body[0..decls.items.len], decls.items);
            @memcpy(new_body[decls.items.len..], body);
            body = new_body;
        }

        // Extract docstring from consts[0] if it's a string AND is a valid docstring
        // Python 3.12+: docstring is in co_consts[0] but NOT loaded by bytecode
        // Older Python: docstring pattern is LOAD_CONST 0, POP_TOP
        if (func.code.consts.len > 0) {
            const first_const = &func.code.consts[0];
            if (first_const.* == .string) {
                var is_docstring = false;
                var has_load_const_0 = false;

                var it = decoder.InstructionIterator.init(func.code.code, self.version);
                var prev_op: ?Opcode = null;
                var prev_arg: u32 = 0;
                while (it.next()) |inst| {
                    if (inst.opcode == .LOAD_CONST and inst.arg == 0) {
                        has_load_const_0 = true;
                        // Check for old-style docstring: LOAD_CONST 0, POP_TOP
                        prev_op = inst.opcode;
                        prev_arg = inst.arg;
                        continue;
                    }
                    if (prev_op == .LOAD_CONST and prev_arg == 0 and inst.opcode == .POP_TOP) {
                        // Old-style docstring pattern
                        is_docstring = true;
                        break;
                    }
                    prev_op = inst.opcode;
                    prev_arg = inst.arg;
                }

                // Python 3.12+: if consts[0] is string but never loaded, it's the docstring
                if (!has_load_const_0 and self.version.gte(3, 11)) {
                    is_docstring = true;
                }

                if (is_docstring) {
                    const docstring = first_const.string;
                    const doc_const = ast.Constant{ .string = docstring };
                    const doc_expr = try ast.makeConstant(a, doc_const);
                    const doc_stmt = try a.create(ast.Stmt);
                    doc_stmt.* = .{ .expr_stmt = .{ .value = doc_expr } };

                    // Prepend docstring to body
                    const new_body = try a.alloc(*ast.Stmt, body.len + 1);
                    new_body[0] = doc_stmt;
                    @memcpy(new_body[1..], body);
                    body = new_body;
                }
            }
        }

        const args = try signature.extractFunctionSignature(a, func.code, self.class_name, func.defaults, func.kw_defaults, func.annotations);

        // Find return annotation
        var returns: ?*Expr = null;
        for (func.annotations) |ann| {
            if (std.mem.eql(u8, ann.name, "return")) {
                returns = ann.value;
                break;
            }
        }

        const decorator_list = try self.takeDecorators(&func.decorators);

        cleanup_func = false;

        const name_copy = try a.dupe(u8, name);

        const stmt = try a.create(Stmt);

        stmt.* = .{ .function_def = .{
            .name = name_copy,
            .type_params = &.{},
            .args = args,
            .body = body,
            .decorator_list = decorator_list,
            .returns = returns,
            .type_comment = null,
            .is_async = codegen.isCoroutine(func.code) or codegen.isAsyncGenerator(func.code),
        } };

        return stmt;
    }

    fn makeClassDef(self: *Decompiler, name: []const u8, cls: *stack_mod.ClassValue) DecompileError!*Stmt {
        var cleanup_cls = true;
        errdefer if (cleanup_cls) cls.deinit(self.allocator);

        const a = self.arena.allocator();

        const class_name_for_body = if (cls.name.len > 0) cls.name else name;
        var body = try self.decompileNestedBodyWithClass(cls.code, class_name_for_body);
        body = try self.trimTrailingReturnNone(body);

        // Python 2.x classes: trim trailing "return locals()"
        if (body.len > 0 and Decompiler.isReturnLocals(body[body.len - 1])) {
            body = body[0 .. body.len - 1];
        }

        body = self.trimClassPrelude(body, class_name_for_body);

        if (body.len > 0 and body[0].* == .assign) {
            const assign = body[0].assign;
            if (assign.targets.len == 1) {
                const target = assign.targets[0];
                if (target.* == .name and std.mem.eql(u8, target.name.id, "__doc__") and
                    assign.value.* == .constant and assign.value.constant == .string)
                {
                    const doc_const = ast.Constant{ .string = assign.value.constant.string };
                    const doc_expr = try ast.makeConstant(a, doc_const);
                    const doc_stmt = try a.create(ast.Stmt);
                    doc_stmt.* = .{ .expr_stmt = .{ .value = doc_expr } };

                    const new_body = try a.alloc(*ast.Stmt, body.len);
                    new_body[0] = doc_stmt;
                    if (body.len > 1) {
                        @memcpy(new_body[1..], body[1..]);
                    }
                    body = new_body;
                }
            }
        }

        const decorator_list = try self.takeDecorators(&cls.decorators);

        const bases = cls.bases;
        const keywords = cls.keywords;
        cls.bases = &.{};
        cls.keywords = &.{};

        var class_name = name;
        if (cls.name.len > 0) {
            class_name = cls.name;
            cls.name = &.{};
        } else {
            class_name = try a.dupe(u8, name);
        }

        cleanup_cls = false;

        const stmt = try a.create(Stmt);
        stmt.* = .{ .class_def = .{
            .name = class_name,
            .type_params = &.{},
            .bases = bases,
            .keywords = keywords,
            .body = body,
            .decorator_list = decorator_list,
        } };

        return stmt;
    }

    fn handleStoreValue(self: *Decompiler, sim: *SimContext, name: []const u8, value: stack_mod.StackValue) DecompileError!?*Stmt {
        const a = self.arena.allocator();
        const out_name = try self.unmangleClassName(name);
        if (self.isModuleLevel() and std.mem.eql(u8, out_name, "__doc__") and self.statements.items.len == 0) {
            if (value == .expr and value.expr.* == .constant and value.expr.constant == .string) {
                return try self.makeExprStmt(value.expr);
            }
        }
        if (value == .expr and value.expr.* == .bin_op and sim.isInplaceExpr(value.expr)) {
            const binop = &value.expr.bin_op;
            if (binop.left.* == .name and std.mem.eql(u8, binop.left.name.id, out_name)) {
                binop.left.deinit(a);
                a.destroy(binop.left);
                const stmt = try a.create(Stmt);
                const target = try self.makeName(out_name, .store);
                stmt.* = .{ .aug_assign = .{
                    .target = target,
                    .op = binop.op,
                    .value = binop.right,
                } };
                a.destroy(value.expr);
                return stmt;
            }
        }
        return switch (value) {
            .expr => |expr| blk: {
                const target = try self.makeName(out_name, .store);
                break :blk try self.makeAssign(target, expr);
            },
            .function_obj => |func| try self.makeFunctionDef(out_name, func),
            .class_obj => |cls| try self.makeClassDef(out_name, cls),
            .import_module => |imp| try self.makeImport(out_name, imp),
            .type_alias => |ta| blk: {
                // ta is a tuple (name_expr, value_expr)
                if (ta.* == .tuple and ta.tuple.elts.len >= 2) {
                    const name_expr = ta.tuple.elts[0];
                    const value_expr = ta.tuple.elts[1];
                    const stmt = try a.create(Stmt);
                    stmt.* = .{ .type_alias = .{
                        .name = name_expr,
                        .type_params = &.{},
                        .value = value_expr,
                    } };
                    break :blk stmt;
                }
                // Fallback
                const placeholder = try ast.makeConstant(a, .ellipsis);
                const target = try self.makeName(out_name, .store);
                break :blk try self.makeAssign(target, placeholder);
            },
            .saved_local => null,
            .code_obj, .comp_obj, .comp_builder, .null_marker, .exc_marker, .unknown => blk: {
                // Fallback for unhandled stack values - emit a valid placeholder
                const placeholder = try ast.makeConstant(a, .ellipsis);
                const target = try self.makeName(out_name, .store);
                break :blk try self.makeAssign(target, placeholder);
            },
        };
    }

    fn tryRecoverFunctionDefFromMakeFunction(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        inst_idx: usize,
        name: []const u8,
    ) DecompileError!?*Stmt {
        if (inst_idx == 0 or inst_idx > instructions.len) return null;
        const make_inst = instructions[inst_idx - 1];
        if (make_inst.opcode != .MAKE_FUNCTION) return null;

        const flags: u32 = make_inst.arg;
        if ((flags & ~@as(u32, 0x01)) != 0) return null;
        if (inst_idx < 3) return null;
        const qual_inst = instructions[inst_idx - 2];
        const code_inst = instructions[inst_idx - 3];
        if (qual_inst.opcode != .LOAD_CONST or code_inst.opcode != .LOAD_CONST) return null;
        const code_obj = sim.getConst(code_inst.arg) orelse return null;
        const code = switch (code_obj) {
            .code, .code_ref => |c| c,
            else => return null,
        };

        var defaults: []const *Expr = &.{};
        if ((flags & 0x01) != 0) {
            if (inst_idx < 4) return null;
            const def_inst = instructions[inst_idx - 4];
            if (def_inst.opcode != .LOAD_CONST) return null;
            if (sim.getConst(def_inst.arg)) |def_obj| {
                const def_expr = try sim.objToExpr(def_obj);
                if (def_expr.* == .tuple) {
                    defaults = def_expr.tuple.elts;
                } else {
                    def_expr.deinit(sim.allocator);
                    sim.allocator.destroy(def_expr);
                }
            }
        }

        const func = try self.allocator.create(stack_mod.FunctionValue);
        func.* = .{
            .code = code,
            .decorators = .{},
            .defaults = defaults,
            .kw_defaults = &.{},
            .annotations = &.{},
        };

        return try self.makeFunctionDef(name, func);
    }

    fn tryRecoverTypeAlias(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        inst_idx: usize,
        name: []const u8,
    ) DecompileError!?*Stmt {
        // Type alias pattern (Python 3.12+):
        // LOAD_CONST name        # n-6
        // LOAD_CONST type_params # n-5
        // LOAD_CONST defaults    # n-4
        // LOAD_CONST code_obj    # n-3
        // MAKE_FUNCTION          # n-2
        // SET_FUNCTION_ATTRIBUTE # n-1 (optional, depends on defaults)
        // BUILD_TUPLE 3          # inst_idx-2
        // CALL_INTRINSIC_1 11    # inst_idx-1
        // STORE_NAME             # inst_idx

        if (inst_idx < 2) return null;
        const intrinsic = instructions[inst_idx - 1];
        if (intrinsic.opcode != .CALL_INTRINSIC_1 or intrinsic.arg != 11) return null;

        const build_tuple = instructions[inst_idx - 2];
        if (build_tuple.opcode != .BUILD_TUPLE or build_tuple.arg != 3) return null;

        // Search backwards for MAKE_FUNCTION and LOAD_CONST instructions
        var make_func_idx: ?usize = null;
        const min_idx = if (inst_idx > 10) inst_idx - 10 else 0;
        var search_idx: usize = inst_idx -| 3;
        while (search_idx > min_idx) : (search_idx -= 1) {
            const inst = instructions[search_idx];
            if (inst.opcode == .MAKE_FUNCTION) {
                make_func_idx = search_idx;
                break;
            }
        }
        if (make_func_idx == null) return null;
        const mf_idx = make_func_idx.?;

        // Code object is loaded before MAKE_FUNCTION
        if (mf_idx < 1) return null;
        const code_load = instructions[mf_idx - 1];
        if (code_load.opcode != .LOAD_CONST) return null;

        const code_obj = sim.getConst(code_load.arg) orelse return null;
        const code = switch (code_obj) {
            .code, .code_ref => |c| c,
            else => return null,
        };

        // Parse the code object to get the type expression
        // The code returns the type value when called
        const type_value = try sim.parseTypeAliasCode(code);

        const a = self.arena.allocator();
        const name_expr = try self.makeName(name, .store);
        const stmt = try a.create(Stmt);
        stmt.* = .{ .type_alias = .{
            .name = name_expr,
            .type_params = &.{},
            .value = type_value,
        } };
        return stmt;
    }

    /// Recover generic type aliases (PEP 695) like `type Matrix[T] = list[list[T]]`
    /// Pattern: MAKE_FUNCTION (code=<generic parameters of X>), PUSH_NULL, CALL 0, STORE_NAME
    fn tryRecoverGenericTypeAlias(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        inst_idx: usize,
        name: []const u8,
    ) DecompileError!?*Stmt {
        // Check for CALL 0 before STORE_NAME
        if (inst_idx < 2) return null;
        const call = instructions[inst_idx - 1];
        if (call.opcode != .CALL or call.arg != 0) return null;

        // Check for PUSH_NULL before CALL
        const push_null = instructions[inst_idx - 2];
        if (push_null.opcode != .PUSH_NULL) return null;

        // Search backwards for MAKE_FUNCTION
        var mf_idx: ?usize = null;
        const min_idx = if (inst_idx > 6) inst_idx - 6 else 0;
        var search_idx: usize = inst_idx -| 3;
        while (search_idx > min_idx) : (search_idx -= 1) {
            if (instructions[search_idx].opcode == .MAKE_FUNCTION) {
                mf_idx = search_idx;
                break;
            }
        }
        const make_func_idx = mf_idx orelse return null;

        // Get the code object before MAKE_FUNCTION
        if (make_func_idx < 1) return null;
        const code_load = instructions[make_func_idx - 1];
        if (code_load.opcode != .LOAD_CONST) return null;

        const code_obj = sim.getConst(code_load.arg) orelse return null;
        const outer_code = switch (code_obj) {
            .code, .code_ref => |c| c,
            else => return null,
        };

        // Check if this is a generic parameters code object
        const prefix = "<generic parameters of ";
        if (!std.mem.startsWith(u8, outer_code.name, prefix)) return null;

        // Parse the outer code to find:
        // 1. Type parameters (from CALL_INTRINSIC_1 7 = INTRINSIC_TYPEVAR)
        // 2. The inner type alias code object (from CALL_INTRINSIC_1 11 = INTRINSIC_TYPEALIAS)
        const result = try sim.parseGenericTypeAliasCode(outer_code);
        if (result.value == null) return null;

        const a = self.arena.allocator();
        const name_expr = try self.makeName(name, .store);
        const stmt = try a.create(Stmt);
        stmt.* = .{ .type_alias = .{
            .name = name_expr,
            .type_params = result.type_params,
            .value = result.value.?,
        } };
        return stmt;
    }

    /// Recover generic functions (PEP 695) like `def identity[T](x: T) -> T: ...`
    /// Pattern: MAKE_FUNCTION (code=<generic parameters of X>), PUSH_NULL, CALL 0, STORE_NAME
    fn tryRecoverGenericFunction(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        inst_idx: usize,
        name: []const u8,
    ) DecompileError!?*Stmt {
        // Check for CALL 0 before STORE_NAME
        if (inst_idx < 2) return null;
        const call = instructions[inst_idx - 1];
        if (call.opcode != .CALL or call.arg != 0) return null;

        // Check for PUSH_NULL before CALL
        const push_null = instructions[inst_idx - 2];
        if (push_null.opcode != .PUSH_NULL) return null;

        // Search backwards for MAKE_FUNCTION
        var mf_idx: ?usize = null;
        const min_idx = if (inst_idx > 6) inst_idx - 6 else 0;
        var search_idx: usize = inst_idx -| 3;
        while (search_idx > min_idx) : (search_idx -= 1) {
            if (instructions[search_idx].opcode == .MAKE_FUNCTION) {
                mf_idx = search_idx;
                break;
            }
        }
        const make_func_idx = mf_idx orelse return null;

        // Get the code object before MAKE_FUNCTION
        if (make_func_idx < 1) return null;
        const code_load = instructions[make_func_idx - 1];
        if (code_load.opcode != .LOAD_CONST) return null;

        const code_obj = sim.getConst(code_load.arg) orelse return null;
        const outer_code = switch (code_obj) {
            .code, .code_ref => |c| c,
            else => return null,
        };

        // Check if this is a generic parameters code object
        const prefix = "<generic parameters of ";
        if (!std.mem.startsWith(u8, outer_code.name, prefix)) return null;

        // Parse the outer code to find type parameters and function/class code
        const result = try sim.parseGenericFunctionCode(outer_code);
        if (result.func_code == null) return null;

        const func_code = result.func_code.?;

        const a = self.arena.allocator();

        // Parse annotations from __annotate__ code if present
        var annotations: []const signature.Annotation = &.{};
        if (result.annotate_code) |ann_code| {
            annotations = try sim.parseAnnotateCode(ann_code);
        }

        // Create the function_def directly with type_params
        const returns = result.return_annotation;
        const args = try signature.extractFunctionSignature(a, func_code, self.class_name, &.{}, &.{}, annotations);
        var body = try self.decompileNestedBody(func_code);

        // Extract docstring (same logic as makeFunctionDef)
        if (func_code.consts.len > 0) {
            const first_const = &func_code.consts[0];
            if (first_const.* == .string) {
                var is_docstring = false;
                var has_load_const_0 = false;

                var it = decoder.InstructionIterator.init(func_code.code, self.version);
                while (it.next()) |inst| {
                    if (inst.opcode == .LOAD_CONST and inst.arg == 0) {
                        has_load_const_0 = true;
                        break;
                    }
                }

                // Python 3.11+: if consts[0] is string but never loaded, it's the docstring
                if (!has_load_const_0 and self.version.gte(3, 11)) {
                    is_docstring = true;
                }

                if (is_docstring) {
                    const docstring = first_const.string;
                    const doc_const = ast.Constant{ .string = docstring };
                    const doc_expr = try ast.makeConstant(a, doc_const);
                    const doc_stmt = try a.create(ast.Stmt);
                    doc_stmt.* = .{ .expr_stmt = .{ .value = doc_expr } };

                    // Prepend docstring to body
                    const new_body = try a.alloc(*ast.Stmt, body.len + 1);
                    new_body[0] = doc_stmt;
                    @memcpy(new_body[1..], body);
                    body = new_body;
                }
            }
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{ .function_def = .{
            .name = try a.dupe(u8, name),
            .type_params = result.type_params,
            .args = args,
            .body = body,
            .decorator_list = &.{},
            .returns = returns,
            .type_comment = null,
            .is_async = codegen.isCoroutine(func_code) or codegen.isAsyncGenerator(func_code),
        } };
        return stmt;
    }

    /// Recover generic classes (PEP 695) like `class Box[T]: ...`
    /// Pattern: MAKE_FUNCTION (code=<generic parameters of X>), PUSH_NULL, CALL 0, STORE_NAME
    fn tryRecoverGenericClass(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        inst_idx: usize,
        name: []const u8,
    ) DecompileError!?*Stmt {
        // Check for CALL 0 before STORE_NAME
        if (inst_idx < 2) return null;
        const call = instructions[inst_idx - 1];
        if (call.opcode != .CALL or call.arg != 0) return null;

        // Check for PUSH_NULL before CALL
        const push_null = instructions[inst_idx - 2];
        if (push_null.opcode != .PUSH_NULL) return null;

        // Search backwards for MAKE_FUNCTION
        var mf_idx: ?usize = null;
        const min_idx = if (inst_idx > 6) inst_idx - 6 else 0;
        var search_idx: usize = inst_idx -| 3;
        while (search_idx > min_idx) : (search_idx -= 1) {
            if (instructions[search_idx].opcode == .MAKE_FUNCTION) {
                mf_idx = search_idx;
                break;
            }
        }
        const make_func_idx = mf_idx orelse return null;

        // Get the code object before MAKE_FUNCTION
        if (make_func_idx < 1) return null;
        const code_load = instructions[make_func_idx - 1];
        if (code_load.opcode != .LOAD_CONST) return null;

        const code_obj = sim.getConst(code_load.arg) orelse return null;
        const outer_code = switch (code_obj) {
            .code, .code_ref => |c| c,
            else => return null,
        };

        // Check if this is a generic parameters code object
        const prefix = "<generic parameters of ";
        if (!std.mem.startsWith(u8, outer_code.name, prefix)) return null;

        // Parse the outer code to find type parameters and class code
        const result = try sim.parseGenericClassCode(outer_code);
        if (result.class_code == null) return null;

        const class_code = result.class_code.?;
        const a = self.arena.allocator();

        // Decompile the class body
        var body = try self.decompileNestedBodyWithClass(class_code, name);
        body = try self.trimTrailingReturnNone(body);
        body = self.trimClassPrelude(body, name);

        // Convert __doc__ = "..." to proper docstring (same logic as makeClassDef)
        if (body.len > 0 and body[0].* == .assign) {
            const assign = body[0].assign;
            if (assign.targets.len == 1) {
                const target = assign.targets[0];
                if (target.* == .name and std.mem.eql(u8, target.name.id, "__doc__") and
                    assign.value.* == .constant and assign.value.constant == .string)
                {
                    const doc_const = ast.Constant{ .string = assign.value.constant.string };
                    const doc_expr = try ast.makeConstant(a, doc_const);
                    const doc_stmt = try a.create(ast.Stmt);
                    doc_stmt.* = .{ .expr_stmt = .{ .value = doc_expr } };

                    const new_body = try a.alloc(*ast.Stmt, body.len);
                    new_body[0] = doc_stmt;
                    if (body.len > 1) {
                        @memcpy(new_body[1..], body[1..]);
                    }
                    body = new_body;
                }
            }
        }

        const stmt = try a.create(Stmt);
        stmt.* = .{ .class_def = .{
            .name = try a.dupe(u8, name),
            .type_params = result.type_params,
            .bases = &.{},
            .keywords = &.{},
            .body = body,
            .decorator_list = &.{},
        } };
        return stmt;
    }

    fn tryDecompileImportFromGroup(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        start_idx: usize,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        stmts_allocator: Allocator,
    ) DecompileError!?usize {
        if (start_idx >= instructions.len) return null;
        const inst = instructions[start_idx];
        if (inst.opcode != .IMPORT_NAME) return null;

        const module_name = sim.getName(inst.arg) orelse return null;
        const stack_items = sim.stack.items.items;
        const fromlist_val = if (stack_items.len > 0) stack_items[stack_items.len - 1] else null;
        var level: u32 = 0;
        if (self.version.gte(2, 5) and stack_items.len >= 2) {
            const level_val = stack_items[stack_items.len - 2];
            if (level_val == .expr and level_val.expr.* == .constant) {
                if (level_val.expr.constant == .int and level_val.expr.constant.int >= 0) {
                    level = @intCast(level_val.expr.constant.int);
                }
            }
        }

        if (self.version.gte(2, 0)) {
            if (fromlist_val) |fv| {
                if (fv == .expr and fv.expr.* == .tuple) {
                    if (fv.expr.tuple.elts.len == 0) return null;
                } else {
                    return null;
                }
            } else {
                return null;
            }
        }

        var idx = start_idx + 1;
        var aliases: std.ArrayListUnmanaged(ast.Alias) = .{};
        defer aliases.deinit(self.allocator);

        if (idx < instructions.len and instructions[idx].opcode == .IMPORT_STAR) {
            const a = self.arena.allocator();
            const list = try a.alloc(ast.Alias, 1);
            list[0] = .{ .name = "*", .asname = null };
            const stmt = try a.create(Stmt);
            stmt.* = .{ .import_from = .{
                .module = if (module_name.len == 0) null else module_name,
                .names = list,
                .level = level,
            } };
            try stmts.append(stmts_allocator, stmt);

            var sim_idx: usize = start_idx;
            while (sim_idx <= idx) : (sim_idx += 1) {
                try sim.simulate(instructions[sim_idx]);
            }
            return idx;
        }

        while (idx + 1 < instructions.len) {
            const from_inst = instructions[idx];
            const store_inst = instructions[idx + 1];
            if (from_inst.opcode != .IMPORT_FROM) break;
            const attr_name = sim.getName(from_inst.arg) orelse break;
            const store_name: ?[]const u8 = switch (store_inst.opcode) {
                .STORE_NAME, .STORE_GLOBAL => sim.getName(store_inst.arg),
                .STORE_FAST => sim.getLocal(store_inst.arg),
                .STORE_DEREF => sim.getDeref(store_inst.arg),
                else => null,
            };
            if (store_name == null) break;
            const asname = if (std.mem.eql(u8, attr_name, store_name.?)) null else store_name.?;
            try aliases.append(self.allocator, .{ .name = attr_name, .asname = asname });
            idx += 2;
        }

        if (aliases.items.len == 0) return null;
        if (idx >= instructions.len or instructions[idx].opcode != .POP_TOP) return null;

        const a = self.arena.allocator();
        const alias_list = try a.alloc(ast.Alias, aliases.items.len);
        std.mem.copyForwards(ast.Alias, alias_list, aliases.items);
        const stmt = try a.create(Stmt);
        stmt.* = .{ .import_from = .{
            .module = if (module_name.len == 0) null else module_name,
            .names = alias_list,
            .level = level,
        } };
        try stmts.append(stmts_allocator, stmt);

        var sim_idx: usize = start_idx;
        while (sim_idx <= idx) : (sim_idx += 1) {
            try sim.simulate(instructions[sim_idx]);
        }

        return idx;
    }

    fn makeImport(self: *Decompiler, alias_name: []const u8, imp: stack_mod.ImportModule) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const stmt = try a.create(ast.Stmt);

        if (imp.fromlist.len == 0) {
            // import module or import module as alias
            const base = blk: {
                if (imp.module.len == 0) break :blk imp.module;
                if (std.mem.indexOfScalar(u8, imp.module, '.')) |dot| {
                    break :blk imp.module[0..dot];
                }
                break :blk imp.module;
            };
            const asname = if (std.mem.eql(u8, alias_name, base)) null else alias_name;
            const aliases = try a.alloc(ast.Alias, 1);
            aliases[0] = .{ .name = imp.module, .asname = asname };
            stmt.* = .{ .import_stmt = .{ .names = aliases } };
        } else {
            // from module import names
            const aliases = try a.alloc(ast.Alias, imp.fromlist.len);
            for (imp.fromlist, 0..) |from_name, i| {
                const asname = if (i == 0 and !std.mem.eql(u8, alias_name, from_name)) alias_name else null;
                aliases[i] = .{ .name = from_name, .asname = asname };
            }
            const module_name: ?[]const u8 = if (imp.module.len == 0) null else imp.module;
            stmt.* = .{ .import_from = .{
                .module = module_name,
                .names = aliases,
                .level = imp.level,
            } };
        }

        return stmt;
    }

    const SubscriptTargetResult = struct {
        target: *Expr,
        next_idx: usize,
    };

    /// Try to parse a subscript or attribute target from instruction stream.
    /// Pattern: LOAD container, (LOAD key | LOAD_CONST key), STORE_SUBSCR
    /// Or: LOAD container, STORE_ATTR
    fn tryParseSubscriptTarget(
        self: *Decompiler,
        sim: *SimContext,
        instructions: []const decoder.Instruction,
        start_idx: usize,
        arena: Allocator,
    ) DecompileError!?SubscriptTargetResult {
        if (start_idx >= instructions.len) return null;

        // Simulate loads to build container expression
        var idx = start_idx;
        const container_inst = instructions[idx];

        // Get container name
        const container_name: ?[]const u8 = switch (container_inst.opcode) {
            .LOAD_NAME, .LOAD_GLOBAL => sim.getName(container_inst.arg),
            .LOAD_FAST => sim.getLocal(container_inst.arg),
            .LOAD_DEREF => sim.getDeref(container_inst.arg),
            else => null,
        };
        if (container_name == null) return null;

        const container = try self.makeName(container_name.?, .load);
        idx += 1;

        if (idx >= instructions.len) return null;
        const next = instructions[idx];

        // Check for STORE_ATTR (container.attr)
        if (next.opcode == .STORE_ATTR) {
            const attr_name = sim.getName(next.arg) orelse return null;
            const target = try self.makeAttribute(container, attr_name, .store);
            return .{ .target = target, .next_idx = idx + 1 };
        }

        // Check for BUILD_SLICE pattern: LOAD start, LOAD stop, [LOAD step], BUILD_SLICE, STORE_SUBSCR
        // Or simple key: LOAD key, STORE_SUBSCR
        const key_or_start: ?*Expr = try parseLoadExpr(self, sim, arena, next);
        if (key_or_start == null) return null;
        idx += 1;

        if (idx >= instructions.len) return null;

        // Check if this is a simple subscript (STORE_SUBSCR immediately follows)
        if (instructions[idx].opcode == .STORE_SUBSCR) {
            const target = try arena.create(Expr);
            target.* = .{ .subscript = .{
                .value = container,
                .slice = key_or_start.?,
                .ctx = .store,
            } };
            return .{ .target = target, .next_idx = idx + 1 };
        }

        // Check for slice pattern: start is loaded, now check for stop [and step]
        // Pattern: LOAD stop, [LOAD step], BUILD_SLICE n, STORE_SUBSCR
        const stop_inst = instructions[idx];
        const stop: ?*Expr = try parseLoadExpr(self, sim, arena, stop_inst);
        if (stop == null) return null;
        idx += 1;

        if (idx >= instructions.len) return null;

        var step: ?*Expr = null;
        var slice_arg: u32 = 2; // Default: 2 args (start, stop)

        // Check for step or BUILD_SLICE
        const maybe_step_or_build = instructions[idx];
        if (maybe_step_or_build.opcode == .BUILD_SLICE) {
            slice_arg = maybe_step_or_build.arg;
            idx += 1;
        } else {
            // Try to parse step
            step = try parseLoadExpr(self, sim, arena, maybe_step_or_build);
            if (step != null) {
                idx += 1;
                if (idx >= instructions.len) return null;
                if (instructions[idx].opcode != .BUILD_SLICE) return null;
                slice_arg = instructions[idx].arg;
                idx += 1;
            } else {
                return null;
            }
        }

        if (idx >= instructions.len) return null;
        if (instructions[idx].opcode != .STORE_SUBSCR) return null;

        // Build slice expression
        const slice_expr = try arena.create(Expr);
        const lower = if (key_or_start.?.* == .constant and key_or_start.?.constant == .none) null else key_or_start;
        const upper = if (stop.?.* == .constant and stop.?.constant == .none) null else stop;
        const step_val = if (step) |s| (if (s.* == .constant and s.constant == .none) null else s) else null;
        slice_expr.* = .{ .slice = .{ .lower = lower, .upper = upper, .step = step_val } };

        const target = try arena.create(Expr);
        target.* = .{ .subscript = .{
            .value = container,
            .slice = slice_expr,
            .ctx = .store,
        } };
        return .{ .target = target, .next_idx = idx + 1 };
    }

    /// Helper to parse a LOAD instruction into an expression
    fn parseLoadExpr(self: *Decompiler, sim: *SimContext, arena: Allocator, inst: decoder.Instruction) DecompileError!?*Expr {
        return switch (inst.opcode) {
            .LOAD_NAME, .LOAD_GLOBAL => blk: {
                const name = sim.getName(inst.arg) orelse break :blk null;
                break :blk try self.makeName(name, .load);
            },
            .LOAD_FAST => blk: {
                const name = sim.getLocal(inst.arg) orelse break :blk null;
                break :blk try self.makeName(name, .load);
            },
            .LOAD_CONST => blk: {
                const c = sim.getConst(inst.arg) orelse break :blk null;
                break :blk try sim.objToExpr(c);
            },
            .LOAD_SMALL_INT => blk: {
                const val = @as(i64, @intCast(inst.arg));
                break :blk try ast.makeConstant(arena, .{ .int = val });
            },
            else => null,
        };
    }

    /// Create an assignment statement.
    fn makeAssign(self: *Decompiler, target: *Expr, value: *Expr) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const targets = try a.alloc(*Expr, 1);
        targets[0] = target;

        const stmt = try a.create(Stmt);
        stmt.* = .{ .assign = .{
            .targets = targets,
            .value = value,
            .type_comment = null,
        } };
        return stmt;
    }

    fn emitAssign(self: *Decompiler, sim: *SimContext, target: *Expr, value: *Expr) DecompileError!*Stmt {
        if (try self.tryMakeAugAssign(sim, target, value, false)) |stmt| return stmt;
        return try self.makeAssign(target, value);
    }

    /// Create a break statement.
    fn makeBreak(self: *Decompiler) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .break_stmt;
        return stmt;
    }

    /// Create a continue statement.
    fn makeContinue(self: *Decompiler) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .continue_stmt;
        return stmt;
    }

    /// Create a return statement.
    fn makeReturn(self: *Decompiler, value: *Expr) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .{ .return_stmt = .{
            .value = value,
        } };
        return stmt;
    }

    /// Create a print statement (Python 2.x).
    fn makePrintStmt(self: *Decompiler, dest: ?*Expr, nl: bool) DecompileError!*Stmt {
        const a = self.arena.allocator();
        const values = try a.alloc(*Expr, self.print_items.items.len);
        @memcpy(values, self.print_items.items);
        self.print_items.clearRetainingCapacity();

        const stmt = try a.create(Stmt);
        stmt.* = .{ .print_stmt = .{
            .values = values,
            .dest = dest,
            .nl = nl,
        } };
        return stmt;
    }

    fn isPrintBoundary(op: Opcode) bool {
        return switch (op) {
            .SET_LINENO,
            .STORE_NAME,
            .STORE_FAST,
            .STORE_GLOBAL,
            .STORE_DEREF,
            .STORE_ATTR,
            .STORE_SUBSCR,
            .STORE_SLICE,
            .STORE_SLICE_0,
            .STORE_SLICE_1,
            .STORE_SLICE_2,
            .STORE_SLICE_3,
            .DELETE_NAME,
            .DELETE_FAST,
            .DELETE_GLOBAL,
            .DELETE_DEREF,
            .DELETE_ATTR,
            .DELETE_SUBSCR,
            .DELETE_SLICE_0,
            .DELETE_SLICE_1,
            .DELETE_SLICE_2,
            .DELETE_SLICE_3,
            .UNPACK_SEQUENCE,
            .UNPACK_EX,
            .RETURN_VALUE,
            .RETURN_CONST,
            .RAISE_VARARGS,
            .POP_TOP,
            .EXEC_STMT,
            .POP_BLOCK,
            .BREAK_LOOP,
            .CONTINUE_LOOP,
            .JUMP_FORWARD,
            .JUMP_BACKWARD,
            .JUMP_BACKWARD_NO_INTERRUPT,
            .JUMP_ABSOLUTE,
            => true,
            else => false,
        };
    }

    fn hasLegacyCondPop(self: *const Decompiler, block_id: u32, block: *const BasicBlock) bool {
        _ = block_id;
        if (block.instructions.len == 0) return false;
        if (block.instructions[0].opcode != .POP_TOP) return false;
        for (block.predecessors) |pred_id| {
            if (pred_id >= self.cfg.blocks.len) continue;
            const pred = &self.cfg.blocks[pred_id];
            const term = pred.terminator() orelse continue;
            if (term.opcode == .JUMP_IF_FALSE or term.opcode == .JUMP_IF_TRUE) {
                return true;
            }
        }
        return false;
    }

    fn flushPendingPrint(
        self: *Decompiler,
        op: Opcode,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        alloc: Allocator,
    ) DecompileError!void {
        if (self.print_items.items.len == 0) return;
        switch (op) {
            .PRINT_ITEM, .PRINT_NEWLINE, .PRINT_ITEM_TO, .PRINT_NEWLINE_TO => return,
            else => {},
        }
        if (!isPrintBoundary(op)) return;
        const dest = self.print_dest;
        self.print_dest = null;
        const stmt = try self.makePrintStmt(dest, false);
        try stmts.append(alloc, stmt);
    }

    fn handlePrintOp(
        self: *Decompiler,
        sim: *SimContext,
        inst: decoder.Instruction,
        stmts: *std.ArrayListUnmanaged(*Stmt),
        alloc: Allocator,
    ) DecompileError!bool {
        switch (inst.opcode) {
            .PRINT_ITEM => {
                const val = try sim.stack.popExpr();
                try self.print_items.append(self.allocator, val);
                return true;
            },
            .PRINT_NEWLINE => {
                const stmt = try self.makePrintStmt(null, true);
                try stmts.append(alloc, stmt);
                return true;
            },
            .PRINT_ITEM_TO => {
                const file = try sim.stack.popExpr();
                const val = try sim.stack.popExpr();
                if (self.print_dest == null) {
                    self.print_dest = file;
                }
                try self.print_items.append(self.allocator, val);
                return true;
            },
            .PRINT_NEWLINE_TO => {
                const file = try sim.stack.popExpr();
                const dest = self.print_dest orelse file;
                self.print_dest = null;
                const stmt = try self.makePrintStmt(dest, true);
                try stmts.append(alloc, stmt);
                return true;
            },
            else => return false,
        }
    }

    /// Create an expression statement.
    fn makeExprStmt(self: *Decompiler, value: *Expr) DecompileError!*Stmt {
        // Suppress placeholders from appearing as statements
        if (value.* == .name) {
            if (std.mem.eql(u8, value.name.id, "__exception__") or std.mem.eql(u8, value.name.id, "__unknown__") or std.mem.eql(u8, value.name.id, "_")) {
                return error.SkipStatement;
            }
            // Skip Python 3.14+ internal names (PEP 649)
            if (self.version.gte(3, 14) and (std.mem.eql(u8, value.name.id, "__conditional_annotations__") or
                std.mem.eql(u8, value.name.id, "__annotate__")))
            {
                return error.SkipStatement;
            }
        }
        if (value.* == .call) {
            const func = value.call.func;
            if (func.* == .name) {
                if (std.mem.eql(u8, func.name.id, "__with_exit__")) {
                    return error.SkipStatement;
                }
                if (std.mem.eql(u8, func.name.id, "__unknown__")) {
                    const args = value.call.args;
                    if (args.len == 3) {
                        var all_none = true;
                        for (args) |arg| {
                            if (arg.* != .constant or arg.constant != .none) {
                                all_none = false;
                                break;
                            }
                        }
                        if (all_none) return error.SkipStatement;
                    }
                }
            }
        }
        if (value.* == .await_expr) {
            const inner = value.await_expr.value;
            if (inner.* == .call) {
                const func = inner.call.func;
                if (func.* == .name) {
                    if (std.mem.eql(u8, func.name.id, "__with_exit__")) {
                        return error.SkipStatement;
                    }
                    if (std.mem.eql(u8, func.name.id, "__unknown__")) {
                        const args = inner.call.args;
                        if (args.len == 3) {
                            var all_none = true;
                            for (args) |arg| {
                                if (arg.* != .constant or arg.constant != .none) {
                                    all_none = false;
                                    break;
                                }
                            }
                            if (all_none) return error.SkipStatement;
                        }
                    }
                }
            }
        }
        const a = self.arena.allocator();
        const stmt = try a.create(Stmt);
        stmt.* = .{ .expr_stmt = .{
            .value = value,
        } };
        return stmt;
    }

    fn isPlaceholderExpr(self: *Decompiler, value: *const Expr) bool {
        _ = self;
        if (value.* != .name) return false;
        return std.mem.eql(u8, value.name.id, "__exception__") or std.mem.eql(u8, value.name.id, "__unknown__");
    }

    fn isExcPlaceholderValue(self: *Decompiler, value: StackValue) bool {
        _ = self;
        return switch (value) {
            .expr => |expr| expr.* == .name and std.mem.eql(u8, expr.name.id, "__exception__"),
            .exc_marker => true,
            else => false,
        };
    }

    /// Create unpacking assignment: a, b, c = expr
    fn makeUnpackAssign(self: *Decompiler, names: []const []const u8, value: *Expr) DecompileError!*Stmt {
        const a = self.arena.allocator();

        // Create tuple of Name expressions for targets
        var target_exprs = try std.ArrayListUnmanaged(*Expr).initCapacity(a, names.len);
        for (names) |name| {
            const name_expr = try a.create(Expr);
            name_expr.* = .{ .name = .{ .id = name, .ctx = .store } };
            try target_exprs.append(a, name_expr);
        }

        const tuple_expr = try a.create(Expr);
        tuple_expr.* = .{ .tuple = .{
            .elts = try target_exprs.toOwnedSlice(a),
            .ctx = .store,
        } };

        const targets = try a.alloc(*Expr, 1);
        targets[0] = tuple_expr;

        const stmt = try a.create(Stmt);
        stmt.* = .{ .assign = .{
            .targets = targets,
            .value = value,
            .type_comment = null,
        } };
        return stmt;
    }

    /// Create unpacking assignment from expr targets: (self.a, b[0]) = expr
    fn makeUnpackAssignExprs(self: *Decompiler, target_exprs: []*Expr, value: *Expr) DecompileError!*Stmt {
        const a = self.arena.allocator();

        const tuple_expr = try a.create(Expr);
        tuple_expr.* = .{ .tuple = .{
            .elts = try a.dupe(*Expr, target_exprs),
            .ctx = .store,
        } };

        const targets = try a.alloc(*Expr, 1);
        targets[0] = tuple_expr;

        const stmt = try a.create(Stmt);
        stmt.* = .{ .assign = .{
            .targets = targets,
            .value = value,
            .type_comment = null,
        } };
        return stmt;
    }

    /// Check if a statement is `return None`.
    pub fn isReturnNone(stmt: *const Stmt) bool {
        if (stmt.* != .return_stmt) return false;
        const ret = stmt.return_stmt;
        if (ret.value) |val| {
            if (val.* == .constant) {
                return val.constant == .none;
            }
        }
        return false;
    }

    /// Check if a statement is `return locals()` (Python 2.x class body).
    fn isReturnLocals(stmt: *const Stmt) bool {
        if (stmt.* != .return_stmt) return false;
        const ret = stmt.return_stmt;
        if (ret.value) |val| {
            if (val.* == .call) {
                const call = val.call;
                if (call.func.* == .name and std.mem.eql(u8, call.func.name.id, "locals")) {
                    return call.args.len == 0;
                }
            }
        }
        return false;
    }

    fn isModuleName(name: []const u8) bool {
        return name.len == 0 or std.mem.eql(u8, name, "<module>") or std.mem.eql(u8, name, "?");
    }

    /// Check if this is module-level code.
    fn isModuleLevel(self: *const Decompiler) bool {
        return isModuleName(self.code.name);
    }

};

pub fn computeStackDepthsForTest(
    allocator: Allocator,
    code: *const pyc.Code,
    version: Version,
) DecompileError![]?usize {
    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    const count: usize = decompiler.cfg.blocks.len;
    const out = try allocator.alloc(?usize, count);
    for (decompiler.stack_in, 0..) |entry_opt, idx| {
        if (entry_opt) |entry| {
            out[idx] = entry.len;
        } else {
            out[idx] = null;
        }
    }
    return out;
}

/// Decompile a code object and write Python source to writer.
pub fn decompileToSource(allocator: Allocator, code: *const pyc.Code, version: Version, writer: anytype) !void {
    return decompileToSourceWithOptions(allocator, code, version, writer, null, .{});
}

/// Decompile with error context output.
pub fn decompileToSourceWithContext(
    allocator: Allocator,
    code: *const pyc.Code,
    version: Version,
    writer: anytype,
    err_writer: ?std.fs.File,
) !void {
    return decompileToSourceWithOptions(allocator, code, version, writer, err_writer, .{});
}

const FocusError = error{
    AmbiguousCodePath,
    CodePathNotFound,
    InvalidFocusPath,
};

pub fn decompileToSourceWithOptions(
    allocator: Allocator,
    code: *const pyc.Code,
    version: Version,
    writer: anytype,
    err_writer: ?std.fs.File,
    opts: DecompileOptions,
) !void {
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();
    const a = arena.allocator();

    var target = code;
    if (opts.focus) |path| {
        target = findCodeByPath(code, path) catch |err| {
            if (err_writer) |ew| {
                var buf: [256]u8 = undefined;
                const msg = switch (err) {
                    error.InvalidFocusPath => try std.fmt.bufPrint(&buf, "Invalid focus path: {s}\n", .{path}),
                    error.CodePathNotFound => try std.fmt.bufPrint(&buf, "Focus path not found: {s}\n", .{path}),
                    error.AmbiguousCodePath => try std.fmt.bufPrint(&buf, "Ambiguous focus path: {s}\n", .{path}),
                };
                _ = try ew.write(msg);
            }
            return err;
        };
    }
    var use_opts = opts;
    use_opts.focus = null;
    // Handle module-level code
    if (Decompiler.isModuleName(target.name)) {
        var pipe = DecompPipeline.init(a, target, version, use_opts, .module);
        defer pipe.deinit();
        try pipe.ensureRewrite(err_writer);
        const effective_stmts = pipe.stmts orelse &.{};

        if (effective_stmts.len == 0) return;

        var cg = codegen.Writer.init(a);
        defer cg.deinit(a);

        var seen_body = false;
        for (effective_stmts) |stmt| {
            const is_doc = Decompiler.isDocstringStmt(stmt);
            const is_future = Decompiler.isFutureImportStmt(stmt);
            if (!seen_body) {
                if (!is_doc and !is_future) seen_body = true;
            } else if (is_future) {
                continue;
            }
            try cg.writeStmt(a, stmt);
        }

        const output = try cg.getOutput(a);
        if (use_opts.align_defs) {
            const aligned = try alignDefLines(a, target, output);
            try writer.writeAll(aligned);
        } else {
            try writer.writeAll(output);
        }
        return;
    }
    try decompileFunctionToSource(a, target, version, writer, 0, use_opts);
}

/// Decompile a function and write to writer.
fn decompileFunctionToSource(
    allocator: Allocator,
    code: *const pyc.Code,
    version: Version,
    writer: anytype,
    indent: u32,
    opts: DecompileOptions,
) !void {
    // Write indent
    var i: u32 = 0;
    while (i < indent) : (i += 1) {
        try writer.writeAll("    ");
    }

    // Check for lambda
    if (codegen.isLambda(code)) {
        const lambda_expr = try stack_mod.buildLambdaExpr(allocator, code, version);
        defer {
            lambda_expr.deinit(allocator);
            allocator.destroy(lambda_expr);
        }

        var cg = codegen.Writer.init(allocator);
        defer cg.deinit(allocator);
        try cg.writeExpr(allocator, lambda_expr);
        const output = try cg.getOutput(allocator);
        defer allocator.free(output);
        try writer.writeAll(output);
        try writer.writeByte('\n');
        return;
    }

    // Decorators are emitted from module-level AST output.

    // Write async if coroutine
    if (codegen.isCoroutine(code)) {
        try writer.writeAll("async ");
    }

    // Write function signature
    try writer.writeAll("def ");
    try writer.writeAll(code.name);
    try writer.writeByte('(');

    // Write arguments
    var first = true;
    const posonly = code.posonlyargcount;
    const argcount = code.argcount;
    const kwonly = code.kwonlyargcount;

    // Position-only and regular args
    for (code.varnames[0..@min(argcount, code.varnames.len)], 0..) |name, idx| {
        if (!first) try writer.writeAll(", ");
        first = false;
        try writer.writeAll(name);

        if (posonly > 0 and idx == posonly - 1) {
            try writer.writeAll(", /");
        }
    }

    // Keyword-only args
    if (kwonly > 0 and argcount + kwonly <= code.varnames.len) {
        if (posonly == 0 and argcount > 0) {
            try writer.writeAll(", ");
        }
        if (argcount == posonly) {
            try writer.writeAll("*, ");
        }
        for (code.varnames[argcount .. argcount + kwonly], 0..) |name, idx| {
            if (idx > 0 or argcount > 0) try writer.writeAll(", ");
            try writer.writeAll(name);
        }
    }

    try writer.writeAll("):\n");

    // Write docstring
    if (codegen.extractDocstring(code)) |doc| {
        i = 0;
        while (i < indent + 1) : (i += 1) {
            try writer.writeAll("    ");
        }
        try writer.writeAll("\"\"\"");
        // Escape newlines in docstring
        for (doc) |c| {
            if (c == '\n') {
                try writer.writeByte('\n');
                var j: u32 = 0;
                while (j < indent + 1) : (j += 1) {
                    try writer.writeAll("    ");
                }
            } else {
                try writer.writeByte(c);
            }
        }
        try writer.writeAll("\"\"\"\n");
    }

    // Decompile function body
    if (code.code.len > 0) {
        var pipe = DecompPipeline.init(allocator, code, version, opts, .function);
        defer pipe.deinit();
        try pipe.ensureRewrite(null);
        const effective_stmts = pipe.stmts orelse &.{};

        if (effective_stmts.len == 0) {
            // Empty body - write pass
            i = 0;
            while (i < indent + 1) : (i += 1) {
                try writer.writeAll("    ");
            }
            try writer.writeAll("pass\n");
        } else {
            // Write decompiled statements
            var cg = codegen.Writer.init(allocator);
            defer cg.deinit(allocator);
            cg.indent_level = indent + 1;

            for (effective_stmts) |stmt| {
                try cg.writeStmt(allocator, stmt);
            }

            const output = try cg.getOutput(allocator);
            defer allocator.free(output);
            try writer.writeAll(output);
        }
    } else {
        i = 0;
        while (i < indent + 1) : (i += 1) {
            try writer.writeAll("    ");
        }
        try writer.writeAll("pass\n");
    }
}

fn findCodeByPath(code: *const pyc.Code, path: []const u8) FocusError!*const pyc.Code {
    if (path.len == 0) return error.InvalidFocusPath;
    var it = std.mem.splitScalar(u8, path, '.');
    var cur = code;
    var first = true;
    while (it.next()) |seg| {
        if (seg.len == 0) return error.InvalidFocusPath;
        if (first) {
            if (std.mem.eql(u8, seg, "<module>") or std.mem.eql(u8, seg, cur.name)) {
                first = false;
                continue;
            }
        }
        first = false;
        var found: ?*const pyc.Code = null;
        for (cur.consts) |c| {
            const child = switch (c) {
                .code => c.code,
                .code_ref => c.code_ref,
                else => null,
            };
            if (child) |cc| {
                if (std.mem.eql(u8, cc.name, seg)) {
                    if (found == null) {
                        found = cc;
                    } else if (found.? != cc) {
                        return error.AmbiguousCodePath;
                    }
                }
            }
        }
        if (found == null) return error.CodePathNotFound;
        cur = found.?;
    }
    return cur;
}

const LineInfo = struct {
    text: []const u8,
    indent: usize,
    is_blank: bool,
};

const TopPadKind = enum { none, func, class };

const TopPadState = struct {
    seen: bool = false,
    prev_kind: TopPadKind = .none,
    prev_class_has_firstlineno: bool = false,
};

fn splitLines(allocator: Allocator, src: []const u8) ![]LineInfo {
    var lines: std.ArrayListUnmanaged(LineInfo) = .{};
    errdefer lines.deinit(allocator);
    var it = std.mem.splitScalar(u8, src, '\n');
    while (it.next()) |line| {
        const trimmed = std.mem.trim(u8, line, " \t\r");
        const is_blank = trimmed.len == 0;
        var indent: usize = 0;
        if (!is_blank) {
            while (indent < line.len and line[indent] == ' ') : (indent += 1) {}
        }
        try lines.append(allocator, .{
            .text = line,
            .indent = indent,
            .is_blank = is_blank,
        });
    }
    if (lines.items.len > 0) {
        const last = lines.items[lines.items.len - 1];
        if (last.is_blank and last.text.len == 0) {
            lines.items.len -= 1;
        }
    }
    return lines.toOwnedSlice(allocator);
}

const ChildCodes = struct {
    named: []const *const pyc.Code,
    anon: []const *const pyc.Code,
};

const AlignError = Allocator.Error;

const ChildState = struct {
    named: []const *const pyc.Code = &.{},
    anon: []const *const pyc.Code = &.{},
    named_idx: usize = 0,
    anon_idx: usize = 0,

    fn deinit(self: *ChildState, allocator: Allocator) void {
        if (self.named.len > 0) allocator.free(self.named);
        if (self.anon.len > 0) allocator.free(self.anon);
    }
};

fn collectChildCodeObjects(allocator: Allocator, code: *const pyc.Code) !ChildCodes {
    var named: std.ArrayListUnmanaged(*const pyc.Code) = .{};
    var anon: std.ArrayListUnmanaged(*const pyc.Code) = .{};
    errdefer {
        named.deinit(allocator);
        anon.deinit(allocator);
    }
    for (code.consts) |c| {
        const child = switch (c) {
            .code => c.code,
            .code_ref => c.code_ref,
            else => null,
        };
        if (child) |cc| {
            if (cc.name.len == 0) continue;
            if (cc.name[0] == '<') {
                try anon.append(allocator, cc);
            } else {
                try named.append(allocator, cc);
            }
        }
    }
    return .{
        .named = try named.toOwnedSlice(allocator),
        .anon = try anon.toOwnedSlice(allocator),
    };
}

fn initChildState(allocator: Allocator, code: ?*const pyc.Code) !ChildState {
    var state = ChildState{};
    if (code) |c| {
        const kids = try collectChildCodeObjects(allocator, c);
        state.named = kids.named;
        state.anon = kids.anon;
    }
    return state;
}

fn parseNameAfterPrefix(rest: []const u8) ?[]const u8 {
    if (rest.len == 0) return null;
    var end: usize = 0;
    while (end < rest.len) : (end += 1) {
        const c = rest[end];
        if (c == '(' or c == ':' or c == ' ' or c == '\t') break;
    }
    if (end == 0) return null;
    return rest[0..end];
}

fn parseDefName(line: []const u8, indent: usize) ?[]const u8 {
    if (line.len <= indent) return null;
    const rest = line[indent..];
    if (std.mem.startsWith(u8, rest, "async def ")) {
        return parseNameAfterPrefix(rest["async def ".len..]);
    }
    if (std.mem.startsWith(u8, rest, "def ")) {
        return parseNameAfterPrefix(rest["def ".len..]);
    }
    return null;
}

fn isAsyncDefLine(line: []const u8, indent: usize) bool {
    if (line.len <= indent) return false;
    return std.mem.startsWith(u8, line[indent..], "async def ");
}

fn parseClassName(line: []const u8, indent: usize) ?[]const u8 {
    if (line.len <= indent) return null;
    const rest = line[indent..];
    if (!std.mem.startsWith(u8, rest, "class ")) return null;
    return parseNameAfterPrefix(rest["class ".len..]);
}

fn isDecoratorLine(line: []const u8, indent: usize) bool {
    return line.len > indent and line[indent] == '@';
}

fn bodyHasFirstlineno(lines: []const LineInfo, start_idx: usize, indent: usize) bool {
    var i = start_idx;
    while (i < lines.len) : (i += 1) {
        const line = lines[i];
        if (line.is_blank) continue;
        if (line.indent != indent) return false;
        if (line.text.len <= indent) return false;
        const rest = line.text[indent..];
        return std.mem.startsWith(u8, rest, "__firstlineno__");
    }
    return false;
}

fn nextChildByName(children: []const *const pyc.Code, idx: *usize, name: []const u8) ?*const pyc.Code {
    var i = idx.*;
    while (i < children.len) : (i += 1) {
        if (std.mem.eql(u8, children[i].name, name)) {
            idx.* = i + 1;
            return children[i];
        }
    }
    return null;
}

fn nextAnonChild(children: []const *const pyc.Code, idx: *usize) ?*const pyc.Code {
    if (idx.* >= children.len) return null;
    const child = children[idx.*];
    idx.* += 1;
    return child;
}

fn lineHasAnonCode(line: []const u8, indent: usize) bool {
    if (line.len <= indent) return false;
    const rest = std.mem.trim(u8, line[indent..], " \t");
    if (std.mem.startsWith(u8, rest, "for ") or std.mem.startsWith(u8, rest, "async for ")) return false;
    if (std.mem.indexOf(u8, rest, "lambda") != null) return true;
    if (std.mem.indexOf(u8, rest, " for ") == null) return false;
    if (std.mem.indexOf(u8, rest, " in ") == null) return false;
    return true;
}

fn writeLine(out: *std.ArrayListUnmanaged(u8), allocator: Allocator, line: []const u8) AlignError!void {
    try out.appendSlice(allocator, line);
    try out.append(allocator, '\n');
}

fn padToLine(out: *std.ArrayListUnmanaged(u8), allocator: Allocator, line_no: *u32, target: u32) AlignError!void {
    while (line_no.* < target) {
        try out.append(allocator, '\n');
        line_no.* += 1;
    }
}

fn padToLineHeuristic(
    out: *std.ArrayListUnmanaged(u8),
    allocator: Allocator,
    line_no: *u32,
    target: u32,
    indent: usize,
    state: *TopPadState,
    cur_kind: TopPadKind,
    cur_async: bool,
) AlignError!void {
    _ = cur_async;
    if (target <= line_no.*) return;
    if (indent != 0) return;
    if (!state.seen) return;
    _ = cur_kind;
    try padToLine(out, allocator, line_no, target);
}

fn processBlockInner(
    allocator: Allocator,
    out: *std.ArrayListUnmanaged(u8),
    lines: []const LineInfo,
    idx: *usize,
    indent: usize,
    code: ?*const pyc.Code,
    base_line: u32,
    state: *ChildState,
    top_state: *TopPadState,
) AlignError!u32 {
    var line_no = base_line;

    while (idx.* < lines.len) {
        const line = lines[idx.*];
        if (!line.is_blank and line.indent < indent) break;

        if (line.is_blank) {
            try writeLine(out, allocator, line.text);
            line_no += 1;
            idx.* += 1;
            continue;
        }

        if (line.indent > indent) {
            line_no = try processBlockInner(allocator, out, lines, idx, line.indent, code, line_no, state, top_state);
            continue;
        }

        if (isDecoratorLine(line.text, indent)) {
            const deco_start = idx.*;
            var deco_count: usize = 0;
            while (deco_start + deco_count < lines.len) : (deco_count += 1) {
                const cur = lines[deco_start + deco_count];
                if (cur.is_blank or cur.indent != indent) break;
                if (!isDecoratorLine(cur.text, indent)) break;
            }
            const def_idx = deco_start + deco_count;
            if (def_idx < lines.len) {
                const def_line = lines[def_idx];
                if (!def_line.is_blank and def_line.indent == indent) {
                    const def_name = parseDefName(def_line.text, indent);
                    const cls_name = if (def_name == null) parseClassName(def_line.text, indent) else null;
                    const name = def_name orelse cls_name;
                    if (name) |nm| {
                        var child: ?*const pyc.Code = null;
                        if (state.named.len > 0) {
                            child = nextChildByName(state.named, &state.named_idx, nm);
                        }
                        const cur_kind: TopPadKind = if (def_name != null) .func else .class;
                        const cur_async = cur_kind == .func and isAsyncDefLine(def_line.text, indent);
                        if (child) |cc| {
                            if (cc.firstlineno > 0) {
                                try padToLineHeuristic(out, allocator, &line_no, cc.firstlineno, indent, top_state, cur_kind, cur_async);
                            }
                        }
                        var j: usize = 0;
                        while (j < deco_count) : (j += 1) {
                            try writeLine(out, allocator, lines[deco_start + j].text);
                            line_no += 1;
                        }
                        try writeLine(out, allocator, def_line.text);
                        line_no += 1;
                        idx.* = def_idx + 1;
                        const body_indent = indent + 4;
                        const class_has_firstlineno = indent == 0 and cur_kind == .class and bodyHasFirstlineno(lines, idx.*, body_indent);
                        line_no = try processBlock(allocator, out, lines, idx, body_indent, child, line_no, top_state);
                        if (indent == 0) {
                            top_state.seen = true;
                            top_state.prev_kind = cur_kind;
                            top_state.prev_class_has_firstlineno = class_has_firstlineno;
                        }
                        continue;
                    }
                }
            }
            // Not followed by def/class; emit decorators as-is.
            var j: usize = 0;
            while (j < deco_count) : (j += 1) {
                try writeLine(out, allocator, lines[deco_start + j].text);
                line_no += 1;
            }
            idx.* = deco_start + deco_count;
            continue;
        }

        const def_name = parseDefName(line.text, indent);
        const cls_name = if (def_name == null) parseClassName(line.text, indent) else null;
        const name = def_name orelse cls_name;
        if (name) |nm| {
            var child: ?*const pyc.Code = null;
            if (state.named.len > 0) {
                child = nextChildByName(state.named, &state.named_idx, nm);
            }
            const cur_kind: TopPadKind = if (def_name != null) .func else .class;
            const cur_async = cur_kind == .func and isAsyncDefLine(line.text, indent);
            if (child) |cc| {
                if (cc.firstlineno > 0) {
                    try padToLineHeuristic(out, allocator, &line_no, cc.firstlineno, indent, top_state, cur_kind, cur_async);
                }
            }
            try writeLine(out, allocator, line.text);
            line_no += 1;
            idx.* += 1;
            const body_indent = indent + 4;
            const class_has_firstlineno = indent == 0 and cur_kind == .class and bodyHasFirstlineno(lines, idx.*, body_indent);
            line_no = try processBlock(allocator, out, lines, idx, body_indent, child, line_no, top_state);
            if (indent == 0) {
                top_state.seen = true;
                top_state.prev_kind = cur_kind;
                top_state.prev_class_has_firstlineno = class_has_firstlineno;
            }
            continue;
        }

        if (state.anon.len > 0 and lineHasAnonCode(line.text, indent)) {
            if (nextAnonChild(state.anon, &state.anon_idx)) |cc| {
                _ = cc;
            }
        }

        try writeLine(out, allocator, line.text);
        line_no += 1;
        idx.* += 1;
        if (indent == 0 and !line.is_blank) {
            top_state.seen = true;
            top_state.prev_kind = .none;
            top_state.prev_class_has_firstlineno = false;
        }
    }

    return line_no;
}

fn processBlock(
    allocator: Allocator,
    out: *std.ArrayListUnmanaged(u8),
    lines: []const LineInfo,
    idx: *usize,
    indent: usize,
    code: ?*const pyc.Code,
    base_line: u32,
    top_state: *TopPadState,
) AlignError!u32 {
    var state = try initChildState(allocator, code);
    defer state.deinit(allocator);
    return processBlockInner(allocator, out, lines, idx, indent, code, base_line, &state, top_state);
}

fn alignDefLines(allocator: Allocator, code: *const pyc.Code, src: []const u8) AlignError![]const u8 {
    const lines = try splitLines(allocator, src);
    defer allocator.free(lines);
    var out: std.ArrayListUnmanaged(u8) = .{};
    errdefer out.deinit(allocator);
    var idx: usize = 0;
    const base_line: u32 = 1;
    var top_state = TopPadState{};
    _ = try processBlock(allocator, &out, lines, &idx, 0, code, base_line, &top_state);
    return out.toOwnedSlice(allocator);
}

// ============================================================================
// Tests
// ============================================================================

fn expectDecompileFixture(allocator: Allocator, path: []const u8) !void {
    var module: pyc.Module = undefined;
    module.init(allocator);
    defer module.deinit();
    try module.loadFromFile(path);

    try std.testing.expect(module.code != null);
    const code = module.code.?;
    const version = module.version();

    var out: std.ArrayListUnmanaged(u8) = .{};
    defer out.deinit(allocator);

    try decompileToSource(allocator, code, version, out.writer(allocator));
    try std.testing.expect(out.items.len > 0);
}

test "writeLine appends newline" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var out: std.ArrayListUnmanaged(u8) = .{};
    defer out.deinit(allocator);

    try writeLine(&out, allocator, "hi");
    try testing.expectEqualStrings("hi\n", out.items);
}

test "decompiler init" {
    const testing = std.testing;
    const allocator = testing.allocator;

    // Create minimal code object
    var code = pyc.Code{
        .allocator = allocator,
        .name = "test",
        .code = &.{},
    };

    const version = Version.init(3, 12);

    var decompiler = try Decompiler.init(allocator, &code, version);
    defer decompiler.deinit();

    try testing.expectEqual(@as(usize, 0), decompiler.cfg.blocks.len);
    try testing.expectEqual(@as(usize, 0), decompiler.statements.items.len);
    try testing.expectEqual(@as(usize, 0), decompiler.print_items.items.len);
}

test "takeDecorators drains list" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 12);

    var code = pyc.Code{
        .allocator = allocator,
        .name = "decorators",
        .code = &.{},
    };

    var decompiler = try Decompiler.init(allocator, &code, version);
    defer decompiler.deinit();

    var decorators: std.ArrayListUnmanaged(*Expr) = .{};
    defer decorators.deinit(allocator);

    const expr = try decompiler.makeRawName("dec", .load);
    try decorators.append(allocator, expr);

    const out = try decompiler.takeDecorators(&decorators);
    try testing.expectEqual(@as(usize, 1), out.len);
    try testing.expectEqual(@as(usize, 0), decorators.items.len);
}

test "runStackSSA hard-fails iteration cap" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 9);

    const ops = [_]test_utils.OpArg{
        .{ .op = .LOAD_CONST, .arg = 0 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
    };
    const bytecode = try test_utils.emitOpsOwned(allocator, version, &ops);
    const consts = [_]pyc.Object{.{ .none = {} }};
    const code = try test_utils.allocCode(
        allocator,
        "ssa_iter",
        &[_][]const u8{},
        &consts,
        bytecode,
        1,
    );
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    var worklist: std.ArrayListUnmanaged(u32) = .{};
    defer worklist.deinit(allocator);
    const block_count: u32 = @intCast(decompiler.cfg.blocks.len);
    try testing.expect(block_count > 0);
    const max_iterations: usize = @as(usize, block_count) * 100;
    try worklist.ensureTotalCapacity(allocator, max_iterations + 1);
    var i: usize = 0;
    while (i < max_iterations + 1) : (i += 1) {
        try worklist.append(allocator, 0);
    }

    var clone_sim = decompiler.initSim(decompiler.arena.allocator(), decompiler.arena.allocator(), code, version);
    defer clone_sim.deinit();

    var flow_arena = std.heap.ArenaAllocator.init(allocator);
    defer flow_arena.deinit();

    try testing.expectError(error.InvalidStackDepth, decompiler.runStackSSA(&worklist, &clone_sim, null, &flow_arena));
    try testing.expect(decompiler.last_error_ctx != null);
    const ctx = decompiler.last_error_ctx.?;
    try testing.expectEqualStrings("stackflow_iter_limit", ctx.opcode);
}

test "simOpt soft errors return PatternNoMatch" {
    const testing = std.testing;
    const allocator = testing.allocator;

    var code = pyc.Code{
        .allocator = allocator,
        .name = "simopt",
        .code = &.{},
    };

    const version = Version.init(3, 9);
    var decompiler = try Decompiler.init(allocator, &code, version);
    defer decompiler.deinit();

    var sim = decompiler.initSim(decompiler.arena.allocator(), decompiler.arena.allocator(), &code, version);
    defer sim.deinit();

    const inst = decoder.Instruction{
        .opcode = .DUP_TOP,
        .arg = 0,
        .offset = 0,
        .size = 2,
        .cache_entries = 0,
    };

    try testing.expectError(error.PatternNoMatch, decompiler.simOpt(&sim, inst));
}

test "simulate condition expr returns null on sim error" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 9);

    const ops = [_]test_utils.OpArg{
        .{ .op = .BINARY_ADD, .arg = 0 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
    };

    const bytecode = try test_utils.emitOpsOwned(allocator, version, &ops);
    const code = try test_utils.allocCode(
        allocator,
        "bad_cond",
        &[_][]const u8{},
        &[_]pyc.Object{},
        bytecode,
        0,
    );
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    var stmts: std.ArrayListUnmanaged(*Stmt) = .{};
    defer stmts.deinit(allocator);
    try testing.expect((try decompiler.initCondSim(0, &stmts, allocator)) == null);
    try testing.expectEqual(@as(usize, 0), stmts.items.len);
    try testing.expect((try decompiler.simulateConditionExpr(0, &.{})) == null);
}

test "simulate condition expr propagates unsupported constant" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 9);

    const inner_ops = [_]test_utils.OpArg{
        .{ .op = .LOAD_CONST, .arg = 0 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
    };
    const inner_consts = [_]pyc.Object{.{ .none = {} }};
    const inner_code = try test_utils.allocCodeFromOps(
        allocator,
        version,
        "inner",
        &[_][]const u8{},
        &inner_consts,
        &inner_ops,
        0,
    );
    var inner_owned = true;
    errdefer if (inner_owned) {
        inner_code.deinit();
        allocator.destroy(inner_code);
    };

    const tuple_items = try allocator.alloc(pyc.Object, 1);
    var tuple_owned = true;
    errdefer if (tuple_owned) allocator.free(tuple_items);
    tuple_items[0] = .{ .code = inner_code };

    const consts = [_]pyc.Object{
        .{ .tuple = tuple_items },
        .{ .none = {} },
    };
    const ops = [_]test_utils.OpArg{
        .{ .op = .JUMP_FORWARD, .arg = 8 },
        .{ .op = .LOAD_CONST, .arg = 0 },
        .{ .op = .POP_JUMP_IF_FALSE, .arg = 8 },
        .{ .op = .LOAD_CONST, .arg = 1 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
        .{ .op = .LOAD_CONST, .arg = 1 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
    };

    const bytecode = try test_utils.emitOpsOwned(allocator, version, &ops);
    const code = try test_utils.allocCode(
        allocator,
        "bad_const",
        &[_][]const u8{},
        &consts,
        bytecode,
        0,
    );
    inner_owned = false;
    tuple_owned = false;
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    const bad_block = decompiler.cfg.blockAtOffset(2) orelse return error.InvalidBlock;
    try testing.expectError(error.UnsupportedConstant, decompiler.simulateConditionExpr(bad_block, &.{}));
}

test "condReach uses scratch and finds path" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 9);

    const ops = [_]test_utils.OpArg{
        .{ .op = .LOAD_CONST, .arg = 0 },
        .{ .op = .POP_JUMP_IF_FALSE, .arg = 8 },
        .{ .op = .LOAD_CONST, .arg = 1 },
        .{ .op = .JUMP_FORWARD, .arg = 2 },
        .{ .op = .LOAD_CONST, .arg = 2 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
    };

    const bytecode = try test_utils.emitOpsOwned(allocator, version, &ops);
    const consts = [_]pyc.Object{ .{ .none = {} }, .{ .none = {} }, .{ .none = {} } };
    const code = try test_utils.allocCode(
        allocator,
        "cond_reach",
        &[_][]const u8{},
        &consts,
        bytecode,
        0,
    );
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    const start = decompiler.cfg.entry;
    try testing.expect(decompiler.cfg.blocks[start].successors.len > 0);
    const target = decompiler.cfg.blocks[start].successors[0].target;
    const skip = std.math.maxInt(u32);
    try testing.expect(try decompiler.condReach(start, target, skip, skip));
}

test "exception seed handles JUMP_IF_NOT_EXC_MATCH" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 9);

    const ops = [_]test_utils.OpArg{
        .{ .op = .DUP_TOP, .arg = 0 },
        .{ .op = .LOAD_GLOBAL, .arg = 0 },
        .{ .op = .JUMP_IF_NOT_EXC_MATCH, .arg = 16 },
        .{ .op = .POP_TOP, .arg = 0 },
        .{ .op = .STORE_FAST, .arg = 0 },
        .{ .op = .POP_TOP, .arg = 0 },
        .{ .op = .LOAD_CONST, .arg = 0 },
        .{ .op = .RETURN_VALUE, .arg = 0 },
        .{ .op = .POP_TOP, .arg = 0 },
        .{ .op = .POP_TOP, .arg = 0 },
        .{ .op = .POP_TOP, .arg = 0 },
        .{ .op = .RERAISE, .arg = 0 },
    };

    const bytecode = try test_utils.emitOpsOwned(allocator, version, &ops);
    const consts = [_]pyc.Object{.{ .none = {} }};
    const code = try test_utils.allocCodeWithNames(
        allocator,
        "exc_seed",
        &[_][]const u8{"e"},
        &[_][]const u8{"Exception"},
        &consts,
        bytecode,
        0,
    );
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var out: std.ArrayListUnmanaged(u8) = .{};
    defer out.deinit(allocator);
    try decompileToSource(allocator, code, version, out.writer(allocator));
    try testing.expect(out.items.len > 0);
}

test "handler end 311 picks postdom pop_except" {
    const testing = std.testing;
    const allocator = testing.allocator;
    const version = Version.init(3, 11);

    const bytecode = try test_utils.emitOpsOwned(allocator, version, &.{});
    const code = try test_utils.allocCode(
        allocator,
        "handler_end_311",
        &[_][]const u8{},
        &[_]pyc.Object{},
        bytecode,
        0,
    );
    defer {
        code.deinit();
        allocator.destroy(code);
    }

    var decompiler = try Decompiler.init(allocator, code, version);
    defer decompiler.deinit();

    const a = decompiler.allocator;

    const inst0 = try a.alloc(decoder.Instruction, 1);
    inst0[0] = test_utils.inst(.NOP, 0);
    const inst1 = try a.alloc(decoder.Instruction, 1);
    inst1[0] = test_utils.inst(.POP_EXCEPT, 0);
    const inst2 = try a.alloc(decoder.Instruction, 1);
    inst2[0] = test_utils.inst(.NOP, 0);
    const inst3 = try a.alloc(decoder.Instruction, 1);
    inst3[0] = test_utils.inst(.POP_EXCEPT, 0);
    const inst4 = try a.alloc(decoder.Instruction, 1);
    inst4[0] = test_utils.inst(.RETURN_VALUE, 0);

    const succ0 = try a.alloc(cfg_mod.Edge, 2);
    succ0[0] = .{ .target = 1, .edge_type = .conditional_true };
    succ0[1] = .{ .target = 2, .edge_type = .conditional_false };
    const succ1 = try a.alloc(cfg_mod.Edge, 1);
    succ1[0] = .{ .target = 3, .edge_type = .normal };
    const succ2 = try a.alloc(cfg_mod.Edge, 1);
    succ2[0] = .{ .target = 3, .edge_type = .normal };
    const succ3 = try a.alloc(cfg_mod.Edge, 1);
    succ3[0] = .{ .target = 4, .edge_type = .normal };
    const succ4 = &[_]cfg_mod.Edge{};

    const pred0 = &[_]u32{};
    const pred1 = try a.alloc(u32, 1);
    pred1[0] = 0;
    const pred2 = try a.alloc(u32, 1);
    pred2[0] = 0;
    const pred3 = try a.alloc(u32, 2);
    pred3[0] = 1;
    pred3[1] = 2;
    const pred4 = try a.alloc(u32, 1);
    pred4[0] = 3;

    const blocks = try a.alloc(BasicBlock, 5);
    blocks[0] = .{
        .id = 0,
        .start_offset = 0,
        .end_offset = 2,
        .instructions = inst0,
        .successors = succ0,
        .predecessors = pred0,
        .is_exception_handler = false,
        .is_loop_header = false,
    };
    blocks[1] = .{
        .id = 1,
        .start_offset = 10,
        .end_offset = 12,
        .instructions = inst1,
        .successors = succ1,
        .predecessors = pred1,
        .is_exception_handler = false,
        .is_loop_header = false,
    };
    blocks[2] = .{
        .id = 2,
        .start_offset = 20,
        .end_offset = 22,
        .instructions = inst2,
        .successors = succ2,
        .predecessors = pred2,
        .is_exception_handler = false,
        .is_loop_header = false,
    };
    blocks[3] = .{
        .id = 3,
        .start_offset = 30,
        .end_offset = 32,
        .instructions = inst3,
        .successors = succ3,
        .predecessors = pred3,
        .is_exception_handler = false,
        .is_loop_header = false,
    };
    blocks[4] = .{
        .id = 4,
        .start_offset = 40,
        .end_offset = 42,
        .instructions = inst4,
        .successors = succ4,
        .predecessors = pred4,
        .is_exception_handler = false,
        .is_loop_header = false,
    };

    const offsets = try a.alloc(u32, 5);
    offsets[0] = 0;
    offsets[1] = 10;
    offsets[2] = 20;
    offsets[3] = 30;
    offsets[4] = 40;

    const all_insts = try a.alloc(decoder.Instruction, 0);

    const cfg = try a.create(CFG);
    cfg.* = .{
        .allocator = a,
        .blocks = blocks,
        .block_offsets = offsets,
        .entry = 0,
        .instructions = all_insts,
        .exception_entries = &.{},
        .version = version,
    };

    decompiler.cfg = cfg;
    if (decompiler.postdom_idom) |idom| {
        decompiler.allocator.free(idom);
        decompiler.postdom_idom = null;
    }

    const end = try decompiler.computeHandlerEnd311(0);
    try testing.expectEqual(@as(u32, 4), end);
}

test "exception handler decompile frees allocations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    const paths = [_][]const u8{
        "refs/pycdc/tests/compiled/async_for.3.7.pyc",
        "refs/pycdc/tests/compiled/try_except_finally.2.6.pyc",
    };

    for (paths) |path| {
        try expectDecompileFixture(allocator, path);
    }
}

test "while loop decompile frees allocations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "refs/pycdc/tests/compiled/while_loop.2.6.pyc");
}

test "list comprehension decompile frees allocations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "refs/pycdc/tests/compiled/test_listComprehensions.2.7.pyc");
}

test "loops2 decompile frees allocations" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "refs/pycdc/tests/compiled/test_loops2.2.2.pyc");
}

test "py_compile decompile 3.14" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "test/corpus/py_compile.3.14.pyc");
}

test "pyimod02_importers decompile 3.9" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "test/corpus/pyimod02_importers.3.9.pyc");
}

test "pyimod03_ctypes decompile 3.9" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "test/corpus/pyimod03_ctypes.3.9.pyc");
}

test "sysconfig decompile 3.9" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "test/corpus/sysconfig.3.9.pyc");
}

test "concurrent futures process decompile 3.9" {
    const testing = std.testing;
    const allocator = testing.allocator;

    try expectDecompileFixture(allocator, "test/corpus/concurrent_futures_process.3.9.pyc");
}

test "genset reuse" {
    const allocator = std.testing.allocator;
    var set = try GenSet.init(allocator, 4);
    defer set.deinit(allocator);

    try set.set(allocator, 1);
    try std.testing.expect(set.isSet(1));
    try std.testing.expect(set.list.items.len == 1);

    set.reset();
    try std.testing.expect(!set.isSet(1));
    try std.testing.expect(set.list.items.len == 0);

    try set.set(allocator, 1);
    try std.testing.expect(set.isSet(1));
    try std.testing.expect(set.list.items.len == 1);
}
